(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{1124:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iNDcxLjQ0NHB4IiBoZWlnaHQ9Ijg3LjEzNHB4IiB2aWV3Qm94PSIwIDAgNDcxLjQ0NCA4Ny4xMzQiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDQ3MS40NDQgODcuMTM0Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxyZWN0IHg9IjMxMS4wOTUiIHk9IjY2LjUzMyIgZmlsbD0iIzAwRkY5QyIgd2lkdGg9IjEzOS43NzkiIGhlaWdodD0iMTAiLz4NCjxyZWN0IHg9IjI4NS42NTEiIHk9Ijc2LjUzMyIgZmlsbD0iIzAwRkY5QyIgd2lkdGg9IjI1LjQ0NCIgaGVpZ2h0PSIxMCIvPg0KPGNpcmNsZSBmaWxsPSIjMDBGRjlDIiBjeD0iNDY1Ljg3NSIgY3k9IjcxLjUzMiIgcj0iNSIvPg0KPGc+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTE3LjQyOSw1MS41MDlMMC40NDQsMS40OTloOC4zOTFsMTEuNDM3LDM1LjY2NEwzMi45MjYsMS40OTloNC4xMjhMNDkuOTgsMzcuMTYzTDYxLjIxMywxLjQ5OWg4LjM5Mg0KCQlsLTE2LjkxOCw1MC4wMWgtNS4yMTFMMzUuMDkyLDE1LjY0M0wyMi43NzYsNTEuNTA5SDE3LjQyOXoiLz4NCgk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNOTkuMzEzLDE1LjAzNGg3LjE3NHYzNi40NzZoLTcuMTc0di01LjAwOGMtMy4zMTYsMy45MjUtNy41MTIsNS44ODgtMTIuNDUxLDUuODg4DQoJCWMtNS4yMTEsMC05LjYxLTEuODI2LTEzLjA2MS01LjU0OWMtMy40NTItMy43MjMtNS4xNDMtOC4zMjQtNS4xNDMtMTMuODA2YzAtNS40ODEsMS42OTEtOS45NDgsNS4xNDMtMTMuNTM1DQoJCWMzLjQ1MS0zLjU4Niw3Ljg1LTUuMzQ2LDEzLjA2MS01LjM0NmM0LjkzOSwwLDkuMTM1LDEuOTYyLDEyLjQ1MSw1Ljk1NVYxNS4wMzR6IE05Ni4zMzUsNDEuOTY3DQoJCWMyLjIzMy0yLjM2OCwzLjMxNi01LjI3OCwzLjMxNi04LjcyOWMwLTMuMzgzLTEuMDgzLTYuMjk0LTMuMzE2LTguNjYyYy0yLjIzMy0yLjM2OS01LjAwOC0zLjU4Ni04LjQ1OS0zLjU4Ng0KCQlzLTYuMjkzLDEuMjE4LTguNDU5LDMuNTg2Yy0yLjE2NiwyLjM2OC0zLjI0OCw1LjI3OS0zLjI0OCw4LjczczEuMDgzLDYuMzYxLDMuMjQ4LDguNzI5czUuMDA4LDMuNTE5LDguNDU5LDMuNTE5DQoJCVM5NC4xMDMsNDQuMzM2LDk2LjMzNSw0MS45Njd6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTEzOC42ODUsNTEuNTA5bC0xMy4xMjgtMTYuNThsLTMuMTgxLDIuOTF2MTMuNjdoLTcuNDQ0VjAuMjEzaDcuNDQ0djI4Ljg5NmwxNS4zNjEtMTQuMDc2aDkuODEyDQoJCWwtMTYuNzgzLDE1LjE1OWwxNy41MjcsMjEuMzE3SDEzOC42ODV6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTE4My42NTQsMzYuMTQ3aC0yOC40OWMxLjA4Myw1LjY4NSw1LjA3Niw5LjU0MiwxMi4xMTMsOS41NDJjNC4xMjgsMCw5LjEzNi0xLjU1NywxMi4zODQtMy45MjYNCgkJbDMuMTEzLDUuNDgyYy0zLjcyMiwyLjc3My05LjYwOSw1LjA3NC0xNS43NjgsNS4wNzRjLTEzLjY3LDAtMTkuNTU3LTkuNTQyLTE5LjU1Ny0xOS4xNTFjMC01LjQ4MSwxLjY5Mi0xMC4wMTYsNS4xNDMtMTMuNjAyDQoJCWMzLjQ1MS0zLjU4Nyw3Ljk4NS01LjQxNCwxMy40NjctNS40MTRjNS4yMTEsMCw5LjU0MiwxLjYyNCwxMi44NTgsNC45NGMzLjMxNiwzLjMxNiw1LjAwOCw3Ljc4Miw1LjAwOCwxMy40NjcNCgkJQzE4My45MjUsMzMuNTc2LDE4My44NTcsMzQuNzk0LDE4My42NTQsMzYuMTQ3eiBNMTU1LjE2NCwzMC4wNTdoMjEuMjVjLTAuNjA5LTUuNzUyLTQuODczLTkuNDc0LTEwLjM1NC05LjQ3NA0KCQlDMTYwLjQ0MiwyMC41ODMsMTU2LjI0NywyNC4zNzIsMTU1LjE2NCwzMC4wNTd6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTIwNy40NzUsMzYuNTU0di0yMS41Mmg3LjQ0NHYyMS40NTJjMCw1LjQ4MSwzLjE4LDkuMDAxLDguNTI2LDkuMDAxYzUuNDE0LDAsOC41MjctMy4zODQsOC41MjctOS4wMDENCgkJVjE1LjAzNGg3LjUxMXYyMS41MmMwLDkuOTQ4LTYuMDIyLDE1LjgzNS0xNi4wMzgsMTUuODM1QzIxMy43MDEsNTIuMzg5LDIwNy40NzUsNDYuMjk4LDIwNy40NzUsMzYuNTU0eiIvPg0KCTxwYXRoIGZpbGw9IiMwMEZGOUMiIGQ9Ik0yODAuNDQsMTkuNzAzYzMuNDUyLDMuNzIyLDUuMjExLDguMjU2LDUuMjExLDEzLjYwM2MwLDUuMzQ2LTEuNzU5LDkuODEyLTUuMjExLDEzLjUzNQ0KCQljLTMuNDUxLDMuNzIzLTcuNzgyLDUuNTQ5LTEyLjk5Myw1LjU0OWMtNS4wNzUsMC05LjI3MS0xLjk2My0xMi40NTEtNS45NTV2MjAuMDk5aC03LjQ0NFYxNS4wMzRoNy40NDR2NS4yNzkNCgkJYzMuMzE1LTQuMTI4LDcuNTEyLTYuMTU5LDEyLjUyLTYuMTU5QzI3Mi43MjYsMTQuMTU0LDI3Ni45ODksMTUuOTgxLDI4MC40NCwxOS43MDN6IE0yNzQuODkxLDI0LjU3Ng0KCQljLTIuMTY1LTIuMzY5LTUuMDA4LTMuNTg2LTguNDU5LTMuNTg2cy02LjI5NCwxLjIxOC04LjQ1OSwzLjU4NmMtMi4wOTksMi4zNjgtMy4xODEsNS4yMS0zLjE4MSw4LjY2Mg0KCQljMCwzLjQ1MSwxLjA4Miw2LjQyOSwzLjE4MSw4Ljc5N2MyLjE2NSwyLjM2OSw1LjAwOCwzLjUxOSw4LjQ1OSwzLjUxOXM2LjI5NC0xLjE1LDguNDU5LTMuNTE5czMuMjQ4LTUuMzQ2LDMuMjQ4LTguNzk3DQoJCUMyNzguMTM5LDI5Ljc4NiwyNzcuMDU2LDI2Ljk0NCwyNzQuODkxLDI0LjU3NnoiLz4NCgk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMzQ0LjMyMywxLjQ5OWg3LjcxNXY1MC4wMWgtNC42MDJMMzE4LjgxLDE3LjYwNXYzMy45MDRoLTcuNzE1VjEuNDk5aDQuMDYxbDI5LjE2NywzNC4xNzVWMS40OTl6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTM2Mi42NzYsNTEuNTA5VjEuNDk5aDMxLjk0MXY3LjM3NmgtMjQuMTU5djEzLjYwMmgyMi4zOTl2Ny4zNzdoLTIyLjM5OXYxNC4yNzhoMjQuMjI3djcuMzc2SDM2Mi42NzZ6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTQwNi4zNDUsNDQuOTQ1Yy00LjkzOS00Ljk0LTcuMzc2LTExLjAzMS03LjM3Ni0xOC4yMDRjMC03LjI0MSwyLjUwNC0xMy4zOTksNy41NzktMTguNDc1DQoJCWM1LjA3Ni01LjA3NiwxMS4xNjYtNy42NDYsMTguMzQtNy42NDZjNy4yNCwwLDEzLjMzMSwyLjUwMywxOC40MDYsNy41NzljNS4wNzYsNS4wNzYsNy41OCwxMS4xNjYsNy41OCwxOC4zMzkNCgkJcy0yLjUwNCwxMy4yNjQtNy41OCwxOC4yNzFjLTUuMDc1LDUuMDA3LTExLjIzMyw3LjUxMS0xOC42MDksNy41MTFDNDE3LjQ0NCw1Mi4zMjEsNDExLjI4Niw0OS44ODUsNDA2LjM0NSw0NC45NDV6DQoJCSBNNDM3LjU0MiwzOS41MzFjMy40NTEtMy40NTEsNS4yMTEtNy43ODIsNS4yMTEtMTIuOTI1YzAtNS4yMTEtMS43Ni05LjYxLTUuMjExLTEzLjA2MXMtNy42NDYtNS4yMTEtMTIuNjU0LTUuMjExDQoJCWMtNC45NCwwLTkuMjA0LDEuNzYtMTIuNjU1LDUuMjc5Yy0zLjQ1MSwzLjQ1MS01LjE0Myw3Ljc4Mi01LjE0MywxMi45OTNjMCw1LjA3NSwxLjY5MSw5LjQwNiw1LjA3NSwxMi44NTcNCgkJYzMuNDUxLDMuNDUyLDcuNjQ2LDUuMjExLDEyLjcyMyw1LjIxMUM0MjkuODk2LDQ0LjY3NCw0MzQuMDkxLDQyLjk4Miw0MzcuNTQyLDM5LjUzMXoiLz4NCjwvZz4NCjwvc3ZnPg0K"},1125:function(e,n){e.exports={tokenomics:{title:"Tokens, ICOs and DApps, oh my!",description:"Create a token, launch an initial coin offering (ICO) and build a simple escrow dapp that uses the token.",image:"contract",lessons:[{title:"Make your own Token",documentation:"# Welcome!\n\nSo you want to create your own Token? Maybe even hold an ICO to raise millions? Well you've come to the right place. This course will teach you how to do all of that and more on the NEO blockchain.\n\n__Let's get started!__\n",chapters:[{title:"Contracts",documentation:"# Chapter 1: Contracts\n\nIn Lesson 1, we're going to build a token smart contract for the NEO blockchain from scratch. The token will\n\n - Expose constants like the token name, symbol and decimals.\n - Maintain a mapping from token holder to amount held.\n - Allow looking up a token holder's balance.\n - Enable transfers between users.\n - Emit an event for every transfer.\n\nIn later lessons we'll add more functionality like pre-approving transfers and forwarding arguments to other contracts.\n\nBefore getting started, let's familiarize ourselves with the editor. The editor works similar to VSCode - errors show up inline, and you can hover over code to get inline help. The editor toolbar at the bottom has two buttons that will be used frequently throughout the course. `Build` compiles the smart contract code - files that end with `.one.ts` in the editor. When you click `Build`, the smart contract is compiled and deployed on a private NEO blockchain running in your browser. `Run Tests` runs the Jest tests - files that end with `.test.ts`. The tests interact with the contract running on the blockchain and verify the contract works the way we expect. Each chapter will have a set of tests which must pass before proceeding to the next chapter. If you ever get stuck, you can always click `Show Solution` and copy the code into the editor.\n\n## Expected Knowledge\n\nThroughout the course we'll be using TypeScript. It's not necessary to have prior experience with TypeScript, but you may want to keep the TypeScript [documentation](http://www.typescriptlang.org/docs/home.html) handy. We'll also include links to the TypeScript handbook throughout the documentation.\n\nThe course assumes some knowledge of blockchain and NEO concepts, though you don't need to be an expert. Reading through the [Blockchain Basics](/docs/blockchain-basics) chapter of the main guide will sufficiently prepare you for the course.\n\n## Learn\n\nEvery NEO•ONE smart contract starts with a TypeScript source file that exports a single class extending `SmartContract`. The simplest smart contract looks like\n\n```typescript\nimport { SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {}\n```\n\nLet's break this down. First, we import `SmartContract` from `@neo-one/smart-contract`. This package contains all of the NEO•ONE smart contract types and is where the majority of imports will come from. `SmartContract` is a basic [class](https://www.typescriptlang.org/docs/handbook/classes.html) that when extended marks the class as a NEO•ONE smart contract. We've extended it with a class called `Example` which will be used for all of the generated variable names in the NEO•ONE client APIs.\n\n## Instructions\n\n  1. Enter the following into the `Token.one.ts` file:\n\n```typescript\nimport { SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {}\n```\n\nThis is the shell of a token smart contract. Since we named it `Token`, the variable name `token` will be used in the generated NEO•ONE client APIs. You can see some of the auto-generated code in action in the `Token.test.ts` file. Notice how the `withContracts` helper passes an object with a property called `token`.\n\n## Test\n\nAt this point, we have a basic compilable NEO•ONE smart contract. Go ahead and click the `Build` button in editor toolbar at the bottom right-hand side to compile the smart contract. Then click the `Run Tests` button to verify the smart contract. Once the tests pass, you may proceed to the next chapter by clicking `Next`.\n\n## Wrap Up\n\n`Token.test.ts` is very basic right now, it just checks that the `Token` smart contract exists and was compiled correctly. In later chapters we'll explore the NEO•ONE client APIs which are used to interact with smart contracts both in the front-end and in tests.\n\nIf you ever get stuck, click the `Help` link in the editor toolbar for information on where to get help, including a link to the NEO•ONE [Discord](https://discord.gg/S86PqDE) where you can get live help. See the solution for a particular chapter by clicking `Show Solution` at the bottom of the course material.\n",files:[{path:"one/contracts/Token.one.ts",initial:"",solution:"import { SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {}\n"},{path:"one/tests/Token.test.ts",solution:"import { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('deploys', async () => {\n    await withContracts(async ({ token }) => {\n      // withContracts automatically publishes and deploys the contract\n      // so if it doesn't fail and token exists, then the contract was written correctly.\n      expect(token).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Contract Properties",documentation:"# Chapter 2: Contract Properties\n\nGreat job! Now that we have a shell for our contract, let's learn how to add a few constant properties.\n\n## Learn\n\nWe'll start by adding [readonly](https://www.typescriptlang.org/docs/handbook/classes.html#readonly-modifier) constant properties. Just like regular TypeScript, `readonly` properties cannot be changed. Marking a property as [public](https://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers) will generate a smart contract method with the same name for accessing the property. Note that even if a property is marked as [private](https://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers), all contract code and storage is publicly accessible, so nothing is ever truly private.\n\nLet's take a look at an example:\n\n```typescript\nexport class Example extends SmartContract {\n  public readonly myStringProperty = 'foo';\n}\n```\n\nIn this example contract we created a [string](https://www.typescriptlang.org/docs/handbook/basic-types.html#string) property called `myStringProperty`. Smart contract callers can read this property by calling the `myStringProperty` method on the smart contract. Using the NEO•ONE client APIs, the property would be accessed as `example.myStringProperty()`.\n\n## Instructions\n\nLet's call the token 'Eon', give it the symbol 'EON' and make it have 8 decimals. We can represent this by adding a few properties to the smart contract:\n\n  1. Add a property called `name`, a `string` with the value `'Eon'`.\n  2. Add a property called `symbol`, a `string` property with the value `'EON'`.\n  3. Add a property called `decimals`, a `number` property with the value `8`.\n\n## Test\n\nNow that we've added the properties, `Build` the contract and then `Run Tests`. Remember, if you ever get stuck feel free to take a look at the solution code by clicking `Show Solution` at the bottom of the page.\n\nTake a look at the updated `Token.test.ts` file to see the newly generated methods on the `token` variable - one for each of the properties that were added to the contract. Hover over the method calls and you'll notice that the properties have the same types as in the smart contract, except they're wrapped in a `Promise`. They are all wrapped in a `Promise` because they require an asynchronous action - we need to make a request to a node to determine the current value. As we continue through the chapters, be sure to hover over the various pieces of the test code to learn a bit about how the generated NEO•ONE client APIs are structured.\n\n## Wrap Up\n\nIn this chapter we learned how to declare constant properties in a NEO•ONE smart contract. When you're ready, click `Next` to learn about storage properties!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {}\n",solution:"import { SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has name, symbol and decimals properties', async () => {\n    await withContracts(async ({ token }) => {\n      expect(token).toBeDefined();\n\n      const [name, symbol, decimals] = await Promise.all([token.name(), token.symbol(), token.decimals()]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Contract Storage",documentation:"# Chapter 3: Storage Properties\n\nAwesome work! Next up is learning about storage properties. We'll also write our first constant method! As a heads up, this chapter is a beefy one because we need to introduce quite a few concepts in order to have a fully functioning contract.\n\n## Learn\n\nContract properties that are not `readonly` are automatically stored inside of contract storage, meaning they persist between invocations of methods of your smart contract. In order to understand what that means a bit more clearly, let's take a step back and talk about what happens when you deploy your smart contract.\n\nEvery NEO•ONE smart contract has an automatically generated method called `deploy` which is based on the `constructor` of your smart contract. It's created whether or not you have an explicit constructor and must be invoked when the contract is published to the blockchain to initialize it. Using the NEO•ONE client APIs, the `deploy` method is called automatically and atomically when the contract is published, so you never have to worry about it.\n\nNow, back to contract storage properties. The way to think about how the smart contract we're building works is that when it's published to the blockchain we construct it, i.e. we call the equivalent of `new Token()`. Then for every invocation we use that one instance, so any changes to storage properties are persisted between invocations. In short, our smart contract follows the [singleton pattern](https://en.wikipedia.org/wiki/Singleton_pattern).\n\nLet's take a look at an example:\n\n```typescript\nimport { Fixed, SmartContract, constant } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  private mutableMyFixedProperty: Fixed<8> = 8_00000000;\n\n  @constant\n  public get myFixedProperty(): Fixed<8> {\n    return this.mutableMyFixedProperty;\n  }\n}\n```\n\nIn this example we created a mutable `Fixed<8>` property called `mutableMyFixedProperty`. Let's break this down. It initially has the value of `8_00000000` when the smart contract is published and deployed, i.e. the same as if we had constructed it using `new Example()`. Whenever we change the value of the property, it will be persisted between invocations.\n\nWe've also introduced a few other concepts here. The first is the `Fixed` [type](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases) - this type has no impact on how the smart contract executes, but it does change how the automatically generated NEO•ONE client APIs function. All numbers in a NEO smart contract must be integers (up to 256 bits, to be precise), so typically we use an integer multiplied by a power of 10 to represent decimals. In this case, `Fixed<8>` is telling the compiler that this number actually represents a fixed point number with 8 decimal places. Notice how we also use the underscore syntax to help relay that fact as well - rather than `800000000` we use `8_00000000` so that it's clearer to the reader that the `mutableMyFixedProperty` actually represents `8.00000000` and not `800000000`. The NEO•ONE client APIs use this information to return [BigNumbers](https://github.com/MikeMcl/bignumber.js/) with the correct number of decimal places, so in this case, if we called `example.myFixedProperty()` we would receive a `BigNumber` with the value of `8`. That was quite a bit of explanation and if it doesn't make perfect sense right now, don't worry, it'll become clearer as we move through the chapters and add more tests.\n\nFinally, we have our first method, a [getter](https://www.typescriptlang.org/docs/handbook/classes.html#accessors) that's been [decorated](https://www.typescriptlang.org/docs/handbook/decorators.html#decorators) with `@constant`. This just tells the compiler that the method does not modify any storage properties, and thus can be invoked without submitting a transaction to the blockchain. Again, this will become more clear once we see how non-constant methods are invoked in later chapters.\n\n## Instructions\n\nPhew, that was a lot of information to absorb at once. The good news is, now you get to try it out!\n\n  1. Add a property called `mutableSupply` - a `Fixed<8>` with the value of `0`.\n  2. Add a `@constant` getter method called `totalSupply` which just returns the value of `mutableSupply`.\n\n## Test\n\nOnce you're done and there are no reported problems, go ahead and click `Build` and `Run Tests`. While they're running, take a look at `Token.test.ts` and you'll notice that we added another call to our `token` smart contract - `token.totalSupply()` - corresponding to the new `totalSupply` getter that was added.\n\n## Wrap Up\n\nIn this chapter we learned about the `Fixed` type, how to declare storage properties, and constant methods. Quite a lot, if you've made it this far you should be proud. Click `Next` and we'll see you on the other side!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n}\n",solution:"import { constant, Fixed, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private mutableSupply: Fixed<8> = 0;\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has name, symbol, decimals and totalSupply properties', async () => {\n    await withContracts(async ({ token }) => {\n      expect(token).toBeDefined();\n\n      const [name, symbol, decimals, totalSupply] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Structured Storage",documentation:"# Chapter 4: Structured Storage\n\nPrimitive storage properties are useful, but most contracts will want some kind of structured storage. In this chapter we'll learn about `MapStorage`, a structured storage class that enables storing a mapping from keys to values.\n\n## Learn\n\n`MapStorage` works almost identically to a JavaScript `Map`, the only difference is it doesn't have a `size` property. Let's take a look at an example:\n\n```typescript\nimport { Address, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  private readonly myMapStorage = MapStorage.for<Address, Fixed<8>>();\n\n  public myMethod(addr: Address): Fixed<8> {\n    this.myMapStorage.set(addr, 10);\n    const value = this.myMapStorage.get(addr)\n\n    return value === undefined ? 0 : value;\n  }\n}\n```\n\nWe create `MapStorage` using the [static](https://www.typescriptlang.org/docs/handbook/classes.html#static-properties) `for` property, which makes it read as \"`MapStorage` `for` `Address` to `Fixed<8>`\". (Note: we're using generic types here, take a look at the TypeScript [documentation](https://www.typescriptlang.org/docs/handbook/generics.html) for more info.) We're also introducing the `Address` [interface](https://www.typescriptlang.org/docs/handbook/interfaces.html) which is a special kind of `Buffer` that represents a NEO address. You'll see a few types like this in NEO•ONE smart contracts, they're defined in a way that makes them difficult to use incorrectly. As a concrete example, you can't pass an arbitrary `Buffer` where an `Address` is expected which helps eliminate bugs.\n\nNotice also that this method is not marked with `@constant` because it modifies the `MapStorage` by calling `set` on it. We won't create a non-constant method in this chapter though, it's only used for illustration.\n\n## Instructions\n\nThe token smart contract needs to store the balances of holders of Eon:\n\n  1. Add a `readonly` property `balances` - a `MapStorage` `for` `Address` (the holder) to `Fixed<8>` (the holder's balance).\n  2. Add a `@constant` method `balanceOf` that takes a single argument `Address` and returns a `Fixed<8>` from the `balances` property.\n\n## Test\n\nIf you run into issues, make sure there are no reported problems. The NEO•ONE compiler will report problems inline and in the problems panel, similar to TypeScript typechecker errors. Check out the tests to see the new `balanceOf` method in action. Then build and run the tests!\n\n## Wrap Up\n\nEasier than last chapter right? Still, we learned about the powerful concept of structured storage which nearly every contract will rely on. We also saw our first specialized `Buffer` type, the `Address`. Once you're done exploring, click `Next` to proceed.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { constant, Fixed, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private mutableSupply: Fixed<8> = 0;\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n}\n",solution:"import { Address, constant, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Constructors",documentation:"# Chapter 5: Constructors\n\nIn this chapter we'll learn about NEO•ONE smart contract constructors which enable contract initialization. We'll also talk about verifying the calling `Address`, i.e. who invoked the smart contract.\n\n## Learn\n\nSo far we've been using an implicit constructor by defining class properties with values. We can also declare a constructor to run arbitrary logic when the smart contract is deployed. Recall that the constructor is called exactly once when the smart contract is deployed.\n\nLet's take a look at an example:\n\n```typescript\nimport { Address, Deploy, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  private readonly myStringProperty: string;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress, stringValue: string = 'foo') {\n    super();\n    this.myStringProperty = `${stringValue}bar`;\n    if (!Address.isCaller(owner)) {\n      throw new Error('Expected caller to be the owner');\n    }\n  }\n}\n```\n\nHere we've defined a constructor that takes two arguments, an `Address` [parameter property](https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties) that will be the `owner` of the contract and a `stringValue` which we manipulate and set the `myStringProperty` to. The first thing you might notice is that we provide [default](https://www.typescriptlang.org/docs/handbook/functions.html#optional-and-default-parameters) values for every constructor argument. This is mandatory in NEO•ONE smart contracts because we use these default values when we automatically deploy your smart contract for automated and local manual testing. Since we also use a generated address to deploy the contract, referred to as the `masterAccountID` in tests and elsewhere, NEO•ONE provides a special value `Deploy.senderAddress` that sets the default value to whichever address deployed the contract.\n\n`Address.isCaller` allows you to determine if the provided `Address` invoked this contract. In this example, we do a sanity check that the `owner` is the one who deployed the smart contract, which eliminates the possibility of accidentally setting the `owner` to an address that the publisher of the smart contract doesn't own.\n\n## Instructions\n\nIn future chapters we'll want to verify that the smart contract caller is the owner of the contract:\n\n  1. Add a constructor with a single parameter property, `owner`, just like in the example above.\n  2. Add the `Address.isCaller` sanity check.\n\n## Test\n\nBy now you should know the drill - build and run the tests! If all goes well, go ahead and click the `Next` button. This chapter's tests are identical to the previous chapter because `withContracts` automatically deploys the contract to a local private network using the default arguments before passing the contract (as `token`) to our test method.\n\n## Wrap Up\n\nIn this chapter we covered constructors, which allow arbitrary initialization logic, as well as how to verify the invoker of the smart contract. As usual, don't forget to check the tests to see the new check for the `owner` property. Notice the usage of `masterAccountID`. This is the account that automatically publishes and deploys the smart contract behind the scenes.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { Address, constant, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n}\n",solution:"import { Address, constant, Deploy, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance, owner] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n        token.owner(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n      // `masterAccountID` is the main/first account on the network and contains just under 100 million NEO and 58 million GAS.\n      // It also is the account that automatically deploys the contracts.\n      expect(owner).toEqual(masterAccountID.address);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Methods",documentation:"# Chapter 6: Methods\n\nCongratulations on making it this far! Now that we've set the stage, it's time to get to the meat of a smart contract - methods that modify internal state. To start, we'll add a method for issuing tokens, read on to learn how!\n\n## Learn\n\nWe saw how to make constant methods using the `@constant` decorator, but now let's look at what happens when we have a non-constant method.\n\n```typescript\nimport { Address, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  private readonly myMapStorage = MapStorage.for<Address, Fixed<8>>();\n\n  public myMethod(addr: Address): Fixed<8> {\n    this.myMapStorage.set(addr, 10);\n    const value = this.myMapStorage.get(addr);\n\n    return value === undefined ? 0 : value;\n  }\n}\n```\n\nLook familiar? This is the same example from Chapter 3: Structured Storage. In terms of the smart contract, there's not much to add, a method that does not have the `@constant` decorator can mutate primitive and structured storage properties. Otherwise, they're free to contain any valid TypeScript just like `@constant` methods.\n\nThe main difference for the NEO•ONE client APIs is that non-constant methods require relaying a transaction to the blockchain. This makes sense because a non-constant method by definiton mutates storage, and we need to persist those changes to the blockchain.\n\n## Instructions\n\n1. Add a simple method `issue` which takes two parameters, the `Address` to issue tokens to and a `Fixed<8>` for the amount of tokens to issue. This method should do two things:\n   1. Increase the balance of the `Address` by the `Fixed<8>` amount.\n   2. Increase the `mutableSupply` by the `Fixed<8>` amount.\n2. Add a check for `Address.isCaller(owner)` and throw an `Error` if it does not return true.\n\n## Test\n\nTake a look at the tests for this chapter in `Token.test.ts`. Notice how unlike the `@constant` methods and `readonly` properties, we check that the invocation succeeded. We also have a test that makes sure the invocation failed when the `from` address is not the `owner`.\n\nHover over the return values and you'll see that they return a `InvokeReceipt<void, TokenEvent>`, which is the \"receipt\" for the confirmed transaction on the blockchain. When a transaction, like a smart contract invocation, is relayed to the blockchain, we wait for it to be confirmed in a block. Once it has been confirmed, we receive a “receipt” of that confirmation which lets us know whether the transaction succeeded and gives us access to any return values. Since the `issue` method doesn't return anything, we receive a `void` value in the receipt. We'll talk more about `TokenEvent` in the next chapter, so for now you can ignore that.\n\nIn our test, we use the shortcut method `confirmed` to do both steps in one call, but you can also make two invocations - in later lessons we'll cover both in more detail. Another thing you might notice is that the NEO•ONE client APIs generate methods that are nearly identical to the methods you've defined in your smart contract, making it feel like you're just calling the same methods you defined.\n\n## Wrap Up\n\nNow that we know how to make methods, we'll really start picking up the pace in future chapters and get into the meat of the `Token` functionality. Click `Next` to proceed!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { Address, constant, Deploy, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n}\n",solution:"import { Address, constant, Deploy, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance, owner] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n        token.owner(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n      expect(owner).toEqual(masterAccountID.address);\n\n      // Check that we can issue new tokens to the given address.\n      const amount = new BigNumber(10);\n      // Note that as long as there exists a user account configured in the `Client`, there will always be a default `from` user account that is used\n      // for creating and signing transactions. The `Client` from `withContracts` is configured to use the `masterAccountID` as the default\n      // `from` user account, hence we don't need to specify it explicitly here.\n      const issueReceipt = await token.issue.confirmed(toAccountID.address, amount);\n      if (issueReceipt.result.state === 'FAULT') {\n        throw new Error(issueReceipt.result.message);\n      }\n\n      // Verify the balances and total supply have been updated to reflect the issuance of tokens.\n      const [ownerBalance, issueBalance, issueTotalSupply] = await Promise.all([\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n        token.totalSupply(),\n      ]);\n      expect(ownerBalance.toNumber()).toEqual(0);\n      expect(issueBalance.toNumber()).toEqual(amount.toNumber());\n      expect(issueTotalSupply.toNumber()).toEqual(amount.toNumber());\n\n      // We explicitly specify which account to use to sign the transaction to verify that it's not possible to `issue` tokens by an\n      // arbitrary user account.\n      const failedIssueReceipt = await token.issue.confirmed(toAccountID.address, amount, {\n        from: toAccountID,\n      });\n      expect(failedIssueReceipt.result.state).toEqual('FAULT');\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Events",documentation:"# Chapter 7: Events\n\nIn this chapter we'll learn about how NEO•ONE smart contracts can emit events. We'll also talk about why and when you would want to emit events from your smart contract.\n\n## Learn\n\nLet's jump right into an example of how to emit an event from a NEO•ONE smart contract.\n\n```typescript\nimport { Address, createEventNotifier, SmartContract } from '@neo-one/smart-contract';\n\nconst notifyAddress = createEventNotifier<Address>('emit', 'address');\n\nexport class Example extends SmartContract {\n  public emitEvent(addr: Address): void {\n    notifyAddress(addr);\n  }\n}\n```\n\nIn this very simple example, every time the `emitEvent` method is invoked, the `Example` smart contract emits an event with the name `'emit'` and a parameter `'address'` that is an `Address`. Simple right? The general syntax for `createEventNotifier` is `createEventNotifier<Param0Type, Param1Type, Param2Type, ...>('<event name>', '<param0 name>', '<param1 name>', '<param2 name>', ...)`. Then you just call the returned function whenever you want to emit that event.\n\nNow, what does that actually do? Well, events (also called notifications) are a way for your contract to communicate that something happened on the blockchain to your app front-end (or back-end), which can be 'listening' for certain events and take action when they happen. You might use this to update an external database, do analytics, or update a UI.\n\n## Instructions\n\n  1. Use `createEventNotifier` to create a notifier for an event called `transfer` with a `from` `Address | undefined` parameter, `to` `Address | undefined` parameter, and an `amount` `Fixed<8>` parameter.\n  2. Call the event notifier in the `issue` method with the `from` parameter set to `undefined` to indicate that we're minting new tokens.\n\n## Test\n\nRecall last chapter we glossed over the `TokenEvent` type in the receipt. Now that we have an event, `transfer`, we can access the events from our issue receipt. Notice in `Token.test.ts` that we added lines 41-49 which verify that the event was emitted as expected.\n\n## Wrap Up\n\nAt this point, we have learned pretty much all of the basics of creating a smart contract. In the next chapter we'll put it all together by implementing the `transfer` method.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import { Address, constant, Deploy, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance, owner] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n        token.owner(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n      expect(owner).toEqual(masterAccountID.address);\n\n      // Check that we can issue new tokens to the given address.\n      const amount = new BigNumber(10);\n      // Note that as long as there exists a user account configured in the `Client`, there will always be a default `from` user account that is used\n      // for creating and signing transactions. The `Client` from `withContracts` is configured to use the `masterAccountID` as the default\n      // `from` user account, hence we don't need to specify it explicitly here.\n      const issueReceipt = await token.issue.confirmed(toAccountID.address, amount);\n      if (issueReceipt.result.state === 'FAULT') {\n        throw new Error(issueReceipt.result.message);\n      }\n\n      // Verify the expected transfer event was emitted.\n      expect(issueReceipt.events).toHaveLength(1);\n      const event = issueReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(amount.toNumber());\n\n      // Verify the balances and total supply have been updated to reflect the issuance of tokens.\n      const [ownerBalance, issueBalance, issueTotalSupply] = await Promise.all([\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n        token.totalSupply(),\n      ]);\n      expect(ownerBalance.toNumber()).toEqual(0);\n      expect(issueBalance.toNumber()).toEqual(amount.toNumber());\n      expect(issueTotalSupply.toNumber()).toEqual(amount.toNumber());\n\n      // We explicitly specify which account to use to sign the transaction to verify that it's not possible to `issue` tokens by an\n      // arbitrary user account.\n      const failedIssueReceipt = await token.issue.confirmed(toAccountID.address, amount, {\n        from: toAccountID,\n      });\n      expect(failedIssueReceipt.result.state).toEqual('FAULT');\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Transfer",documentation:"# Chapter 8: Transfer\n\nIn this chapter we'll use everything we've learned to complete the initial implementation of the Eon token by adding a `transfer` method.\n\n## Learn\n\nBefore we jump into implementing the `transfer` method, let's take a moment to discuss when it's appropriate to throw `Error`s vs. return `false` in a smart contract method. For those of you that have experience with other NEO Smart Contract languages, you may notice that rather than returning `false` we always throw an `Error`. Not only is this more idiomatic TypeScript, but throwing an `Error` also has the side effect of reverting all storage changes. This ensures that when an assertion in an operation fails, there are no erroneous storage changes. Note that when your contract is called from another contract, we will always return `false` to that contract so that it has a chance to react to the failure. We do this because there is not (currently) a way for the calling contract to catch errors. Concretely, imagine the `transfer` method is declared to return a `string`. Because every method can throw, the interface when interacting with the contract from another contract will be `string | false`, meaning the method will return `false` if an `Error` occurred. Let's take a look at an example:\n\n```typescript\nimport { Address, Fixed, SmartContract } from '@neo-one/smart-contract';\n\ninterface Token {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => string | false;\n}\n\nconst tokenAddress = Address.from('APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR');\n\nexport class Example extends SmartContract {\n  public attemptTransfer(from: Address, to: Address, amount: Fixed<8>): void {\n    // Reference a smart contract with an interface that matches Token at tokenAddress.\n    const smartContract = SmartContract.for<Token>(tokenAddress);\n    if (smartContract.transfer(from, to, amount) === false) {\n      // do something on failure\n    } else {\n      // do something else on success\n    }\n  }\n}\n```\n\nIn this example, first we attempt a transfer. If it succeeds and returns a string, we run one set of logic. If it fails and returns false, we run a different set of logic. Normally we might use a `try`/`catch` here, but errors don't propagate across smart contract boundaries. If an error is thrown, the entire transaction immediately fails. Instead we expect that the `transfer` method on the `Token` contract we're calling will return `false`.\n\n## Instructions\n\nAlrighty, let's finish up the `Token` contract! Implement a `transfer` method that:\n\n 1. Takes a `from` `Address`, `to` `Address` and `amount` `Fixed<8>` to transfer.\n 2. Throws an `Error` when `amount < 0`.\n 3. Throws an `Error` when the `from` address is not the caller (using `Address.isCaller`).\n 4. Throws an `Error` when `amount` is greater than the `from` `Address`es current balance.\n 5. Otherwise, reduces the `from` `Address` balance by `amount` and increases the `to` `Address` balance by `amount`.\n 6. Emits a `transfer` event.\n 7. And finally, returns `true`. Note that we return `true` on success for compatibility with the NEP-5 standard.\n\n## Test\n\nIf you get stuck, don't forget you can always reference the solution by clicking `Show Solution`. The tests for this chapter check a few things:\n\n 1. A valid `transfer` reduces the `from` balance and increases the `to` balance by `amount`, returning `true` and emitting a `transfer` event.\n 2. An error is thrown on `amount`s less than 0 or when the `transfer` cannot proceed due to insufficient funds.\n\n## Wrap Up\n\nCongratulations, you've written your first [NEP-5](https://github.com/neo-project/proposals/blob/master/nep-5.mediawiki) token! In the next lesson we'll extend our contract to launch an ICO as well as write a simple front-end to participate in the ICO. When you're ready, click `Next Lesson`. See you on the other side!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): true {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      throw new Error('The from Address did not approve the operation.');\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      throw new Error('The from balance is insufficient.');\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance, owner] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n        token.owner(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n      expect(owner).toEqual(masterAccountID.address);\n\n      // Check that we can issue new tokens to the given address.\n      const amount = new BigNumber(10);\n      // Note that as long as there exists a user account configured in the `Client`, there will always be a default `from` user account that is used\n      // for creating and signing transactions. The `Client` from `withContracts` is configured to use the `masterAccountID` as the default\n      // `from` user account, hence we don't need to specify it explicitly here.\n      const issueReceipt = await token.issue.confirmed(toAccountID.address, amount);\n      if (issueReceipt.result.state === 'FAULT') {\n        throw new Error(issueReceipt.result.message);\n      }\n\n      // Verify the expected transfer event was emitted.\n      expect(issueReceipt.events).toHaveLength(1);\n      let event = issueReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(amount.toNumber());\n\n      // Verify the balances and total supply have been updated to reflect the issuance of tokens.\n      const [ownerBalance, issueBalance, issueTotalSupply] = await Promise.all([\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n        token.totalSupply(),\n      ]);\n      expect(ownerBalance.toNumber()).toEqual(0);\n      expect(issueBalance.toNumber()).toEqual(amount.toNumber());\n      expect(issueTotalSupply.toNumber()).toEqual(amount.toNumber());\n\n      // We explicitly specify which account to use to sign the transaction to verify that it's not possible to `issue` tokens by an\n      // arbitrary user account.\n      const failedIssueReceipt = await token.issue.confirmed(toAccountID.address, amount, {\n        from: toAccountID,\n      });\n      expect(failedIssueReceipt.result.state).toEqual('FAULT');\n\n      // Try various transfers\n      const transferAmount = new BigNumber(5);\n      const [successTransferReceipt, falseTransferReceipt0] = await Promise.all([\n        // Successful because there are sufficient funds and the from account is the toWallet\n        token.transfer.confirmed(toAccountID.address, masterAccountID.address, transferAmount, { from: toAccountID }),\n        // Returns false because the from account is the masterAccountID (the currently selected account)\n        token.transfer.confirmed(toAccountID.address, masterAccountID.address, transferAmount),\n      ]);\n\n      if (successTransferReceipt.result.state === 'FAULT') {\n        throw new Error(successTransferReceipt.result.message);\n      }\n      expect(successTransferReceipt.result.state).toEqual('HALT');\n      expect(successTransferReceipt.result.value).toEqual(true);\n\n      // Verify the transfer event\n      expect(successTransferReceipt.events).toHaveLength(1);\n      event = successTransferReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(toAccountID.address);\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(transferAmount.toNumber());\n\n      // // Verify the failed result (throws an error)\n      expect(falseTransferReceipt0.result.state).toEqual('FAULT');\n      expect(falseTransferReceipt0.events).toHaveLength(3);\n\n      // Validate that an error is thrown when the from account has insufficient funds\n      let falseTransferReceipt1: Error | undefined;\n      try {\n        await token.transfer.confirmed(toAccountID.address, masterAccountID.address, new BigNumber(20), {\n          from: toAccountID,\n        });\n      } catch (err) {\n        falseTransferReceipt1 = err;\n      }\n      expect(falseTransferReceipt1).toBeDefined();\n\n      // Validate that an error is thrown on the exceptional case of -1\n      let error: Error | undefined;\n      try {\n        // Note that this transfer doesn't even get relayed to the blockchain and instead immediately fails because\n        // the transaction would throw an error.\n        await token.transfer.confirmed(toAccountID.address, masterAccountID.address, new BigNumber(-1));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]}]},{title:"Add ICO Capability",documentation:"# Raising Funds\n\nNow that we have the Eon token, we'll want to distribute it to people so that they can use it. We also need funds for our operation, so we can kill two birds with one stone by holding an ICO.\n\nIn this lesson we'll add ICO functionality to the Eon token. We'll introduce a few new concepts as well as solidify some of the learnings from the previous lesson.\n\n__Let's get started!__\n",chapters:[{title:"Receiving NEO and GAS",documentation:"# Chapter 1: Receiving NEO and GAS\n\nIn Lesson 2, we're going to add ICO functionality to our token smart contract. The token will\n\n - Enable minting tokens using NEO.\n - Start and end at a particular block time.\n - Limit the number of tokens minted.\n - Enable withdrawing the contributed NEO.\n\nThere's quite a bit of ground to cover, so let's get started!\n\nAs a quick reminder, the same flow applies as in Lesson 1. Write the code -> `Build` -> `Run Tests` -> `Next` once the tests are passing. If you get stuck, you can also view the full solution by clicking `Show Solution`.\n\n## Learn\n\nThe NEO blockchain supports native assets, the two most important ones being NEO and GAS. Native assets are UTXO based and are understood natively by the blockchain. Contrast this with tokens like the one we've built so far which live entirely in custom smart contracts. As a result, they require special handling within smart contracts. Luckily, NEO•ONE smart contracts abstract most of this away and let you focus on the logic of your smart contract. Let's take a look at how we would enable a smart contract to receive native assets.\n\n```typescript\nimport { receive, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @receive\n  public receiveNativeAssets(): void {\n  }\n}\n```\n\nIn this very simple example, we've defined a method decorated with `@receive`. This enables the method to receive native assets of any kind, including NEO and GAS. Methods marked with `@receive` must throw an error to indicate if the contract does not want to receive the assets. Note, however, that there are cases where the contract may still receive assets, despite throwing an error, due to limitations in how NEO handles native UTXO assets. For these cases, we automatically generate a `refundAssets` method that clients of your smart contract may call to refund assets which were not processed by the smart contract (i.e. the smart contract threw an error or was not actually called). Note that this method cannot refund assets if the smart contract invocation succeeded.\n\n## Instructions\n\n  1. Add a method called `mintTokens` that's decorated with `@receive` and does not throw an error.\n\nIn the following chapters we'll start expanding the method with more logic like converting NEO to tokens, but for now, we'll just accept all assets.\n\n## Test\n\nThe tests for this chapter simply check that we can send both NEO and GAS to the smart contract using the master account which starts with 100 million NEO and 58 million GAS. Take a look at `Token.test.ts` to see how the NEO•ONE client APIs work for sending assets to a smart contract.\n\n## Wrap Up\n\nIn this chapter we learned about receiving native assets. On the other side of `Next`, we'll start to expand our method with additional verification checks.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @receive\n  public mintTokens(): void {}\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('allows minting tokens', async () => {\n    await withContracts(async ({ token }) => {\n      expect(token).toBeDefined();\n\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: new BigNumber(10),\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n    });\n  });\n\n  test.skip('has NEP-5 properties and methods', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      const [name, symbol, decimals, totalSupply, initialBalance, owner] = await Promise.all([\n        token.name(),\n        token.symbol(),\n        token.decimals(),\n        token.totalSupply(),\n        token.balanceOf(toAccountID.address),\n        token.owner(),\n      ]);\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(decimals.toNumber()).toEqual(8);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(initialBalance.toNumber()).toEqual(0);\n      expect(owner).toEqual(masterAccountID.address);\n\n      // Check that we can issue new tokens to the given address.\n      const amount = new BigNumber(10);\n      // Note that as long as there exists a user account configured in the `Client`, there will always be a default `from` user account that is used\n      // for creating and signing transactions. The `Client` from `withContracts` is configured to use the `masterAccountID` as the default\n      // `from` user account, hence we don't need to specify it explicitly here.\n      const issueReceipt = await token.issue.confirmed(toAccountID.address, amount);\n      if (issueReceipt.result.state === 'FAULT') {\n        throw new Error(issueReceipt.result.message);\n      }\n\n      // Verify the expected transfer event was emitted.\n      expect(issueReceipt.events).toHaveLength(1);\n      let event = issueReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(amount.toNumber());\n\n      // Verify the balances and total supply have been updated to reflect the issuance of tokens.\n      const [ownerBalance, issueBalance, issueTotalSupply] = await Promise.all([\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n        token.totalSupply(),\n      ]);\n      expect(ownerBalance.toNumber()).toEqual(0);\n      expect(issueBalance.toNumber()).toEqual(amount.toNumber());\n      expect(issueTotalSupply.toNumber()).toEqual(amount.toNumber());\n\n      // We explicitly specify which account to use to sign the transaction to verify that it's not possible to `issue` tokens by an\n      // arbitrary user account.\n      const failedIssueReceipt = await token.issue.confirmed(toAccountID.address, amount, {\n        from: toAccountID,\n      });\n      expect(failedIssueReceipt.result.state).toEqual('FAULT');\n\n      // Try various transfers\n      const transferAmount = new BigNumber(5);\n      const [successTransferReceipt, falseTransferReceipt0, falseTransferReceipt1] = await Promise.all([\n        // Successful because there are sufficient funds and the from account is the toWallet\n        token.transfer.confirmed(toAccountID.address, masterAccountID.address, transferAmount, {\n          from: toAccountID,\n        }),\n        // Returns false because the from account is the masterAccountID (the currently selected account)\n        token.transfer.confirmed(toAccountID.address, masterAccountID.address, transferAmount),\n        // Returns false because the from account has insufficient funds\n        token.transfer.confirmed(toAccountID.address, masterAccountID.address, new BigNumber(20), {\n          from: toAccountID,\n        }),\n      ]);\n      if (successTransferReceipt.result.state === 'FAULT') {\n        throw new Error(successTransferReceipt.result.message);\n      }\n      expect(successTransferReceipt.result.state).toEqual('HALT');\n      expect(successTransferReceipt.result.value).toEqual(true);\n\n      // Verify the transfer event\n      expect(successTransferReceipt.events).toHaveLength(1);\n      event = successTransferReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(toAccountID.address);\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(transferAmount.toNumber());\n\n      // Verify the failed result (returns false)\n      if (falseTransferReceipt0.result.state === 'FAULT') {\n        throw new Error(falseTransferReceipt0.result.message);\n      }\n      expect(falseTransferReceipt0.result.state).toEqual('HALT');\n      expect(falseTransferReceipt0.result.value).toEqual(false);\n      expect(falseTransferReceipt0.events).toHaveLength(0);\n\n      // Verify the failed result (returns false)\n      if (falseTransferReceipt1.result.state === 'FAULT') {\n        throw new Error(falseTransferReceipt1.result.message);\n      }\n      expect(falseTransferReceipt1.result.state).toEqual('HALT');\n      expect(falseTransferReceipt1.result.value).toEqual(false);\n      expect(falseTransferReceipt1.events).toHaveLength(0);\n\n      // Validate that an error is thrown on the exceptional case of -1\n      let error: Error | undefined;\n      try {\n        // Note that this transfer doesn't even get relayed to the blockchain and instead immediately fails because\n        // the transaction would throw an error.\n        await token.transfer.confirmed(toAccountID.address, masterAccountID.address, new BigNumber(-1));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Processing Native Assets",documentation:"# Chapter 2: Processing Native Assets\n\nIn this chapter we'll start processing the native UTXO assets in the transaction that invokes our `mintTokens` function.\n\n## Learn\n\nThe current transaction in NEO•ONE smart contracts can be accessed using `Blockchain.currentTransaction`. The transaction itself has many useful properties, but for now we are only interested in a few of them. Let's look at an example.\n\n```typescript\nimport { Blockchain, Hash256, receive, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @receive\n  public receiveNativeAssets(): void {\n    const { references, outputs } = Blockchain.currentTransaction;\n\n    if (references.length !== 1) {\n      throw new Error('Invalid receiveNativeAssets');\n    }\n\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.GAS)) {\n          throw new Error('Invalid receiveNativeAssets');\n        }\n      }\n    }\n  }\n}\n```\n\nIn this example, we're verifying that every output that is sent to the contract address (`this.address`) is GAS. We're also checking that there's exactly one reference. A reference is the corresponding `output` for the `input`s of the transaction. Learn more about `input`s and `output`s in the [Blockchain Basics](/docs/blockchain-basics) chapter of the main guide.\n\n## Instructions\n\n  1. Add a check that throws an error if `references.length === 0` to the `mintTokens` method. We always want a sender for minting tokens, so we expect at least one input.\n  2. Add a similar check as the example for verifying that the assets sent to the contract are always `Hash256.NEO`.\n\n## Test\n\nIn this chapter the tests verify that we can only send NEO to the contract. If you get stuck, feel free to check out the solution, dealing with UTXO assets can be rather complex, particularly when learning them for the first time.\n\n## Wrap Up\n\nIn this chapter we started to learn about processing native UTXO assets received in a transaction. We saw how to access the current transaction, how to fetch the corresponding `output`s for the transaction's `input`s and how to check for outputs that were sent to the contract.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @receive\n  public mintTokens(): void {}\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @receive\n  public mintTokens(): void {\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n      }\n    }\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('allows minting tokens', async () => {\n    await withContracts(async ({ token }) => {\n      expect(token).toBeDefined();\n\n      // Verify a valid mint transaction\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: new BigNumber(10),\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving the assets.\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.GAS,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Minting Tokens",documentation:"# Chapter 3: Minting Tokens\n\nNow we can get to the meat of minting tokens. By the end of this chapter we'll have a fully functioning ICO.\n\n## Learn\n\nThis chapter primarily makes use of skills we've already learned, there's just one more thing to know - we can access the value of an output via the `output.value` property. Let's look at an example:\n\n```typescript\nimport { Blockchain, Hash256, receive, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @receive\n  public receiveNativeAssets(): void {\n    const { outputs } = Blockchain.currentTransaction;\n\n    for (const output of outputs) {\n      if (output.address.equals(this.address) && output.value > 10_00000000) {\n        throw new Error('Invalid receiveNativeAssets');\n      }\n    }\n  }\n}\n```\n\nIn this somewhat contrived example, we're checking that if any of the outputs have a value greater than 10, then we refuse the transaction.\n\n## Instructions\n\nThere's quite a bit that needs to be done this chapter, so don't hesitate to take a peek at the solution if you get stuck.\n\n  1. Add a `public` `readonly` property for the `amountPerNEO` that we'll be minting. Give it a value of `100_000`, i.e. for each NEO contributed, we'll mint 100k of the token.\n  2. Add a `private` `Fixed<8>` property for the `mutableRemaining` and give it an initial value of `10_000_000_000_00000000`, i.e. at the start of the ICO there are 10 billion tokens available.\n  3. Add a `public` `@constant` getter called `remaining` that returns `mutableRemaining` so that clients can easily check how much is remaining in the ICO.\n  4. In the `for` loop that checks for only `NEO` assets, sum the `amount` to issue by multiplying `output.value` by `this.amountPerNEO`.\n  5. Add a check that if `amount` is greater than `this.remaining` throws an error so that we don't issue more than the expected number of tokens.\n  6. Subtract `amount` from `this.mutableRemaining`.\n  7. Call `this.issue` with the first reference's address as the address to issue tokens to.\n  8. Change `issue` to a `private` method and remove the `Address.isCaller` check.\n\n## Test\n\nTake a look at the `Token.test.ts` file and you'll see that we're now fully testing the functionality of `mintTokens` - verifying everything from the emission of transfer events to the remaining amount being decremented.\n\n## Wrap Up\n\nIn this chapter we buttoned up the implementation for `mintTokens` - in the following chapter we'll add a start and end time to our ICO.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @receive\n  public mintTokens(): void {\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n      }\n    }\n  }\n\n  public issue(addr: Address, amount: Fixed<8>): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Only the owner can issue tokens.');\n    }\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('allows minting tokens', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Verify a valid mint transaction\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: new BigNumber(10),\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving the assets.\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.GAS,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify various properties have been updated to reflect the mint\n      const [totalSupply, remaining, balance, toBalance] = await Promise.all([\n        token.totalSupply(),\n        token.remaining(),\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n      ]);\n      expect(totalSupply.toNumber()).toEqual(1_000_000);\n      expect(remaining.toNumber()).toEqual(9_999_000_000);\n      expect(balance.toNumber()).toEqual(1_000_000);\n      expect(toBalance.toNumber()).toEqual(0);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"ICO Start Time & Duration",documentation:"# Chapter 4: ICO Start Time & Duration\n\nNow that we can mint tokens, let's limit the duration of the ICO. We'll add a start time and duration in this chapter.\n\n## Learn\n\nLast chapter we saw that we can access the current transaction with `Blockchain.currentTransaction` - there are two other properties to be aware of on `Blockchain` that are useful for smart contract development:\n\n - `Blockchain.currentBlockTime` - the unix timestamp (in seconds) of the current block.\n - `Blockchain.currentHeight` - the current block index.\n\n## Instructions\n\n  1. Add a `public` `readonly` constructor parameter property called `icoStartTimeSeconds` whose default value is equal to `Blockchain.currentBlockTime + 60 * 60`.\n  2. Add a `public` `readonly` constructor parameter property called `icoDurationSeconds` whose default value is equal to `24 * 60 * 60`.\n  3. If the `Blockchain.currentBlockTime` is not within `this.icoStartTimeSeconds` and `this.icoStartTimeSeconds + this.icoDurationSeconds`, return `false` from `mintTokens`.\n\n  Recall that all constructor parameters must have a default value for local and automated testing. Here we're setting the start time to 1 hour from the current time and the duration to 24 hours.\n\n## Test\n\n`Token.test.ts` has been updated to do a few things:\n\n  1. Check that `mintTokens` fails before the ICO start time.\n  2. Fast forward the local blockchain 1 hour ahead using `developerClient.fastForwardOffset(60 * 60)`.\n  3. Check that `mintTokens` succeeds just like last chapter.\n  4. Fast forward the local blockchain 24 hours ahead using `developerClient.fastForwardOffset(24 * 60 * 60)`.\n  5. Check that `mintTokens` fails because we're past the ICO time.\n  6. Check that the properties `icoStartTimeSeconds` and `icoDurationSeconds` are accessible.\n\n## Wrap Up\n\nIn this chapter we learned about the remaining `Blockchain` properties and used `Blockchain.currentBlockTime` to enforce that minting tokens in our ICO only happens during a set period of time. Now that we have a fully functioning NEP-5 Token with ICO capabilities, let's see how we can interact with it in a front-end app for the ICO in the next chapter.\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('allows minting tokens', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID, developerClient }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.NEO,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      // Verify a valid mint transaction\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: new BigNumber(10),\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      error = undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving the assets.\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.GAS,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.NEO,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify various properties have been updated to reflect the mint\n      const [totalSupply, remaining, balance, toBalance] = await Promise.all([\n        token.totalSupply(),\n        token.remaining(),\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n      ]);\n      expect(totalSupply.toNumber()).toEqual(1_000_000);\n      expect(remaining.toNumber()).toEqual(9_999_000_000);\n      expect(balance.toNumber()).toEqual(1_000_000);\n      expect(toBalance.toNumber()).toEqual(0);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Withdraw Contributions",documentation:"# Chapter 5: Withdraw Contributions\n\nWe almost have a fully functioning ICO smart contract, though it's missing one piece of functionality that's critical to our fundraising efforts: a way to withdraw the contributed NEO. In this chapter we'll learn about the `@sendUnsafe` decorator, which will allows us to withdraw NEO from the smart contract.\n\n## Learn\n\nSimilar to `@receive`, we can decorate a method with `@sendUnsafe` to allow native assets to be sent from the smart contract to the desired address when invoking a smart contract method. Again, like `@receive`, it must throw an error if the transfer should not proceed.\n\nThe decorator is \"unsafe\" because it should only be used in cases where it's not possible for a malicious actor to invoke the method - if they can, it's possible for them to construct a parallel set of calls that result in the method returning successfully when in fact only one of the calls should have been allowed. Read more about this limitation in the [documentation](/docs/native-assets).\n\nIn short, you only want to decorate a method with `@sendUnsafe` when the method checks that the caller is a \"superuser\", i.e. someone who is not going to attempt to cheat the contract. The most common case is to simply call `Address.isCaller(this.owner)` which checks that the method was only invoked by the owner of the smart contract. Let's take a look at an example.\n\n```typescript\nimport { Address, Deploy, sendUnsafe, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  public constructor(public readonly owner = Deploy.senderAddress) {}\n\n  @sendUnsafe\n  public sendNativeAssetsUnsafe(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid transfer');\n    }\n  }\n}\n```\n\nIn this example, we simply check that the caller of the method is the owner of the smart contract - if that's the case, then the native asset transfer is allowed to proceed. We could do additional verification on the inputs and outputs of the transaction, similar to what we did with `@receive`, however in this example, we're trusting that the owner is not acting maliciously.\n\nWhat if we want to safely send assets? NEO•ONE supports that too, we'll talk about the safe counterpart to the `@sendUnsafe` decorator, `@send`, in a later lesson.\n\nNote that any transaction which attempts to send native assets from the smart contract without invoking a method marked with `@sendUnsafe` or `@send` will be automatically denied.\n\n## Instructions\n\n  1. Add a method called `withdraw` that's decorated with `@sendUnsafe` and throws an error when `!Address.isCaller(this.owner)`.\n\n## Test\n\nWe've updated `Token.test.ts` to verify that we can invoke the `withdraw` method to withdraw assets from the smart contract and that non-owners cannot invoke the method. Take a look at `Token.test.ts` to see how the NEO•ONE client APIs work for sending assets from a smart contract using the `@sendUnsafe` decorator.\n\n## Wrap Up\n\nCongratulations, you've built a fully functioning ICO smart contract! Now we just need a way for people to participate in the ICO through a UI, otherwise we'll likely not see many participants since not everyone is technical enough to construct the smart contract invocations themselves. We'll do that and more in the next lesson, see you on the other side!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('allows minting tokens', async () => {\n    await withContracts(async ({ token, accountIDs, masterAccountID, developerClient, client, networkName }) => {\n      expect(token).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.NEO,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      // Verify a valid mint transaction\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      error = undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving the assets.\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.GAS,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await token.mintTokens.confirmed({\n          sendTo: [\n            {\n              amount: new BigNumber(10),\n              asset: Hash256.NEO,\n            },\n          ],\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify various properties have been updated to reflect the mint\n      const [totalSupply, remaining, balance, toBalance] = await Promise.all([\n        token.totalSupply(),\n        token.remaining(),\n        token.balanceOf(masterAccountID.address),\n        token.balanceOf(toAccountID.address),\n      ]);\n      expect(totalSupply.toNumber()).toEqual(1_000_000);\n      expect(remaining.toNumber()).toEqual(9_999_000_000);\n      expect(balance.toNumber()).toEqual(1_000_000);\n      expect(toBalance.toNumber()).toEqual(0);\n\n      // Test that we can withdraw to an arbitrary address as long as the from account is the owner\n      // (which by default, it currently is since it's the selected account)\n      const withdrawReceipt = await token.withdraw.confirmed({\n        sendFrom: [\n          {\n            amount: new BigNumber(10),\n            asset: Hash256.NEO,\n            to: toAccountID.address,\n          },\n        ],\n      });\n      if (withdrawReceipt.result.state === 'FAULT') {\n        throw new Error(withdrawReceipt.result.message);\n      }\n      expect(withdrawReceipt.result.state).toEqual('HALT');\n      expect(withdrawReceipt.result.value).toBeUndefined();\n      const [toWalletAccount, contractAccount] = await Promise.all([\n        client.getAccount(toAccountID),\n        client.getAccount({\n          network: networkName,\n          address: token.definition.networks[networkName].address,\n        }),\n      ]);\n      expect(toWalletAccount.balances[Hash256.NEO]).toBeDefined();\n      expect(toWalletAccount.balances[Hash256.NEO].toNumber()).toEqual(mintNEOAmount.toNumber());\n      expect(contractAccount.balances[Hash256.NEO]).toBeUndefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]}]},{title:"Launch the ICO",documentation:"# Ready, Set, Launch!\n\nThe ICO contract is complete and ready to launch, but we need a way for people to participate. Of course, the technical contributors can invoke the smart contract methods directly, but we'll want more than just technical people to participate.\n\nIn this lesson we'll build an ICO participation UI for the Eon ICO using the NEO•ONE client APIs.\n\n__Let's get started!__\n",chapters:[{title:"Display ICO Info",documentation:"# Chapter 1: Display ICO Info\n\nIn this chapter we'll begin to learn how we can interact with the smart contract using the NEO•ONE client APIs. We'll start by building a front-end for our ICO using React, however the NEO•ONE client APIs are framework agnostic, so you may use them with any front-end framework.\n\nBefore we dive in though, let's quickly go over the new window you might have noticed in the editor. On the right hand side is a live preview of the React dapp we'll be building throughout this lesson. Right now it shows an error, because the method we're implementing in this chapter is currently empty, but once you've added the implementation the results will appear immediately. Every pane (including this one) is resizable, so if you're feeling a bit tight on space, be sure to resize as needed.\n\n## Learn\n\nRecall from previous chapters that NEO•ONE client APIs are automatically generated and correspond one-to-one with the properties and methods of your smart contract. For example, given the following contract:\n\n```typescript\nimport { SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  public readonly myProperty = 'foo';\n}\n```\n\nWe can fetch the `myProperty` value in a dapp with:\n\n```typescript\nconst myProperty = await example.myProperty();\nexpect(myProperty).toEqual('foo');\n```\n\nIn the coming chapters we'll explain where the `example` value which represents our smart contract comes from, but for now we'll just assume that it's available. Notice that even though it's defined as a property in the smart contract, we still call it like a function and that function returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) which we must [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function). This is what we mean when we say the generated smart contract client APIs \"correspond one-to-one\", while not identical, it functions very similarly to the smart contract. We return a `Promise` in particular because all communication with the blockchain is inherently asynchronous. For example, in this case we need to make a request to a node to fetch the current value.\n\n## Instructions\n\nImplement the `getTokenInfo` method, by returning the expected result type.\n\n  1. Fetch each property using `token.<property-name>()`.\n\nSince we'll be fetching multiple properties, you'll want to `await` a [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) to fetch them in parallel.\n\n## Test\n\nOnce you've correctly implemented `getTokenInfo`, you should see the properties displayed in a simple table. The tests for this chapter are located in `utils.test.ts`, once you're done implementing `getTokenInfo` go ahead and click `Run Tests` to check your answer. Once they pass, click `Next` to proceed to the next chapter! Remember, if you ever get stuck, click `Show Solution` to view the complete solution for this chapter.\n\n## Wrap Up\n\nIn this chapter we got our first taste of using the NEO•ONE client APIs to fetch properties from our token smart contract. Next we'll learn how to make use of the `balanceOf` constant method of our smart contract. Take a look at the `ICO.tsx` to see how the `getTokenInfo` function is used - if it doesn't make much sense, don't worry! We'll explain everything in that file in future chapters.\n\nBefore you go, try clicking the NEO•ONE icon in the lower left hand side of the preview pane. This reveals a developer toolbar with handy functionality for controlling the local node your smart contract is deployed to, as well as a full wallet implementation for testing. Play around with it and hover over the various buttons to familiarize yourself with what's possible. Head on over to the [documentation](/docs/dapps#developer-tools) for a full description of the functionality available with the developer tools as well as instructions on how to integrate them with your dapp for testing.\n",files:[{path:"src/utils.ts",initial:"import BigNumber from 'bignumber.js';\nimport { TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract): Promise<TokenInfoResult> => {\n  // Implement me\n};\n",solution:"import BigNumber from 'bignumber.js';\nimport { TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds };\n};\n"},{path:"src/__tests__/utils.test.ts",solution:"import { getTokenInfo } from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token }) => {\n      expect(token).toBeDefined();\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n      } = await getTokenInfo(token);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n    });\n  });\n});\n"},{path:"src/ICO.tsx",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport { FromStream } from '@neo-one/react';\nimport { Box } from '@neo-one/react-core';\nimport * as React from 'react';\nimport { defer } from 'rxjs';\nimport { prop } from 'styled-tools';\nimport { WithContracts } from '../one/generated';\nimport { getTokenInfo } from './utils';\n\nconst StyledGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\nexport const ICO = (props: {}) => (\n  <WithContracts>\n    {({ token }) => (\n      <FromStream props={[token]} createStream={() => defer(async () => getTokenInfo(token))}>\n        {(value) => (\n          <Wrapper>\n            <InnerWrapper>\n              <StyledGrid {...props}>\n                <Box>Name:</Box>\n                <Box>{value.name}</Box>\n                <Box>Symbol:</Box>\n                <Box>{value.symbol}</Box>\n                <Box>Total Supply:</Box>\n                <Box>{value.totalSupply.toFormat()}</Box>\n                <Box>Amount Per NEO:</Box>\n                <Box>{value.amountPerNEO.toFormat()}</Box>\n                <Box>NEO Contributed:</Box>\n                <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                <Box>Remaining:</Box>\n                <Box>{value.remaining.toFormat()}</Box>\n                <Box>Start Time:</Box>\n                <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                <Box>Duration:</Box>\n                <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n              </StyledGrid>\n            </InnerWrapper>\n          </Wrapper>\n        )}\n      </FromStream>\n    )}\n  </WithContracts>\n);\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app'));\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]},{title:"Fetch User Balance",documentation:"# Chapter 2: Fetch User Balance\n\nIn this chapter we'll take a quick look at how we can invoke constant methods using the NEO•ONE client APIs. This chapter will be rather short because, like properties, constant methods correspond one-to-one with methods on the generated client smart contract APIs.\n\n## Learn\n\nLet's jump right in with an example.\n\n```typescript\nimport { constant, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @constant\n  public myConstantMethod(myFirstArg: string): string {\n    return myFirstArg;\n  }\n}\n```\n\nWe can invoke `myConstantMethod` by simply calling it on the generated client APIs.\n\n```typescript\nconst myResult = await example.myConstantMethod('foo');\nexpect(myResult).toEqual('foo');\n```\n\nSimilar to the previous chapter, the only difference with the generated client APIs and what was defined in the smart contract is that they return a `Promise`, so we must `await` the result.\n\n## Instructions\n\n  1. Add a call to the `getTokenInfo` method which returns the balance of the argument address and add it to the result.\n\nNote that you'll have to deal with the case where `address` is undefined - just return `new BigNumber(0)` as the balance. Also note the new type `AddressString`. Recall that in our smart contract, we declared a single parameter of type `Address` for the `balanceOf` method. `AddressString` is the 1:1 mapping in the generated client APIs which let us pass the NEO address in string form which will then be automatically converted into the proper form for the smart contract. Read more about the 1:1 type mappings in the [documentation](/docs/smart-contract-apis#type-conversion-table).\n\n## Test\n\nNotice we added a row for the balance of the current user in the dapp preview. Right now it will always show 0 since the current user (nor any other user) has participated in the ICO. Similarly, the tests add a check that the returned balance for the passed address is 0. Run the tests to verify you've implemented `getTokenInfo` correctly and then proceed to the next chapter.\n\n## Wrap Up\n\nIn this chapter we saw that invoking constant methods is virtually identical to accessing properties. In the next chapter we'll look at invoking non-constant methods by implementing a text input for participating in the ICO.\n",files:[{path:"src/utils.ts",initial:"import { AddressString } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds };\n};\n",solution:"import { AddressString } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n"},{path:"src/__tests__/utils.test.ts",solution:"import { createPrivateKey } from '@neo-one/client';\nimport { getTokenInfo } from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token, networkName }) => {\n      expect(token).toBeDefined();\n\n      const toWallet = await token.client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n        balance,\n      } = await getTokenInfo(token, toWallet.userAccount.id.address);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n      expect(balance.toNumber()).toEqual(0);\n    });\n  });\n});\n"},{path:"src/ICO.tsx",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport { FromStream } from '@neo-one/react';\nimport { Box } from '@neo-one/react-core';\nimport * as React from 'react';\nimport { defer } from 'rxjs';\nimport { prop } from 'styled-tools';\nimport { WithContracts } from '../one/generated';\nimport { getTokenInfo } from './utils';\n\nconst StyledGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\nexport const ICO = (props: {}) => (\n  <WithContracts>\n    {({ token }) => (\n      <FromStream props={[token]} createStream={() => defer(async () => getTokenInfo(token))}>\n        {(value) => (\n          <Wrapper>\n            <InnerWrapper>\n              <StyledGrid {...props}>\n                <Box>Name:</Box>\n                <Box>{value.name}</Box>\n                <Box>Symbol:</Box>\n                <Box>{value.symbol}</Box>\n                <Box>Total Supply:</Box>\n                <Box>{value.totalSupply.toFormat()}</Box>\n                <Box>Amount Per NEO:</Box>\n                <Box>{value.amountPerNEO.toFormat()}</Box>\n                <Box>NEO Contributed:</Box>\n                <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                <Box>Remaining:</Box>\n                <Box>{value.remaining.toFormat()}</Box>\n                <Box>Start Time:</Box>\n                <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                <Box>Duration:</Box>\n                <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                <Box>Your Balance:</Box>\n                <Box>{value.balance.toFormat()}</Box>\n              </StyledGrid>\n            </InnerWrapper>\n          </Wrapper>\n        )}\n      </FromStream>\n    )}\n  </WithContracts>\n);\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app')); \n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]},{title:"Participate in the ICO",documentation:"# Chapter 3: Participate in the ICO\n\nNow we get to the fun part, invoking a non-constant method on our smart contract. We'll cover how to do that for normal methods and ones marked with `@receive` and then you'll put that knowledge to use implementing a callback handler that participates in the ICO. We'll also have an opportunity to play with the NEO•ONE developer tools.\n\n## Learn\n\nSmart contract methods that are not constant require relaying a transaction on the network. Typically you'll want to wait for the transaction to be confirmed in order to update the UI as well as to respond to any errors during the process. The generated NEO•ONE client APIs enable this through a two step process.\n\nFirst, invoke the smart contract method which will return a `Promise<TransactionResult>`. The `TransactionResult` object contains two properties, `transaction` which is the full transaction object that was relayed to the network, and `confirmed` which is a function we can call to wait for the transaction to be confirmed.\n\nThus, the second step of the process is to call `confirmed` which returns a `Promise<InvokeReceipt>`. This `InvokeReceipt` contains many useful properties, like the `event`s that were emitted during execution as well as the final `result` of the smart contract. To learn more, take a look at the detailed [documentation](/docs/smart-contract-apis#methods) on invoking smart contract methods.\n\nMethods marked with `@receive` also take an additional argument for the native assets to send with the invocation. Let's take a look at an example:\n\n```typescript\nimport { receive, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @receive\n  public myReceive(value: string): void {\n    // do something with value + received assets\n  }\n}\n```\n\n```typescript\nimport { Hash256 } from '@neo-one/client';\n\nconst result = await example.myReceive('foo', {\n  sendTo: [{\n    asset: Hash256.NEO,\n    amount: new BigNumber(10),\n  }]\n});\nconst receipt = await result.confirmed();\nif (receipt.result.state === 'FAULT') {\n  // do something when the transaction failed.\n} else {\n  // do something when the transaction succeeded.\n}\n```\n\nIn this example, we follow the two step process outlined above by first calling the `myReceive` method, followed by calling the `confirmed` method. We can check if the transaction was successful by checking the `receipt.result.state` property. Notice how we invoke the `myReceive` method with `'foo'` as the argument for the `value` parameter in the smart contract and additionally pass an object with a `sendTo` property. This `sendTo` property is only allowed for methods marked with `@receive` and it allows us to specify the native assets to send along with the transaction - in this case we've specified that we want to send `10` `NEO` to the contract along with the transaction.\n\n## Instructions\n\n  1. Implement the `handleMint` method by calling `token.mintTokens` with the given amount.\n  2. Return the result of calling `confirmed`.\n\n## Test\n\nThe tests for this chapter add a call to the `handleMint` method and verify that the mint failed or was successful similar to the tests for minting tokens in chapter 3 - that is, if it's before the ICO start time, it fails; during, succeeds; after, fails. In fact, the methods you implemented in the last few chapters are the exact same as the logic in testing our implementation of the smart contract in previous lessons.\n\nWe've also updated the UI to make use the `handleMint` method with a text input for the amount and a button to contribute. Try it out and you'll notice that contributing fails because the ICO hasn't started. Click the NEO•ONE icon in the lower left and then click on the \"Fast Forward\" button (the one with the counter of seconds since last block) to fast forward by 1 hour. Then try contributing again and it should succeed.\n\n## Wrap Up\n\nIn this chapter we learned how to invoke smart contract methods as well as how to send assets to methods marked with `@receive`. If you played around with the UI and the developer tools, you may have noticed that the UI did not update to reflect the contribution - we'll tackle improving that in the next chapter!\n",files:[{path:"src/utils.ts",initial:"import { AddressString, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  // Implement me\n};\n",solution:"import { AddressString, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n"},{path:"src/__tests__/utils.test.ts",solution:"import { createPrivateKey } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { getTokenInfo, handleMint } from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token, networkName }) => {\n      expect(token).toBeDefined();\n\n      const toWallet = await token.client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n        balance,\n      } = await getTokenInfo(token, toWallet.userAccount.id.address);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n      expect(balance.toNumber()).toEqual(0);\n    });\n  });\n\n  test('handleMint mints tokens', async () => {\n    await withContracts(async ({ developerClient, token, masterAccountID }) => {\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      const mintReceipt = await handleMint(token, new BigNumber(10));\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"src/ICO.tsx",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport { FromStream } from '@neo-one/react';\nimport { Box, Button, TextInput } from '@neo-one/react-core';\nimport BigNumber from 'bignumber.js';\nimport * as React from 'react';\nimport { defer } from 'rxjs';\nimport { prop } from 'styled-tools';\nimport { TokenSmartContract, WithContracts } from '../one/generated';\nimport { getTokenInfo, handleMint } from './utils';\n\nconst InfoGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst ContributeGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'input amount' auto\n    'empty send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst AmountInput = styled(TextInput)`\n  grid-area: input;\n`;\n\nconst AmountText = styled(Box)`\n  grid-area: amount;\n`;\n\nconst SendWrapper = styled(Box)`\n  display: grid;\n  grid-area: send;\n  grid-auto-flow: column;\n  justify-items: end;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\ninterface Props {}\ninterface State {\n  readonly text: string;\n  readonly amount?: BigNumber;\n  readonly loading: boolean;\n}\n\nexport class ICO extends React.Component<Props, State> {\n  public state: State = {\n    text: '',\n    loading: false,\n  };\n\n  public render() {\n    return (\n      <WithContracts>\n        {({ token, client }) => (\n          <FromStream\n            props={[client, token]}\n            createStream={() =>\n              defer(async () => {\n                const userAccount = client.getCurrentUserAccount();\n\n                return getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address);\n              })\n            }\n          >\n            {(value) => (\n              <Wrapper>\n                <InnerWrapper>\n                  <InfoGrid>\n                    <Box>Name:</Box>\n                    <Box>{value.name}</Box>\n                    <Box>Symbol:</Box>\n                    <Box>{value.symbol}</Box>\n                    <Box>Total Supply:</Box>\n                    <Box>{value.totalSupply.toFormat()}</Box>\n                    <Box>Amount Per NEO:</Box>\n                    <Box>{value.amountPerNEO.toFormat()}</Box>\n                    <Box>NEO Contributed:</Box>\n                    <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                    <Box>Remaining:</Box>\n                    <Box>{value.remaining.toFormat()}</Box>\n                    <Box>Start Time:</Box>\n                    <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                    <Box>Duration:</Box>\n                    <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                    <Box>Your Balance:</Box>\n                    <Box>{value.balance.toFormat()}</Box>\n                  </InfoGrid>\n                  <ContributeGrid>\n                    <AmountInput value={this.state.text} placeholder=\"Send NEO\" onChange={this.onChangeAmount} />\n                    <AmountText>\n                      {this.state.amount === undefined ? '0' : value.amountPerNEO.times(this.state.amount).toFormat()}\n                    </AmountText>\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.amount === undefined || this.state.loading}\n                        onClick={() => this.send(token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </ContributeGrid>\n                </InnerWrapper>\n              </Wrapper>\n            )}\n          </FromStream>\n        )}\n      </WithContracts>\n    );\n  }\n\n  private readonly onChangeAmount = (event: React.SyntheticEvent<any>) => {\n    const text = event.currentTarget.value;\n    let amount: BigNumber | undefined;\n    try {\n      amount = new BigNumber(text);\n      if (amount.toString() !== text) {\n        amount = undefined;\n      }\n    } catch {\n      // do nothing\n    }\n\n    this.setState({ text, amount });\n  };\n\n  private readonly send = (token: TokenSmartContract) => {\n    const amount = this.state.amount;\n    if (amount !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleMint(token, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            // We should show an error message, but for the course we'll just log the error to console.\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n}\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app'));\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]},{title:"Reactive Updates",documentation:"# Chapter 4: Reactive Updates\n\nThe NEO•ONE client APIs use `Observable`s to make your dapps reactive. For example, `Observable`s allow them to easily update whenever a new block is broadcast on the network. If you're not familiar with `Observable`s, take a look at the extensive documentation at [ReactiveX](http://reactivex.io/). NEO•ONE uses [RxJS](https://rxjs-dev.firebaseapp.com/), so keep the documentation for both handy while you work through this chapter. [Rx Visualizer](https://rxviz.com/) is also a helpful tool for visualizing `Observable`s. With that said, we will walk through the steps of using `Observable`s in detail in this chapter, so if you'e never used them before, don't worry.\n\nIn this chapter we'll learn how to make our dapp reactive by automatically updating the UI when a user has participated in the ICO.\n\n## Learn\n\nUp until this point we've mainly interacted with the automatically generated smart contract APIs that correspond to our smart contract. The NEO•ONE client APIs also include a class called `Client` for more generic interactions with the NEO blockchain.\n\nThe `Client` class abstracts interaction with the blockchain using `UserAccount`s which are uniquely identified by a `UserAccountID` - a network (e.g. main network, test network, local network) and a NEO address. During initialization of your dapp you'll configure a `Client` with various `UserAccountProvider`s that serve to provide `UserAccount`s to the `Client`. For example, you might configure a `LocalUserAccountProvider` if you've implemented a full wallet in your dapp, though more commonly you would configure a `UserAccountProvider` that works with an existing wallet like NEO Tracker, nOS or NEX. By using the `Client` abstraction (also used by the generated smart contract APIs) throughout your dapp you can easily switch between and use different providers without changing a single line of your business logic.\n\nOnce configured, the `Client` instance serves as the entrypoint for interacting with and reading from the NEO blockchain beyond interacting with your smart contract. In this chapter, we'll focus on reacting to changes in the blockchain, but you can take a look at the [reference](/reference/@neo-one/client) on the `Client` APIs for a full description of what's available.\n\nThe two most commonly used properties of the `Client` are the `block$` `Observable` and the `currentUserAccount$` `Observable`. By subscribing to the `block$` `Observable` we can easily update the UI in response to new blocks created on the blockchain. By subscribing to the `currentUserAccount$` `Observable` we have access to the currently selected account, regardless of which provider it's associated with.\n\nLet's take a look at an example.\n\n```typescript\nimport { Address, constant, Fixed, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @constant\n  public myConstantFunction(address: Address): Fixed<8> {\n    // do something with address and return a Fixed<8> value\n  }\n}\n```\n\n```typescript\nimport { combineLatest } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\nconst value$ = combineLatest([client.currentUserAccount$, client.block$]).pipe(\n  switchMap(async ([userAccount]) => {\n    const value = await example.myConstantFunction(userAccount.id.address);\n\n    return value;\n  }),\n);\n```\n\nHere we have a simple smart contract that returns a `Fixed<8>` value for a given `Address`, similar to the `balanceOf` function of the Eon smart contract. We combine the latest values of the `currentUserAccount$` and `block$` `Observable`s which results in another `Observable` that contains a pair of the latest `UserAccount` and `Block`. We then `pipe` that stream of values into the [`switchMap`](https://rxjs-dev.firebaseapp.com/api/operators/switchMap) operator which transforms the stream of values with an async function, returning the latest value from the `myConstantFunction` of the smart contract. Finally, we would subscribe to the stream of values in order to do something with each one, for example update a UI. Abstractly, this allows us to automatically call `myConstantFunction` with the current `UserAccount`'s address every time the current `UserAccount` changes or a new `Block` is added.\n\nBecause using `Observable`s to reactively update a UI is a very common pattern in developing dapps, NEO•ONE offers a React component, `FromStream`, which helps simplify integrating with React. Using the above stream for example, we could reactively update a UI with the following:\n\n```tsx\n<FromStream createStream={() => value$}>{(value) => <div>{value}</div>}</FromStream>\n```\n\nNow whenever the `value$` `Observable` from the above example emits a new `value`, the UI will automatically update with that value.\n\n## Instructions\n\n1. Implement the `createTokenInfoStream$` method. This method should return an `Observable` that calls the `getTokenInfo` function similar to the above examples, i.e. whenever the current user account changes or a new block comes in.\n\nRemember, if you get stuck, you can click `Show Solution` to see the solution. If this is your first time working with `Observable`s they may seem a bit mysterious, but over time you'll add common patterns for using them to your toolbelt.\n\n## Test\n\nOnce you've implemented the `createTokenInfoStream$` function correctly, try participating in the ICO and you should see the UI update reactively to the contribution. You can also try switching wallets using the developer tools, which will update the \"Your Balance:\" entry.\n\nThe tests verify the stream by checking the emitted values update reactively to contributions.\n\nBefore heading to the next chapter, take a look at how the `ICO` component (in `ICO.tsx`) uses the `FromStream` component we mentioned earlier to reactively update the UI in a very succint way. You'll also see how we're getting the `token` smart contract and `client` values - through the `WithContracts` component. This is a component that automatically wires up a React application to allow easy access to the functionality you need to interact with your dapp. Learn more about the React integration in the [documentation](/docs/react). Writing your app in Angular or Vue? No problem! Check out our [Angular](/docs/angular) or [Vue](/docs/vue) advanced guides to learn about to tools we provide.\n\n## Wrap Up\n\nIn this chapter we took a whirlwind tour through `Observable`s and how they can be used to reactively update your dapp's UI. At this point, we have a fully reactive UI for participating in an ICO. We'll take a look at how we can invoke the `transfer` and `withdraw` methods in the next two chapters.\n",files:[{path:"src/utils.ts",initial:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { Observable } from 'rxjs';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> => {\n  // Implement me\n};\n",solution:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { combineLatest, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> =>\n  combineLatest([client.currentUserAccount$, client.block$]).pipe(\n    switchMap(async ([userAccount]) =>\n      getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address),\n    ),\n  );\n"},{path:"src/__tests__/utils.test.ts",solution:"import { createPrivateKey } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { take } from 'rxjs/operators';\nimport { createTokenInfoStream$, getTokenInfo, handleMint, TokenInfoResult } from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token, networkName }) => {\n      expect(token).toBeDefined();\n\n      const toWallet = await token.client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n        balance,\n      } = await getTokenInfo(token, toWallet.userAccount.id.address);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n      expect(balance.toNumber()).toEqual(0);\n    });\n  });\n\n  test('handleMint mints tokens and createTokenInfoStream$ reacts to the mint', async () => {\n    await withContracts(async ({ client, developerClient, token, masterAccountID }) => {\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      const mintReceipt = await handleMint(token, new BigNumber(10));\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      const stream$ = createTokenInfoStream$(client, token);\n      let info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n    });\n  });\n});\n"},{path:"src/ICO.tsx",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport { FromStream } from '@neo-one/react';\nimport { Box, Button, TextInput } from '@neo-one/react-core';\nimport BigNumber from 'bignumber.js';\nimport * as React from 'react';\nimport { prop } from 'styled-tools';\nimport { TokenSmartContract, WithContracts } from '../one/generated';\nimport { createTokenInfoStream$, handleMint } from './utils';\n\nconst InfoGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst ContributeGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'input amount' auto\n    'empty send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst AmountInput = styled(TextInput)`\n  grid-area: input;\n`;\n\nconst AmountText = styled(Box)`\n  grid-area: amount;\n`;\n\nconst SendWrapper = styled(Box)`\n  display: grid;\n  grid-area: send;\n  grid-auto-flow: column;\n  justify-items: end;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\ninterface Props {}\ninterface State {\n  readonly text: string;\n  readonly amount?: BigNumber;\n  readonly loading: boolean;\n}\n\nexport class ICO extends React.Component<Props, State> {\n  public state: State = {\n    text: '',\n    loading: false,\n  };\n\n  public render() {\n    return (\n      <WithContracts>\n        {({ client, token }) => (\n          <FromStream props={[client, token]} createStream={() => createTokenInfoStream$(client, token)}>\n            {(value) => (\n              <Wrapper>\n                <InnerWrapper>\n                  <InfoGrid>\n                    <Box>Name:</Box>\n                    <Box>{value.name}</Box>\n                    <Box>Symbol:</Box>\n                    <Box>{value.symbol}</Box>\n                    <Box>Total Supply:</Box>\n                    <Box>{value.totalSupply.toFormat()}</Box>\n                    <Box>Amount Per NEO:</Box>\n                    <Box>{value.amountPerNEO.toFormat()}</Box>\n                    <Box>NEO Contributed:</Box>\n                    <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                    <Box>Remaining:</Box>\n                    <Box>{value.remaining.toFormat()}</Box>\n                    <Box>Start Time:</Box>\n                    <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                    <Box>Duration:</Box>\n                    <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                    <Box>Your Balance:</Box>\n                    <Box>{value.balance.toFormat()}</Box>\n                  </InfoGrid>\n                  <ContributeGrid>\n                    <AmountInput value={this.state.text} placeholder=\"Send NEO\" onChange={this.onChangeAmount} />\n                    <AmountText>\n                      {this.state.amount === undefined ? '0' : value.amountPerNEO.times(this.state.amount).toFormat()}\n                    </AmountText>\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.amount === undefined || this.state.loading}\n                        onClick={() => this.send(token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </ContributeGrid>\n                </InnerWrapper>\n              </Wrapper>\n            )}\n          </FromStream>\n        )}\n      </WithContracts>\n    );\n  }\n\n  private readonly onChangeAmount = (event: React.SyntheticEvent<any>) => {\n    const text = event.currentTarget.value;\n    let amount: BigNumber | undefined;\n    try {\n      amount = new BigNumber(text);\n      if (amount.toString() !== text) {\n        amount = undefined;\n      }\n    } catch {\n      // do nothing\n    }\n\n    this.setState({ text, amount });\n  };\n\n  private readonly send = (token: TokenSmartContract) => {\n    const amount = this.state.amount;\n    if (amount !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleMint(token, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            // We should show an error message, but for the course we'll just log the error to console.\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n}\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app'));\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]},{title:"Reactive Updates",documentation:"# Chapter 5: Transfer EON\n\nEarlier this lesson we saw how to invoke a method marked with `@receive`. Now we'll take a look at how to invoke the `transfer` method which does not have any decorators.\n\n## Learn\n\nIt turns out there's not much to learn here. Invoking a method without a decorator follows the same two step process that we mentioned in the earlier chapter, the only difference is we can't send native assets along with the invocation. So instead of covering the same material, we'll look at how we can shortcut that two step process if we don't care about knowing when the transaction has been successfully relayed. We can do this by invoking the `confirmed` property that is available on every smart contract method. Let's take a look at an example.\n\n```typescript\nimport { SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  public myMethod(value: string): boolean {\n    // do something with value\n\n    return true;\n  }\n}\n```\n\n```typescript\nconst receipt = await example.myMethod.confirmed('foo');\nif (receipt.result.state === 'FAULT') {\n  // do something when the transaction failed.\n} else {\n  // do something when the transaction succeeded.\n}\n```\n\nNotice how we call `example.myMethod.confirmed` which is just a shortcut for the following:\n\n```typescript\nconst result = await example.myMethod('foo');\nconst receipt = await result.confirmed();\n```\n\nEvery smart contract method has this property and it can be handy for cases where you don't require a side effect after relaying of a transaction only it's confirmation. For example, if you want your dapp to display a notification when a transaction has been relayed, you should use the two step confirmation process. If however you only care about updating the final balance once the result has been confirmed, then the one step confirmation process can be a handy shortcut.\n\n## Instructions\n\n  1. Implement `handleTransfer` which should call the `transfer` method of the token contract.\n\nSince we're not updating the UI when the transaction is successfully relayed, feel free to use either form of calling `transfer` to implement the method.\n\n## Test\n\nWe've added a simple UI for transferring tokens to a specified address. Use the developer tools to get the address of another configured wallet and then, after participating in the ICO, try transferring tokens to that address. You'll notice that the UI updates reactively to the transfer the same way it does for minting tokens. Use the developer tools to switch to the wallet you transferred to in order to see their new balance of EON tokens.\n\nSimilar to before, the unit tests simply verify that we can call `handleTransfer` to transfer tokens from one address to another.\n\n## Wrap Up\n\nIn this chapter we saw how invoking a smart contract method without decorators is virtually the same as what we saw for `mintTokens`. In the next chapter we'll hook up the `withdraw` method and find that, again, invoking a method with `@sendUnsafe` is very similar.\n",files:[{path:"src/utils.ts",initial:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { combineLatest, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> =>\n  combineLatest([client.currentUserAccount$, client.block$]).pipe(\n    switchMap(async ([userAccount]) =>\n      getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address),\n    ),\n  );\n\nexport const handleTransfer = async (\n  token: TokenSmartContract,\n  from: AddressString,\n  to: AddressString,\n  amount: BigNumber,\n): Promise<InvokeReceipt<boolean, TokenEvent>> => {\n  // Implement me\n};\n",solution:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { combineLatest, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> =>\n  combineLatest([client.currentUserAccount$, client.block$]).pipe(\n    switchMap(async ([userAccount]) =>\n      getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address),\n    ),\n  );\n\nexport const handleTransfer = async (\n  token: TokenSmartContract,\n  from: AddressString,\n  to: AddressString,\n  amount: BigNumber,\n): Promise<InvokeReceipt<boolean, TokenEvent>> => token.transfer.confirmed(from, to, amount);\n"},{path:"src/__tests__/utils.test.ts",solution:"import { createPrivateKey } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { take } from 'rxjs/operators';\nimport { createTokenInfoStream$, getTokenInfo, handleMint, TokenInfoResult, handleTransfer } from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token, networkName }) => {\n      expect(token).toBeDefined();\n\n      const toWallet = await token.client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n        balance,\n      } = await getTokenInfo(token, toWallet.userAccount.id.address);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n      expect(balance.toNumber()).toEqual(0);\n    });\n  });\n\n  test('handleMint mints tokens, createTokenInfoStream$ reacts to the mint, handleTransfer transfers tokens', async () => {\n    await withContracts(async ({ client, developerClient, token, masterAccountID, networkName }) => {\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      const mintReceipt = await handleMint(token, new BigNumber(10));\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      const stream$ = createTokenInfoStream$(client, token);\n      let info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n\n      const toWallet = await client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n      const transferAmount = new BigNumber(100000);\n      const transferReceipt = await handleTransfer(\n        token,\n        masterAccountID.address,\n        toWallet.userAccount.id.address,\n        transferAmount,\n      );\n      if (transferReceipt.result.state === 'FAULT') {\n        throw new Error(transferReceipt.result.message);\n      }\n      expect(transferReceipt.result.state).toEqual('HALT');\n      expect(transferReceipt.result.value).toEqual(true);\n      event = transferReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toWallet.userAccount.id.address);\n      expect(event.parameters.amount.toNumber()).toEqual(transferAmount.toNumber());\n    });\n  });\n});\n"},{path:"src/ICO.tsx",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport BigNumber from 'bignumber.js';\nimport { Client } from '@neo-one/client';\nimport { FromStream } from '@neo-one/react';\nimport { Box, Button, TextInput } from '@neo-one/react-core';\nimport * as React from 'react';\nimport { prop } from 'styled-tools';\nimport { TokenSmartContract, WithContracts } from '../one/generated';\nimport { createTokenInfoStream$, handleMint, handleTransfer } from './utils';\n\nconst InfoGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst ContributeGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'input amount' auto\n    'empty send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst TransferGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'address address' auto\n    'input send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst AmountInput = styled(TextInput)`\n  grid-area: input;\n`;\n\nconst AmountText = styled(Box)`\n  grid-area: amount;\n`;\n\nconst AddressInput = styled(TextInput)`\n  grid-area: address;\n`;\n\nconst SendWrapper = styled(Box)`\n  display: grid;\n  grid-area: send;\n  grid-auto-flow: column;\n  justify-items: end;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\ninterface Props {}\ninterface State {\n  readonly text: string;\n  readonly transferText: string;\n  readonly transferAddress: string;\n  readonly amount?: BigNumber;\n  readonly transferAmount?: BigNumber;\n  readonly loading: boolean;\n}\n\nexport class ICO extends React.Component<Props, State> {\n  public state: State = {\n    text: '',\n    transferText: '',\n    transferAddress: '',\n    loading: false,\n  };\n\n  public render() {\n    return (\n      <WithContracts>\n        {({ client, token }) => (\n          <FromStream props={[client, token]} createStream={() => createTokenInfoStream$(client, token)}>\n            {(value) => (\n              <Wrapper>\n                <InnerWrapper>\n                  <InfoGrid>\n                    <Box>Name:</Box>\n                    <Box>{value.name}</Box>\n                    <Box>Symbol:</Box>\n                    <Box>{value.symbol}</Box>\n                    <Box>Total Supply:</Box>\n                    <Box>{value.totalSupply.toFormat()}</Box>\n                    <Box>Amount Per NEO:</Box>\n                    <Box>{value.amountPerNEO.toFormat()}</Box>\n                    <Box>NEO Contributed:</Box>\n                    <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                    <Box>Remaining:</Box>\n                    <Box>{value.remaining.toFormat()}</Box>\n                    <Box>Start Time:</Box>\n                    <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                    <Box>Duration:</Box>\n                    <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                    <Box>Your Balance:</Box>\n                    <Box>{value.balance.toFormat()}</Box>\n                  </InfoGrid>\n                  <ContributeGrid>\n                    <AmountInput value={this.state.text} placeholder=\"Send NEO\" onChange={this.onChangeAmount} />\n                    <AmountText>\n                      {this.state.amount === undefined ? '0' : value.amountPerNEO.times(this.state.amount).toFormat()}\n                    </AmountText>\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.amount === undefined || this.state.loading}\n                        onClick={() => this.send(token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </ContributeGrid>\n                  <TransferGrid>\n                    <AddressInput\n                      value={this.state.transferAddress}\n                      placeholder=\"Transfer To Address\"\n                      onChange={this.onChangeTransferAddress}\n                    />\n                    <AmountInput\n                      value={this.state.transferText}\n                      placeholder=\"Send EON\"\n                      onChange={this.onChangeTransferAmount}\n                    />\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.transferAmount === undefined || this.state.loading}\n                        onClick={() => this.transfer(client, token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </TransferGrid>\n                </InnerWrapper>\n              </Wrapper>\n            )}\n          </FromStream>\n        )}\n      </WithContracts>\n    );\n  }\n\n  private readonly onChangeAmount = (event: React.SyntheticEvent<any>) => {\n    const text = event.currentTarget.value;\n    this.setState({ text, amount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAmount = (event: React.SyntheticEvent<any>) => {\n    const transferText = event.currentTarget.value;\n    this.setState({ transferText, transferAmount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAddress = (event: React.SyntheticEvent<any>) => {\n    this.setState({ transferAddress: event.currentTarget.value });\n  };\n\n  private readonly send = (token: TokenSmartContract) => {\n    const amount = this.state.amount;\n    if (amount !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleMint(token, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            // We should show an error message, but for the course we'll just log the error to console.\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private readonly transfer = (client: Client, token: TokenSmartContract) => {\n    const amount = this.state.transferAmount;\n    const account = client.getCurrentUserAccount();\n    const to = this.state.transferAddress;\n    if (amount !== undefined && account !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleTransfer(token, account.id.address, to, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private getAmount(event: React.SyntheticEvent<any>) {\n    const text = event.currentTarget.value;\n    let amount: BigNumber | undefined;\n    try {\n      amount = new BigNumber(text);\n      if (amount.toString() !== text) {\n        amount = undefined;\n      }\n    } catch {\n      // do nothing\n    }\n\n    return amount;\n  }\n}\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app'));\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]},{title:"Reactive Updates",documentation:"# Chapter 6: Withdraw NEO\n\nWe've seen how to invoke normal smart contract methods, methods decorated with `@receive` and now we'll learn how to invoke a method decorated with `@sendUnsafe`. Since this turns out to be very similar to methods marked with `@receive`, we'll also cover a few `Client` methods that will be used in the implementation for this chapter.\n\n## Learn\n\nLike `@receive`, methods marked with `@sendUnsafe` allow specifying native assets to include with the transaction. This time, however, you specify them with `sendFrom` since we'll be sending assets from the smart contract to another address. Let's take a look at an example.\n\n```typescript\nimport { sendUnsafe, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @sendUnsafe\n  public mySendUnsafe(value: string): void {\n    // do something with value + assets to be sent\n  }\n}\n```\n\n```typescript\nimport { Hash256 } from '@neo-one/client';\n\nconst result = await example.mySendUnsafe('foo', {\n  sendFrom: [{\n    asset: Hash256.NEO,\n    amount: new BigNumber(10),\n    to: 'APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR',\n  }]\n});\nconst receipt = await result.confirmed();\nif (receipt.result.state === 'FAULT') {\n  // do something when the transaction failed.\n} else {\n  // do something when the transaction succeeded.\n}\n```\n\nIn this example, we're invoking the method `mySendUnsafe` with the argument `'foo'` and also specifying that we want to send `10` NEO from the contract to the given address. Notice how the invocation is very similar to how we invoked methods decorated with `@receive`.\n\nBefore we move on to the instructions for this chapter, let's take a quick look at how we can fetch the balances for a given account so that when we use the `withdraw` function of the EON contract, we know how much is available to withdraw.\n\nWe can use the method `getAccount` on the `Client` to fetch the current balance of all native assets for a given network and address, called a `UserAccountID` within the NEO•ONE client APIs. One thing to note about the NEO•ONE client APIs is that they're not only address agnostic, as in they will use whichever address is currently selected, but they're also network agnostic. We haven't needed to specify a network (or address) explicitly thus far because all of the smart contract methods automatically use the network of the currently selected account. The currently selected account also automatically signs every transaction.\n\nNow, back to `getAccount` - we can get the currently selected account using `getCurrentUserAccount`. Note that this may return an `undefined` value if no account is selected, or more commonly, if the user has not enabled access to their external account through nOS, NEX or NEO Tracker. Assuming it's defined, we now have the network that the `Client` is currently operating with.\n\nWe can pull the address of our deployed smart contract for a particular network through the `definition` property of the smart contract. Let's take a look at an example:\n\n```typescript\nimport { Hash256 } from '@neo-one/client';\n\nconst userAccount = client.getCurrentUserAccount();\nif (userAccount !== undefined) {\n  const network = userAccount.id.network;\n  const contractAddress = example.definition.networks[network].address;\n  const contractID = { network, address: contractAddress };\n  const contractAccount = await client.getAccount(contractID);\n  const neoBalance = contractAccount.balances[Hash256.NEO] as BigNumber | undefined;\n  // do something with the contract account and/or the neo balance.\n}\n```\n\nIn this example, we get the currently selected `UserAccount` and if it's defined, we use it to fetch the `Account` of the `Example` contract on the `UserAccount`'s network. Notice that we type cast the `balances` value for `Hash256.NEO` to `BigNumber | undefined` - this is because if the balance of that account is 0, then it might not be defined in the `balances` object. However, in TypeScript, it's rather inconvenient to declare the value type of an object as possibly undefined, so we just need to remember to cast it when we're accessing the value of a particular asset.\n\n## Instructions\n\nImplement `handleWithdraw`:\n\n  1. Fetch the current NEO balance of the token contract account.\n  2. Invoke `withdraw` using the current NEO balance as the amount to withdraw and the current `UserAccount` as the address to withdraw to.\n\n## Test\n\nOnce you've implemented `handleWithdraw` you can test it out by participating in the ICO (don't forget to fast forward by an hour to the ICO start time) and then clicking the `Withdraw` button. The tests will also verify that `handleWithdraw` is implemented correctly, that is, by verifying that the entirety of the contributions are withdrawn from the token contract account.\n\n## Wrap Up\n\nIn this chapter we saw how to invoke a smart contract method decorated with `@sendUnsafe` using the NEO•ONE client APIs. We also saw how we can use the `Client` to get the currently selected `UserAccount` as well as fetch the balance of an arbitrary `Account`. Finally, we were able to pull the address of our Eon contract with the `definition` property.\n\nAnd with that, we've implemented a UI for the entire Eon token smart contract. Not bad for 6 chapters. In case you want to play around with the UI implementation itself, we've made the `ICO.tsx` file writable. The original `ICO.tsx` content can be found in the `Show Solution` menu in case you want to revert back.\n\nIn the next lesson, we'll create an escrow contract that uses our Eon token as well as modify the Eon token itself to enable other contracts to easily interact with it. See you on the other side!\n",files:[{path:"src/utils.ts",initial:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { combineLatest, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> =>\n  combineLatest([client.currentUserAccount$, client.block$]).pipe(\n    switchMap(async ([userAccount]) =>\n      getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address),\n    ),\n  );\n\nexport const handleTransfer = async (\n  token: TokenSmartContract,\n  from: AddressString,\n  to: AddressString,\n  amount: BigNumber,\n): Promise<InvokeReceipt<boolean, TokenEvent>> => token.transfer.confirmed(from, to, amount);\n\nexport const handleWithdraw = async (\n  client: Client,\n  token: TokenSmartContract,\n): Promise<void> => {\n  // Implement me\n};\n",solution:"import { AddressString, Client, Hash256, InvokeReceipt } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { combineLatest, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TokenEvent, TokenSmartContract } from '../one/generated';\n\nexport interface TokenInfoResult {\n  readonly name: string;\n  readonly symbol: string;\n  readonly amountPerNEO: BigNumber;\n  readonly totalSupply: BigNumber;\n  readonly remaining: BigNumber;\n  readonly icoStartTimeSeconds: BigNumber;\n  readonly icoDurationSeconds: BigNumber;\n  readonly balance: BigNumber;\n}\n\nexport const getTokenInfo = async (token: TokenSmartContract, address?: AddressString): Promise<TokenInfoResult> => {\n  const [\n    name,\n    symbol,\n    amountPerNEO,\n    totalSupply,\n    remaining,\n    icoStartTimeSeconds,\n    icoDurationSeconds,\n    balance,\n  ] = await Promise.all([\n    token.name(),\n    token.symbol(),\n    token.amountPerNEO(),\n    token.totalSupply(),\n    token.remaining(),\n    token.icoStartTimeSeconds(),\n    token.icoDurationSeconds(),\n    address === undefined ? Promise.resolve(new BigNumber(0)) : token.balanceOf(address),\n  ]);\n\n  return { name, symbol, amountPerNEO, totalSupply, remaining, icoStartTimeSeconds, icoDurationSeconds, balance };\n};\n\nexport const handleMint = async (\n  token: TokenSmartContract,\n  amount: BigNumber,\n): Promise<InvokeReceipt<undefined, TokenEvent>> => {\n  const result = await token.mintTokens({\n    sendTo: [\n      {\n        asset: Hash256.NEO,\n        amount,\n      },\n    ],\n  });\n\n  return result.confirmed();\n};\n\nexport const createTokenInfoStream$ = (client: Client, token: TokenSmartContract): Observable<TokenInfoResult> =>\n  combineLatest([client.currentUserAccount$, client.block$]).pipe(\n    switchMap(async ([userAccount]) =>\n      getTokenInfo(token, userAccount === undefined ? undefined : userAccount.id.address),\n    ),\n  );\n\nexport const handleTransfer = async (\n  token: TokenSmartContract,\n  from: AddressString,\n  to: AddressString,\n  amount: BigNumber,\n): Promise<InvokeReceipt<boolean, TokenEvent>> => token.transfer.confirmed(from, to, amount);\n\nexport const handleWithdraw = async (\n  client: Client,\n  token: TokenSmartContract,\n): Promise<void> => {\n  const currentAccount = client.getCurrentUserAccount();\n  if (currentAccount !== undefined) {\n    const network = currentAccount.id.network;\n    const address = token.definition.networks[network].address;\n    const contractAccount = await client.getAccount({ network, address });\n    const balance = contractAccount.balances[Hash256.NEO] as BigNumber | undefined;\n    if (balance !== undefined) {\n      await token.withdraw.confirmed({\n        sendFrom: [\n          {\n            asset: Hash256.NEO,\n            amount: balance,\n            to: currentAccount.id.address,\n          },\n        ],\n      });\n    }\n  }\n};\n"},{path:"src/__tests__/utils.test.ts",solution:"import { createPrivateKey, Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { take } from 'rxjs/operators';\nimport {\n  createTokenInfoStream$,\n  getTokenInfo,\n  handleMint,\n  TokenInfoResult,\n  handleTransfer,\n  handleWithdraw,\n} from '../utils';\nimport { withContracts } from '../../one/generated/test';\n\ndescribe('utils', () => {\n  test('getTokenInfo returns token info', async () => {\n    await withContracts(async ({ token, networkName }) => {\n      expect(token).toBeDefined();\n\n      const toWallet = await token.client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n\n      const {\n        name,\n        symbol,\n        amountPerNEO,\n        totalSupply,\n        remaining,\n        icoStartTimeSeconds,\n        icoDurationSeconds,\n        balance,\n      } = await getTokenInfo(token, toWallet.userAccount.id.address);\n\n      expect(name).toEqual('Eon');\n      expect(symbol).toEqual('EON');\n      expect(amountPerNEO.toNumber()).toEqual(100000);\n      expect(totalSupply.toNumber()).toEqual(0);\n      expect(remaining.toNumber()).toEqual(10_000_000_000);\n      expect(icoStartTimeSeconds).toBeDefined();\n      expect(icoDurationSeconds.toNumber()).toEqual(24 * 60 * 60);\n      expect(balance.toNumber()).toEqual(0);\n    });\n  });\n\n  test('handleMint mints tokens, createTokenInfoStream$ reacts to the mint, handleTransfer transfers tokens and handleWithdraw withdraws contributions', async () => {\n    await withContracts(async ({ client, developerClient, token, masterAccountID, networkName }) => {\n      let error: Error | undefined;\n      try {\n        // Note that this transaction doesn't even get relayed to the blockchain and instead immediately fails because\n        // the smart contract returned false from receiving assets.\n        // Here we test that the mint tokens fails before the start time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Fast forward to the start of the ICO\n      await developerClient.fastForwardOffset(60 * 60);\n\n      const mintReceipt = await handleMint(token, new BigNumber(10));\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n\n      expect(mintReceipt.result.state).toEqual('HALT');\n      expect(mintReceipt.result.value).toBeUndefined();\n      expect(mintReceipt.events).toHaveLength(1);\n      let event = mintReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toBeUndefined();\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(1000000);\n\n      const stream$ = createTokenInfoStream$(client, token);\n      let info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n\n      // Fast forward past the end of of the ICO\n      await developerClient.fastForwardOffset(24 * 60 * 60);\n\n      error = undefined;\n      try {\n        // Here we test that the mint tokens fails after the end time of the ICO\n        await handleMint(token, new BigNumber(10));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      info = await stream$.pipe<TokenInfoResult>(take(1)).toPromise();\n      expect(info.balance.toNumber()).toEqual(1000000);\n\n      const toWallet = await client.providers.memory.keystore.addUserAccount({\n        network: networkName,\n        privateKey: createPrivateKey(),\n      });\n      const transferAmount = new BigNumber(100000);\n      const transferReceipt = await handleTransfer(\n        token,\n        masterAccountID.address,\n        toWallet.userAccount.id.address,\n        transferAmount,\n      );\n      if (transferReceipt.result.state === 'FAULT') {\n        throw new Error(transferReceipt.result.message);\n      }\n      expect(transferReceipt.result.state).toEqual('HALT');\n      expect(transferReceipt.result.value).toEqual(true);\n      event = transferReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toWallet.userAccount.id.address);\n      expect(event.parameters.amount.toNumber()).toEqual(transferAmount.toNumber());\n\n      await handleWithdraw(client, token);\n      const account = await client.getAccount({\n        network: networkName,\n        address: token.definition.networks[networkName].address,\n      });\n      expect(account.balances[Hash256.NEO]).toBeUndefined();\n    });\n  });\n});\n"},{path:"src/ICO.tsx",initial:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport BigNumber from 'bignumber.js';\nimport { Client } from '@neo-one/client';\nimport { FromStream } from '@neo-one/react';\nimport { Box, Button, TextInput } from '@neo-one/react-core';\nimport * as React from 'react';\nimport { prop } from 'styled-tools';\nimport { TokenSmartContract, WithContracts } from '../one/generated';\nimport { createTokenInfoStream$, handleMint, handleTransfer, handleWithdraw } from './utils';\n\nconst InfoGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst ContributeGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'input amount' auto\n    'empty send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst TransferGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'address address' auto\n    'input send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst WithdrawGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  justify-items: end;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst AmountInput = styled(TextInput)`\n  grid-area: input;\n`;\n\nconst AmountText = styled(Box)`\n  grid-area: amount;\n`;\n\nconst AddressInput = styled(TextInput)`\n  grid-area: address;\n`;\n\nconst SendWrapper = styled(Box)`\n  display: grid;\n  grid-area: send;\n  grid-auto-flow: column;\n  justify-items: end;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\ninterface Props {}\ninterface State {\n  readonly text: string;\n  readonly transferText: string;\n  readonly transferAddress: string;\n  readonly amount?: BigNumber;\n  readonly transferAmount?: BigNumber;\n  readonly loading: boolean;\n}\n\nexport class ICO extends React.Component<Props, State> {\n  public state: State = {\n    text: '',\n    transferText: '',\n    transferAddress: '',\n    loading: false,\n  };\n\n  public render() {\n    return (\n      <WithContracts>\n        {({ client, token }) => (\n          <FromStream props={[client, token]} createStream={() => createTokenInfoStream$(client, token)}>\n            {(value) => (\n              <Wrapper>\n                <InnerWrapper>\n                  <InfoGrid>\n                    <Box>Name:</Box>\n                    <Box>{value.name}</Box>\n                    <Box>Symbol:</Box>\n                    <Box>{value.symbol}</Box>\n                    <Box>Total Supply:</Box>\n                    <Box>{value.totalSupply.toFormat()}</Box>\n                    <Box>Amount Per NEO:</Box>\n                    <Box>{value.amountPerNEO.toFormat()}</Box>\n                    <Box>NEO Contributed:</Box>\n                    <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                    <Box>Remaining:</Box>\n                    <Box>{value.remaining.toFormat()}</Box>\n                    <Box>Start Time:</Box>\n                    <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                    <Box>Duration:</Box>\n                    <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                    <Box>Your Balance:</Box>\n                    <Box>{value.balance.toFormat()}</Box>\n                  </InfoGrid>\n                  <ContributeGrid>\n                    <AmountInput value={this.state.text} placeholder=\"Send NEO\" onChange={this.onChangeAmount} />\n                    <AmountText>\n                      {this.state.amount === undefined ? '0' : value.amountPerNEO.times(this.state.amount).toFormat()}\n                    </AmountText>\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.amount === undefined || this.state.loading}\n                        onClick={() => this.send(token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </ContributeGrid>\n                  <TransferGrid>\n                    <AddressInput\n                      value={this.state.transferAddress}\n                      placeholder=\"Transfer To Address\"\n                      onChange={this.onChangeTransferAddress}\n                    />\n                    <AmountInput\n                      value={this.state.transferText}\n                      placeholder=\"Send EON\"\n                      onChange={this.onChangeTransferAmount}\n                    />\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.transferAmount === undefined || this.state.loading}\n                        onClick={() => this.transfer(client, token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </TransferGrid>\n                  <WithdrawGrid>\n                    <Button disabled={this.state.loading} onClick={() => this.withdraw(client, token)}>\n                      Withdraw\n                    </Button>\n                  </WithdrawGrid>\n                </InnerWrapper>\n              </Wrapper>\n            )}\n          </FromStream>\n        )}\n      </WithContracts>\n    );\n  }\n\n  private readonly onChangeAmount = (event: React.SyntheticEvent<any>) => {\n    const text = event.currentTarget.value;\n    this.setState({ text, amount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAmount = (event: React.SyntheticEvent<any>) => {\n    const transferText = event.currentTarget.value;\n    this.setState({ transferText, transferAmount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAddress = (event: React.SyntheticEvent<any>) => {\n    this.setState({ transferAddress: event.currentTarget.value });\n  };\n\n  private readonly send = (token: TokenSmartContract) => {\n    const amount = this.state.amount;\n    if (amount !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleMint(token, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            // We should show an error message, but for the course we'll just log the error to console.\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private readonly transfer = (client: Client, token: TokenSmartContract) => {\n    const amount = this.state.transferAmount;\n    const account = client.getCurrentUserAccount();\n    const to = this.state.transferAddress;\n    if (amount !== undefined && account !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleTransfer(token, account.id.address, to, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private readonly withdraw = (client: Client, token: TokenSmartContract) => {\n    this.setState({ loading: true }, () => {\n      handleWithdraw(client, token)\n        .then(() => {\n          this.setState({ loading: false });\n        })\n        .catch((error) => {\n          // We should show an error message, but for the course we'll just log the error to console.\n          console.error(error);\n          this.setState({ loading: false });\n        });\n    });\n  };\n\n  private getAmount(event: React.SyntheticEvent<any>) {\n    const text = event.currentTarget.value;\n    let amount: BigNumber | undefined;\n    try {\n      amount = new BigNumber(text);\n      if (amount.toString() !== text) {\n        amount = undefined;\n      }\n    } catch {\n      // do nothing\n    }\n\n    return amount;\n  }\n}\n",solution:"/// <reference types=\"@emotion/core\"/>\nimport styled from '@emotion/styled';\nimport BigNumber from 'bignumber.js';\nimport { Client } from '@neo-one/client';\nimport { FromStream } from '@neo-one/react';\nimport { Box, Button, TextInput } from '@neo-one/react-core';\nimport * as React from 'react';\nimport { prop } from 'styled-tools';\nimport { TokenSmartContract, WithContracts } from '../one/generated';\nimport { createTokenInfoStream$, handleMint, handleTransfer, handleWithdraw } from './utils';\n\nconst InfoGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  padding: 8px;\n  margin: 8px;\n  color: ${prop('theme.black')};\n  grid-template-columns: '160px 1fr';\n  grid-auto-rows: auto;\n  gap: 0;\n`;\n\nconst ContributeGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'input amount' auto\n    'empty send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst TransferGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  grid:\n    'address address' auto\n    'input send' auto\n    / 1fr auto;\n  grid-gap: 8px;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst WithdrawGrid = styled(Box)<{}, {}>`\n  display: grid;\n  ${prop('theme.fonts.axiformaRegular')};\n  ${prop('theme.fontStyles.body1')};\n  background-color: ${prop('theme.gray0')};\n  justify-items: end;\n  padding: 8px;\n  margin: 8px;\n`;\n\nconst AmountInput = styled(TextInput)`\n  grid-area: input;\n`;\n\nconst AmountText = styled(Box)`\n  grid-area: amount;\n`;\n\nconst AddressInput = styled(TextInput)`\n  grid-area: address;\n`;\n\nconst SendWrapper = styled(Box)`\n  display: grid;\n  grid-area: send;\n  grid-auto-flow: column;\n  justify-items: end;\n`;\n\nconst Wrapper = styled(Box)`\n  display: grid;\n  justify-items: center;\n`;\n\nconst InnerWrapper = styled(Box)`\n  max-width: 400px;\n`;\n\ninterface Props {}\ninterface State {\n  readonly text: string;\n  readonly transferText: string;\n  readonly transferAddress: string;\n  readonly amount?: BigNumber;\n  readonly transferAmount?: BigNumber;\n  readonly loading: boolean;\n}\n\nexport class ICO extends React.Component<Props, State> {\n  public state: State = {\n    text: '',\n    transferText: '',\n    transferAddress: '',\n    loading: false,\n  };\n\n  public render() {\n    return (\n      <WithContracts>\n        {({ client, token }) => (\n          <FromStream props={[client, token]} createStream={() => createTokenInfoStream$(client, token)}>\n            {(value) => (\n              <Wrapper>\n                <InnerWrapper>\n                  <InfoGrid>\n                    <Box>Name:</Box>\n                    <Box>{value.name}</Box>\n                    <Box>Symbol:</Box>\n                    <Box>{value.symbol}</Box>\n                    <Box>Total Supply:</Box>\n                    <Box>{value.totalSupply.toFormat()}</Box>\n                    <Box>Amount Per NEO:</Box>\n                    <Box>{value.amountPerNEO.toFormat()}</Box>\n                    <Box>NEO Contributed:</Box>\n                    <Box>{value.totalSupply.div(value.amountPerNEO).toFormat()}</Box>\n                    <Box>Remaining:</Box>\n                    <Box>{value.remaining.toFormat()}</Box>\n                    <Box>Start Time:</Box>\n                    <Box>{new Date(value.icoStartTimeSeconds.toNumber() * 1000).toLocaleString()}</Box>\n                    <Box>Duration:</Box>\n                    <Box>{value.icoDurationSeconds.toNumber() / (60 * 60)} hours</Box>\n                    <Box>Your Balance:</Box>\n                    <Box>{value.balance.toFormat()}</Box>\n                  </InfoGrid>\n                  <ContributeGrid>\n                    <AmountInput value={this.state.text} placeholder=\"Send NEO\" onChange={this.onChangeAmount} />\n                    <AmountText>\n                      {this.state.amount === undefined ? '0' : value.amountPerNEO.times(this.state.amount).toFormat()}\n                    </AmountText>\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.amount === undefined || this.state.loading}\n                        onClick={() => this.send(token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </ContributeGrid>\n                  <TransferGrid>\n                    <AddressInput\n                      value={this.state.transferAddress}\n                      placeholder=\"Transfer To Address\"\n                      onChange={this.onChangeTransferAddress}\n                    />\n                    <AmountInput\n                      value={this.state.transferText}\n                      placeholder=\"Send EON\"\n                      onChange={this.onChangeTransferAmount}\n                    />\n                    <SendWrapper>\n                      <Button\n                        disabled={this.state.transferAmount === undefined || this.state.loading}\n                        onClick={() => this.transfer(client, token)}\n                      >\n                        Send\n                      </Button>\n                    </SendWrapper>\n                  </TransferGrid>\n                  <WithdrawGrid>\n                    <Button disabled={this.state.loading} onClick={() => this.withdraw(client, token)}>\n                      Withdraw\n                    </Button>\n                  </WithdrawGrid>\n                </InnerWrapper>\n              </Wrapper>\n            )}\n          </FromStream>\n        )}\n      </WithContracts>\n    );\n  }\n\n  private readonly onChangeAmount = (event: React.SyntheticEvent<any>) => {\n    const text = event.currentTarget.value;\n    this.setState({ text, amount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAmount = (event: React.SyntheticEvent<any>) => {\n    const transferText = event.currentTarget.value;\n    this.setState({ transferText, transferAmount: this.getAmount(event) });\n  };\n\n  private readonly onChangeTransferAddress = (event: React.SyntheticEvent<any>) => {\n    this.setState({ transferAddress: event.currentTarget.value });\n  };\n\n  private readonly send = (token: TokenSmartContract) => {\n    const amount = this.state.amount;\n    if (amount !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleMint(token, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            // We should show an error message, but for the course we'll just log the error to console.\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private readonly transfer = (client: Client, token: TokenSmartContract) => {\n    const amount = this.state.transferAmount;\n    const account = client.getCurrentUserAccount();\n    const to = this.state.transferAddress;\n    if (amount !== undefined && account !== undefined) {\n      this.setState({ loading: true }, () => {\n        handleTransfer(token, account.id.address, to, amount)\n          .then(() => {\n            this.setState({ loading: false });\n          })\n          .catch((error) => {\n            console.error(error);\n            this.setState({ loading: false });\n          });\n      });\n    }\n  };\n\n  private readonly withdraw = (client: Client, token: TokenSmartContract) => {\n    this.setState({ loading: true }, () => {\n      handleWithdraw(client, token)\n        .then(() => {\n          this.setState({ loading: false });\n        })\n        .catch((error) => {\n          // We should show an error message, but for the course we'll just log the error to console.\n          console.error(error);\n          this.setState({ loading: false });\n        });\n    });\n  };\n\n  private getAmount(event: React.SyntheticEvent<any>) {\n    const text = event.currentTarget.value;\n    let amount: BigNumber | undefined;\n    try {\n      amount = new BigNumber(text);\n      if (amount.toString() !== text) {\n        amount = undefined;\n      }\n    } catch {\n      // do nothing\n    }\n\n    return amount;\n  }\n}\n"},{path:"src/index.tsx",solution:"import { theme } from '@neo-one/react-core';\nimport { ThemeProvider } from 'emotion-theming';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { ContractsProvider } from '../one/generated';\nimport { ICO } from './ICO';\n\nconst App = (\n  <ThemeProvider theme={theme}>\n    <ContractsProvider>\n      <ICO />\n    </ContractsProvider>\n  </ThemeProvider>\n);\n\nReactDOM.render(App, document.getElementById('app'));\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"public/index.html",solution:'<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <style>\n    body {\n      margin: 0;\n      background-color: #2E2837;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app"></div>\n</body>\n\n</html>\n'},{path:"package.json",solution:'{\n  "dependencies": {\n    "@emotion/core": "10.0.27",\n    "@emotion/styled": "10.0.27",\n    "@neo-one/react": "2.3.0",\n    "@neo-one/react-core": "2.3.0",\n    "@types/react": "16.9.19",\n    "@types/react-dom": "16.9.1",\n    "bignumber.js": "9.0.0",\n    "emotion-theming": "10.0.27",\n    "react": "16.10.0",\n    "react-dom": "16.10.0",\n    "rxjs": "6.5.4",\n    "styled-tools": "1.7.1"\n  }\n}\n'}]}]},{title:"Build an Escrow Account",documentation:"# Use the EON Token.\n\nNow that we've launched our ICO, let's build a few contracts that make use of the EON token. We'll learn some advanced concepts in smart contract programming as well as reinforce what we've learned in previous lessons.\n\nIn this lesson we'll build a simple Escrow contract that allows one person to send EON to another person, but requires them to take action to claim the EON. If they don't claim the EON, the sender can reclaim their tokens.\n\n__Let's get started!__\n",chapters:[{title:"Pre-Approved Transfers",documentation:"# Chapter 1: Pre-Approved Transfers\n\nBefore we get started on the Escrow contract, we need to enable other contracts to interact with the EON `Token` contract on behalf of a user. There's two primary ways to do this, we'll learn about one in this chapter and the other in the next lesson.\n\nAs a quick reminder, remember that you can build the contracts by clicking `Build` at the bottom of the editor and you can run the tests by clicking `Run Tests`. Once the tests pass, you may proceed to the next chapter by clicking `Next`. If you ever get stuck, click `Show Solution` to view the solution code for the chapter.\n\n## Learn\n\nRecall from previous lessons that we used `Address.isCaller` to verify that a particular action, e.g. `transfer`, was both directly called by and approved by the given address. This means that a smart contract won't be able call `transfer` on behalf of another user, even if they've signed the transaction. We make this stronger check that the call is both approved AND direct because if we only checked that it was approved, i.e. the transaction was signed by the address, a malicious contract could drain the account of all NEP-5 tokens or related assets by simply calling every transfer method of every NEP-5 token.\n\nTherefore, we'll need another mechanism to enable a smart contract to take action on behalf of another user. Let's take a look at an example.\n\n```typescript\nimport { Address, Blockchain, SetStorage, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  public readonly preapprovedActions = SetStorage.for<[Address, Address]>();\n\n  public approveAction(for: Address, by: Address): boolean {\n    if (!Address.isCaller(for)) {\n      return false;\n    }\n\n    this.preapprovedActions.add([for, by]);\n\n    return true;\n  }\n\n  public revokeAction(for: Address, by: Address): boolean {\n    if (!Address.isCaller(for)) {\n      return false;\n    }\n\n    this.preapprovedActions.delete([for, by]);\n\n    return true;\n  }\n\n  public action(for: Address): boolean {\n    if (\n      !Address.isCaller(for) &&\n      (Blockchain.currentCallerContract === undefined || !this.preapprovedActions.has([for, Blockchain.currentCallerContract]))\n    ) {\n      return false;\n    }\n\n    // Take the action\n\n    return true;\n  }\n}\n```\n\nIn this example, we have a method `action` that represents taking an action on the parameter `for` `Address`. Like before, we check if `for` is the caller of the method. We've also added a check to see if the current calling contract, which can be accessed with the `Blockchain.currentCallerContract` property, has been pre-approved to take the action. Notice that `Blockchain.currentCallerContract` will be `undefined` if the call was initiated directly by a user, and not through another smart contract.\n\nIf the exact mechanics here seems a bit confusing, don't worry, it will become more clear in the following chapter when we make use of the pre-approval with our Escrow contract.\n\nA user can pre-approve a contract by invoking the `approveAction` method, which first checks to see that the user is the caller and if so, adds the `by` parameter `Address` to the `preapprovedActions` `SetStorage`. We're using `SetStorage` for the first time here - like `MapStorage`, `SetStorage` works identically to a `Set` with the one exception that you can't get the `size` of it.\n\nAdditionally, a user can revoke their previous approval by invoking the `revokeAction` method. With these 2 methods and the additional check on `Blockchain.currentCallerContract`, the contract can now safely allow other smart contracts to invoke `action` on behalf of the user.\n\n## Instructions\n\nWe're going to implement quite a bit in this chapter, but most of it will be reinforcing what we've learned in previous chapters. Remember, if you feel like you're not sure how to proceed, you can always check the solution by clicking `Show Solution`. Alternatively, you can take a look at the tests to see if you're on the right track.\n\nBefore diving into the detailed instructions, at a high level we want to enable users to approve smart contracts to make transfers for a given maximum amount on their behalf. We'll enable this by implementing a few methods, `approveSendTransfer` which will add to our approvals, `revokeSendTransfer` which will revoke an approval and `approvedTransfer` which will return the current amount approved for transferring. We'll hold off on modifying the `transfer` method to make use of approvals (and `Blockchain.currentCallerContract`) until one of the following chapters where we can properly test it. Let's get started!\n\n  1. Add a `private` `readonly` `MapStorage<[Address, Address], Fixed<8>>` property called `approvedTransfers`. The first `Address` in the pair represents the user `Address` that is approving the second `Address` in the pair to transfer up to the `Fixed<8>` value amount of tokens.\n  2. Add a `@constant` `approvedTransfer` method which takes two parameters, a `from` `Address` and a `by` `Address | undefined` and returns a `Fixed<8>` approved amount that the `by` `Address` can transfer on behalf of the `from` `Address`.\n  3. Add an `approveSendTransfer` method which takes a `from` `Address`, a `by` `Address` and an `amount` `Fixed<8>` that the `from` `Address` wants to pre-approve transfers for the `by` `Address`. Remember to check for invalid inputs!\n  4. In the `approveSendTransfer` method, invoke an event notifier that emits an event called `'approveSendTransfer'` for the `from`, `by`, and `amount` arguments.\n  5. Add a `revokeSendTransfer` method which takes a `from` `Address`, a `by` `Address` and an `amount` `Fixed<8>` that the `from` `Address` wishes to revoke the pre-approval for.\n  6. In the `revokeSendTransfer` method, invoke an event notifier that emits an event called `'revokeSendTransfer'` for the `from`, `by`, and `amount` arguments.\n\n\n## Test\n\nPhew, that was quite a bit. You should feel proud of yourself for implementing all of that! We've added a new test case (and skipped the old tests) which verifies the `approveSendTransfer` and `revokeSendTransfer` methods, once the tests pass you may proceed to the next chapter.\n\n## Wrap Up\n\nIn this chapter we took a look at how we can pre-approve actions by smart contracts on behalf of other users by using the `Blockchain.currentCallerContract` property. Though we haven't used `Blockchain.currentCallerContract` yet, it set the stage for the approve and revoke methods that we implemented in this chapter. On the other side of the `Next` button we'll start building our Escrow contract!\n",files:[{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Token.test.ts",solution:"import BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Token', () => {\n  test('can pre-approve and revoke transfers', async () => {\n    await withContracts(async ({ token, masterAccountID, accountIDs }) => {\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Pre-approve a transfer\n      const amount = new BigNumber(100);\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        amount,\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.state).toEqual('HALT');\n      expect(approveReceipt.result.value).toEqual(true);\n      expect(approveReceipt.events).toHaveLength(1);\n      let event = approveReceipt.events[0];\n      expect(event.name).toEqual('approveSendTransfer');\n      if (event.name !== 'approveSendTransfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.by).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(amount.toNumber());\n\n      // Verify the approved amount matches above.\n      let approvedAmount = await token.approvedTransfer(masterAccountID.address, toAccountID.address);\n      expect(approvedAmount.toNumber()).toEqual(amount.toNumber());\n\n      // Revoke part of the approval\n      const revokeAmount = new BigNumber(25);\n      const revokeReceipt = await token.revokeSendTransfer.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        revokeAmount,\n      );\n      if (revokeReceipt.result.state === 'FAULT') {\n        throw new Error(revokeReceipt.result.message);\n      }\n      expect(revokeReceipt.result.state).toEqual('HALT');\n      expect(revokeReceipt.result.value).toEqual(true);\n      expect(revokeReceipt.events).toHaveLength(1);\n      event = revokeReceipt.events[0];\n      expect(event.name).toEqual('revokeSendTransfer');\n      if (event.name !== 'revokeSendTransfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.by).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(revokeAmount.toNumber());\n\n      // Verify the approved amount is updated to reflect the revoked amount\n      approvedAmount = await token.approvedTransfer(masterAccountID.address, toAccountID.address);\n      expect(approvedAmount.toNumber()).toEqual(amount.minus(revokeAmount).toNumber());\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Deposit Funds",documentation:"# Chapter 2: Deposit Funds\n\nLast chapter was a lot of reinforcing previously learned concepts, and this one will be much the same as we develop the shell of our Escrow contract. The Escrow contract should allow one person to deposit funds into a shared account with another address, where either party may withdraw funds from the account at any time. One might use this, for example, to give Eon to friends to try out and if they don't end up claiming it, then they can get it back - i.e. it's not just lost forever.\n\n## Learn\n\nThis chapter doesn't have anything new to learn - rather than try to throw in new concepts at the same time as revisiting old ones, we felt it best to just let you focus on building out the contract from scratch on your own.\n\n## Instructions\n\nStarting from scratch, we're going to implement the shell of the Escrow contract. We'll need to do the following:\n\n  1. Add a `MapStorage<[Address, Address], Fixed<8>>` property named `balances` to store the balance of each shared account\n  2. Add a `@constant` method named `balanceOf`  for checking the balance of a given shared account.\n  3. Add a method named `deposit` which accepts a `from` and `to` which specify the shared account, and `amount` for the amount in that account. Increase the balance of the shared account by `amount`.\n  4. Add an event notifier to `deposit` called `balanceAvailable` that takes the `from`, `to`, and `amount` as parameters. Invoke the event notifier in the `deposit` method.\n\nNote that we haven't transferred any tokens yet, and functionally our smart contract doesn't do much since all we're doing is incrementing a balance. In the next chapter we'll make this a bit more functional once the shell is complete.\n\n## Test\n\nWe've started a new set of test cases in `Escrow.test.ts` which validate that we can call the `deposit` method and that the escrow balance is updated correctly.\n\n## Wrap Up\n\nIn this chapter we reinforced concepts learned in earlier lessons to create a new smart contract from scratch. Next chapter we'll learn how to invoke methods on the Token contract from our Escrow contract.\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"",solution:"import { Address, constant, createEventNotifier, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.setBalance(from, to, this.balanceOf(from, to) + amount);\n    notifyBalanceAvailable(from, to, amount);\n\n    return true;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('can deposit funds', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount,\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Depost into the Escrow account\n      const escrowReceipt = await escrow.deposit.confirmed(masterAccountID.address, toAccountID.address, escrowAmount);\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Verify the escrow balance matches the above.\n      const escrowBalance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(escrowBalance.toNumber()).toEqual(escrowAmount.toNumber());\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Escrow Transfer",documentation:"# Chapter 3: Escrow Transfer\n\nNow that we have the shell of the Escrow contract we can learn how to interact with other smart contracts. In this chapter we'll cover how to use the EON `Token` contract from our `Escrow` contract as well as cover a few other things to keep in mind when invoking other contracts.\n\n## Learn\n\nLet's dive right in with an example:\n\nGiven a contract `Foo` with event `calledFizz` in `Foo.ts`\n\n```typescript\nimport { createEventNotifier, SmartContract } from '@neo-one/smart-contract';\n\nconst notifyCalledFizz = createEventNotifier<string>('calledFizz', 'value');\n\nexport class Foo extends SmartContract {\n  public fizz(value: string): boolean {\n    notifyCalledFizz(value);\n\n    return true;\n  }\n}\n```\n\nWe can invoke the contract in another contract `Bar` in `Bar.ts` like so:\n\n```typescript\nimport { LinkedSmartContract, SmartContract } from '@neo-one/smart-contract';\nimport { Foo } from './Foo';\n\nexport class Bar extends SmartContract {\n  public bang(value: string): boolean {\n    const contract = LinkedSmartContract.for<Foo>();\n\n    return contract.fizz(value);\n  }\n}\n```\n\nSimple, right? All we have to do is import the contract `Foo` from the `Bar` file and use the special static method `for` on `LinkedSmartContract` to get a reference to the deployed `Foo` contract which we can then call. The events of the linked smart contract also get automatically merged into the events of the calling smart contract, e.g. in this case, `'calledFizz'` will automatically be an event in the generated NEO•ONE client APIs for `Bar`. And with that, we can start implementing!\n\n## Instructions\n\nWe need to make two changes in this chapter. First, we need to modify the Token contract to use the `approvedTransfers` property along with the `Blockchain.currentCallerContract` contract to allow transfers. Second, we need to modify the Escrow contract to transfer the tokens from the `from` address to the Escrow contract address, which can be accessed with `this.address`.\n\nLet's break it down:\n\n  1. Add a check for an existing `approvedTransfer` by the `Blockchain.currentCallerContract` in the `transfer` method of the `Token` contract.\n  2. If there is an existing approved transfer, and that approval amount is greater than or equal to the desired amount, allow the transfer to proceed and reduce the approved amount by the transfer amount.\n  2. Create an instance of the `Token` contract in the `Escrow` contract using `LinkedSmartContract.for` in `depsoit`.\n  3. Invoke the `transfer` method of that instance with the `from` `Address` of the `deposit` call as the `from` parameter, `this.address` as the `to` parameter and the `amount` of the `deposit` call as the `amount` parameter.\n  4. If the result of the `transfer` is true, proceed with the remainder of the `deposit` logic. Otherwise, `return` `false`.\n\n## Test\n\nThe tests for this chapter verify both the `Token` contract and the `Escrow` contract by running through the following scenario:\n\n  1. Fast forward and mint tokens.\n  2. Pre-approve a transfer of tokens to another address.\n  3. Call deposit for the tokens pre-approved in 2/\n\nWe also verify that it returns `false` if the transfer is not pre-approved.\n\n## Wrap Up\n\nIn this chapter we used the `Blockchain.currentCallerContract` property we learned about earlier, as well as, learned how to call one smart contract from another. In the next chapter we'll flesh out the remainder of the Escrow contract.\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"import { Address, constant, createEventNotifier, Fixed, MapStorage, SmartContract } from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.setBalance(from, to, this.balanceOf(from, to) + amount);\n    notifyBalanceAvailable(from, to, amount);\n\n    return true;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('can deposit funds', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const additionalAmount = new BigNumber(50);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount.plus(additionalAmount),\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Deposit into the Escrow account\n      const escrowReceipt = await escrow.deposit.confirmed(masterAccountID.address, toAccountID.address, escrowAmount);\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Try depositing more than is pre-approved\n      const failedDepositReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        additionalAmount.plus(1),\n      );\n      if (failedDepositReceipt.result.state === 'FAULT') {\n        throw new Error(failedDepositReceipt.result.message);\n      }\n      expect(failedDepositReceipt.result.value).toEqual(false);\n\n      // Verify the balance is still the same since the deposit failed.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Escrow Claim",documentation:"# Chapter 4: Escrow Claim\n\nIn this chapter we'll add a method for the destination address to claim EON from the account. We don't need to learn anything new to implement this method, so let's jump right into it.\n\n## Instructions\n\n  1. Add a method `claim` which takes a `from` `Address`, `to` `Address`, and `amount` `Fixed<8>`\n  2. Throw an error if `amount` is less than 0.\n  3. Verify that the caller is the `to` `Address`.\n  4. Verify that the escrow account has enough funds to claim.\n  5. Create an instance of `Token` using `LinkedSmartContract.for`.\n  6. Invoke `transfer` with `this.address` as the `from` parameter, the `to` argument to `claim` as the `to` parameter of `transfer`, and the `amount` argument to `claim` as the `amount` parameter of `transfer`.\n  7. If successful (`transfer` returns `true`), reduce the escrow balance and emit a `'balanceClaimed'` event with the `from`, `to` and `amount` arguments.\n\n## Test\n\nSimilar to last chapter, the tests verify that the `claim` method properly transfers tokens, deducts from the escrow balance, and emits an event on a successful `claim`. We also verify that an unsuccessful claim results in no changes and that an invalid amount throws an error.\n\n## Wrap Up\n\nIn this chapter we used the knowledge we've gained to implement the `claim` method. Next chapter we'll enable refunds, which works very similarly to the `claim` method.\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>>('balanceClaimed', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceClaimed(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('holds funds claimable by two parties', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const additionalAmount = new BigNumber(50);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount.plus(additionalAmount),\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Deposit into the Escrow account\n      const escrowReceipt = await escrow.deposit.confirmed(masterAccountID.address, toAccountID.address, escrowAmount);\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Try depositing more than is pre-approved\n      const failedDepositReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        additionalAmount.plus(1),\n      );\n      if (failedDepositReceipt.result.state === 'FAULT') {\n        throw new Error(failedDepositReceipt.result.message);\n      }\n      expect(failedDepositReceipt.result.value).toEqual(false);\n\n      // Verify the balance is still the same since the deposit failed.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Claim half of the escrow balance\n      const claimAmount = escrowAmount.dividedBy(2);\n      const claimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount,\n        // Set the from address as the toAccountID since only the `to` address should be able to claim from the Escrow account.\n        { from: toAccountID },\n      );\n      if (claimReceipt.result.state === 'FAULT') {\n        throw new Error(claimReceipt.result.message);\n      }\n      expect(claimReceipt.result.value).toEqual(true);\n      // Notice how the receipt has the events for both the Token contract we invoked as well as the Escrow contract.\n      event = claimReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      event = claimReceipt.events[1];\n      expect(event.name).toEqual('balanceClaimed');\n      if (event.name !== 'balanceClaimed') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n\n      // Verify the escrow balance has been deducted\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Try claiming the remainder + 1 (i.e. more than the balance of the escrow account)\n      const failedClaimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount.plus(1),\n        { from: toAccountID },\n      );\n      if (failedClaimReceipt.result.state === 'FAULT') {\n        throw new Error(failedClaimReceipt.result.message);\n      }\n      expect(failedClaimReceipt.result.value).toEqual(false);\n\n      // Verify the escrow balance is still the same.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Verify that claim throws an error in the exceptional case that we pass a negative number\n      let error: Error | undefined;\n      try {\n        await escrow.claim.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), {\n          from: toAccountID,\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Escrow Refund",documentation:"# Chapter 5: Escrow Refund\n\nIn this chapter we'll add a method for the source address to reclaim EON from the account. Like last chapter, we don't need to learn anything new to implement this method. You may be wondering if there is more to learn - yes, yes there is! We'll learn about new concepts in the next chapter.\n\n## Instructions\n\n  1. Add a method `refund` which takes a `from` `Address`, `to` `Address`, and `amount` `Fixed<8>`\n  2. Throw an error if `amount` is less than 0.\n  3. Verify that the caller is the `from` `Address`.\n  4. Verify that the escrow account has enough funds to claim.\n  5. Create an instance of `Token` using `LinkedSmartContract.for`.\n  6. Invoke `transfer` with `this.address` as the `from` parameter, the `from` argument to `claim` as the `to` parameter of `transfer`, and the `amount` argument to `claim` as the `amount` parameter of `transfer`.\n  7. If successful (`transfer` returns `true`), reduce the escrow balance and emit a `'balanceRefunded'` event with the `from`, `to` and `amount` arguments.\n\n## Test\n\nSimilar to last chapter, the tests verify that the `refund` method properly transfers tokens, deducts from the escrow balance, and emits an event on a successful `refund`. We also verify that an unsuccessful `refund` results in no changes and that an invalid `amount` throws an error.\n\n## Wrap Up\n\nNow we have a fully functioning Escrow contract! On the other side of `Next` we'll see how to generalize the Escrow contract to work for any NEP-5 token.\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>>('balanceClaimed', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceClaimed(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>>('balanceClaimed', 'from', 'to', 'amount');\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceClaimed(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceRefunded(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('holds funds claimable by two parties', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const additionalAmount = new BigNumber(50);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount.plus(additionalAmount),\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Depost into the Escrow account\n      const escrowReceipt = await escrow.deposit.confirmed(masterAccountID.address, toAccountID.address, escrowAmount);\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Try depositing more than is pre-approved\n      const failedDepositReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        additionalAmount.plus(1),\n      );\n      if (failedDepositReceipt.result.state === 'FAULT') {\n        throw new Error(failedDepositReceipt.result.message);\n      }\n      expect(failedDepositReceipt.result.value).toEqual(false);\n\n      // Verify the balance is still the same since the deposit failed.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Claim half of the escrow balance\n      const claimAmount = escrowAmount.dividedBy(2);\n      const claimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount,\n        // Set the from address as the toAccountID since only the `to` address should be able to claim from the Escrow account.\n        { from: toAccountID },\n      );\n      if (claimReceipt.result.state === 'FAULT') {\n        throw new Error(claimReceipt.result.message);\n      }\n      expect(claimReceipt.result.value).toEqual(true);\n      // Notice how the receipt has the events for both the Token contract we invoked as well as the Escrow contract.\n      event = claimReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      event = claimReceipt.events[1];\n      expect(event.name).toEqual('balanceClaimed');\n      if (event.name !== 'balanceClaimed') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n\n      // Verify the escrow balance has been deducted\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Try claiming the remainder + 1 (i.e. more than the balance of the escrow account)\n      const failedClaimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount.plus(1),\n        { from: toAccountID },\n      );\n      if (failedClaimReceipt.result.state === 'FAULT') {\n        throw new Error(failedClaimReceipt.result.message);\n      }\n      expect(failedClaimReceipt.result.value).toEqual(false);\n\n      // Verify the escrow balance is still the same.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Refund the remainder of the escrow account\n      const refundAmount = escrowAmount.minus(claimAmount);\n      const refundReceipt = await escrow.refund.confirmed(masterAccountID.address, toAccountID.address, refundAmount);\n      if (refundReceipt.result.state === 'FAULT') {\n        throw new Error(refundReceipt.result.message);\n      }\n      expect(refundReceipt.result.value).toEqual(true);\n      event = refundReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n      event = refundReceipt.events[1];\n      expect(event.name).toEqual('balanceRefunded');\n      if (event.name !== 'balanceRefunded') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n\n      // Verify the escrow balance is now 0\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address);\n      expect(balance.toNumber()).toEqual(0);\n\n      // Try to refund more (and fail)\n      const failedRefundReceipt = await escrow.refund.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        new BigNumber(1),\n      );\n      if (failedRefundReceipt.result.state === 'FAULT') {\n        throw new Error(failedRefundReceipt.result.message);\n      }\n      expect(failedRefundReceipt.result.value).toEqual(false);\n\n      // Verify that claim throws an error in the exceptional case that we pass a negative number\n      let error: Error | undefined;\n      try {\n        await escrow.claim.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), {\n          from: toAccountID,\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify that refund throws an error in the exceptional case that we pass a negative number\n      error = undefined;\n      try {\n        await escrow.refund.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1));\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Support Every NEP-5 Token",documentation:"# Chapter 6: Support Every NEP-5 Token\n\nWe now have a fully functioning Escrow contract for Eon tokens. But what if we want to have an escrow account for another NEP-5 token? In it's current form, we'd need to deploy a new contract that points to the other token. Instead of deploying an escrow contract for every token, let's generalize the contract to support any NEP-5 token.\n\n## Learn\n\nIn order to generalize the contract we'll need to be able to invoke the `transfer` method of an arbitrary contract. Let's take a look at an example of how that can be done:\n\n```typescript\nimport { Address, Fixed, declareEvent, SmartContract } from '@neo-one/smart-contract';\n\ninterface ExampleToken {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => boolean;\n}\ndeclareEvent<Address | undefined, Address | undefined, Fixed<8>>('transfer', 'from', 'to', 'amount');\n\nexport class Example extends SmartContract {\n  public invokeTransfer(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    const token = SmartContract.for<ExampleToken>(asset);\n\n    return token.transfer(from, to, amount);\n  }\n}\n```\n\nIn this example we're forwarding the transfer call to the contract at the given `tokenAddress`. Compared to before, we replaced the `LinkedSmartContract.for<Token>()` call that referenced our own `Token` contract with a `SmartContract.for<ExampleToken>(tokenAddress)` call that references a contract that has the interface `ExampleToken` at `tokenAddress`. Besides that, the return value is identical - we can call any contract method defined by the `ExampleToken` interface, which in this case just contains the `transfer` method.\n\nWe can also declare the events that we expect our smart contract to emit due to calling other smart contracts. Before when we used `LinkedSmartContract.for<Token>()`, the `Token` contract's events were automatically pulled in as possible events for the `Escrow` contract to emit. We can use `declareEvent` with the same type parameters and parameter names as we did for the `'transfer'` in order to have the same effect when using `SmartContract.for<ExampleToken>(tokenAddress)` - that is, now the generated NEO•ONE client APIs will include the `'transfer'` event in transaction receipts.\n\n## Instructions\n\nRather than go step by step through every change, we'll make this a bit more challenging than previous chapters and give a high level description of what needs to be done.\n\n  1. Remove the `Token` import and construct an interface called `Token` with a `transfer` method just like the example above. Use `declareEvent` to declare the `'transfer'` event that we expect the tokens we invoke to emit.\n  2. Make the `balances` have keys that are a triplet of `Address` corresponding to `[from, to, asset]`.\n  3. Modify each of the methods in the `Escrow` contract to take an additional `asset` `Address` parameter. Use this parameter throughout. - create the contract using `SmartContract.for<Token>(asset)`, add it to the emitted events, etc.\n\n## Test\n\nThe tests for this chapter are identical to the previous one with the exception that we additionally pass the Eon `Token` contract address as the final parameter to each method. We also expect that each of the events contain an `asset` parameter equal to the `Token` address.\n\n## Wrap Up\n\nThis chapter generalized the `Escrow` contract to work with any NEP-5 token. But what if we want to have an escrow account with NEO or GAS? In the next chapter we'll look at how we can make NEO conform to the NEP-5 standard so that we can use it in the `Escrow` contract.\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  Fixed,\n  LinkedSmartContract,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\nimport { Token } from './Token.one';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>>('balanceClaimed', 'from', 'to', 'amount');\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n);\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address): Fixed<8> {\n    const balance = this.balances.get([from, to]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to) + amount);\n      notifyBalanceAvailable(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceClaimed(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = LinkedSmartContract.for<Token>();\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount);\n      notifyBalanceRefunded(from, to, amount);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>): void {\n    this.balances.set([from, to], amount);\n  }\n}\n",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  declareEvent,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceClaimed',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\n\ninterface Token {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => boolean;\n}\ndeclareEvent<Address | undefined, Address | undefined, Fixed<8>>('transfer', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address, asset: Address): Fixed<8> {\n    const balance = this.balances.get([from, to, asset]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to, asset) + amount, asset);\n      notifyBalanceAvailable(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceClaimed(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceRefunded(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>, asset: Address): void {\n    this.balances.set([from, to, asset], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('holds funds claimable by two parties', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const additionalAmount = new BigNumber(50);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await token.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount.plus(additionalAmount),\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Depost into the Escrow account\n      const tokenAddress = token.definition.networks[networkName].address;\n      const escrowReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        escrowAmount,\n        tokenAddress,\n      );\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      expect(event.parameters.asset).toEqual(tokenAddress);\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Try depositing more than is pre-approved\n      const failedDepositReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        additionalAmount.plus(1),\n        tokenAddress,\n      );\n      if (failedDepositReceipt.result.state === 'FAULT') {\n        throw new Error(failedDepositReceipt.result.message);\n      }\n      expect(failedDepositReceipt.result.value).toEqual(false);\n\n      // Verify the balance is still the same since the deposit failed.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Claim half of the escrow balance\n      const claimAmount = escrowAmount.dividedBy(2);\n      const claimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount,\n        tokenAddress,\n        // Set the from address as the toAccountID since only the `to` address should be able to claim from the Escrow account.\n        { from: toAccountID },\n      );\n      if (claimReceipt.result.state === 'FAULT') {\n        throw new Error(claimReceipt.result.message);\n      }\n      expect(claimReceipt.result.value).toEqual(true);\n      // Notice how the receipt has the events for both the Token contract we invoked as well as the Escrow contract.\n      event = claimReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      event = claimReceipt.events[1];\n      expect(event.name).toEqual('balanceClaimed');\n      if (event.name !== 'balanceClaimed') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      expect(event.parameters.asset).toEqual(tokenAddress);\n\n      // Verify the escrow balance has been deducted\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Try claiming the remainder + 1 (i.e. more than the balance of the escrow account)\n      const failedClaimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount.plus(1),\n        tokenAddress,\n        { from: toAccountID },\n      );\n      if (failedClaimReceipt.result.state === 'FAULT') {\n        throw new Error(failedClaimReceipt.result.message);\n      }\n      expect(failedClaimReceipt.result.value).toEqual(false);\n\n      // Verify the escrow balance is still the same.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Refund the remainder of the escrow account\n      const refundAmount = escrowAmount.minus(claimAmount);\n      const refundReceipt = await escrow.refund.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        refundAmount,\n        tokenAddress,\n      );\n      if (refundReceipt.result.state === 'FAULT') {\n        throw new Error(refundReceipt.result.message);\n      }\n      expect(refundReceipt.result.value).toEqual(true);\n      event = refundReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n      event = refundReceipt.events[1];\n      expect(event.name).toEqual('balanceRefunded');\n      if (event.name !== 'balanceRefunded') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n      expect(event.parameters.asset).toEqual(tokenAddress);\n\n      // Verify the escrow balance is now 0\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(0);\n\n      // Try to refund more (and fail)\n      const failedRefundReceipt = await escrow.refund.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        new BigNumber(1),\n        tokenAddress,\n      );\n      if (failedRefundReceipt.result.state === 'FAULT') {\n        throw new Error(failedRefundReceipt.result.message);\n      }\n      expect(failedRefundReceipt.result.value).toEqual(false);\n\n      // Verify that claim throws an error in the exceptional case that we pass a negative number\n      let error: Error | undefined;\n      try {\n        await escrow.claim.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), tokenAddress, {\n          from: toAccountID,\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify that refund throws an error in the exceptional case that we pass a negative number\n      error = undefined;\n      try {\n        await escrow.refund.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), tokenAddress);\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Contract NEO",documentation:"# Chapter 7: Contract NEO\n\nIn the last chapter we extended the `Escrow` contract with support for all NEP-5 tokens. In this chapter we'll look at how we can make native assets like `NEO` and `GAS` conform to the NEP-5 standard so that they may be used in contracts that expect NEP-5 tokens like `Escrow`. We can make `NEO` work like a NEP-5 token by constructing a contract that accepts `NEO` and converts it 1:1 for `CNEO`. It should also accept `CNEO` and convert it 1:1 for `NEO`. The mechanism for converting `NEO` to `CNEO` is the same as minting tokens for an ICO, so in this chapter we'll focus on how we convert `CNEO` back into `NEO`. We'll also talk about how to claim the accrued `GAS` in a smart contract that has been sent `NEO`.\n\nNote that `CNEO` and `CGAS` are already deployed to the mainnet, so if you are developing a contract that wants to use `NEO` or `GAS`, it may be prudent to use `CNEO` and `CGAS` instead as they're generally easier to work with from smart contracts.\n\n## Learn\n\nRecall from Lesson 2 that we used the `@sendUnsafe` decorator in order to withdraw ICO contributions. To recap that chapter, `@sendUnsafe` is an unsafe way of enabling native assets to be sent from the contract, as it potentially allows the equivalent of double spends - that is, a user can construct a series of parallel transactions that enable them to withdraw more than they should be allowed to. NEO•ONE supports another decorator `@send` which eliminates the attack vector by requiring two transactions to withdraw from the contract. At a high level, every send happens in two phases:\n\n  1. The user \"marks\" the assets they wish to withdraw from the contract by constructing a transaction that sends those assets back to the smart contract.\n  2. The user constructs a transaction that withdraws the previously \"mark\"ed assets to the desired address.\n\nWith NEO•ONE, this process is implemented transparently both in terms of the implementation in the smart contract as well as invoking the methods in the NEO•ONE client APIs. Simply decorate a method with the `@send` decorator as before and throw an error if the transaction should not proceed. The method may optionally accept one argument in addition to any user defined arguments; a `Transfer` object. The `Transfer` object contains a `to` `Address` property that the assets will be sent to, an `asset` `Hash256` property corresponding to the asset to be sent, and an `amount` `Fixed<8>` property that will be sent. Typically your method will want to accept the `Transfer` argument in order to validate the transaction. Let's take a look at an example.\n\n```typescript\nimport { send, SmartContract, Transfer } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @send\n  public withdraw(value: string, transfer: Transfer): void {\n    // Check internal state against the provided arguments and throw an error if the transfer should not proceed.\n  }\n}\n```\n\nSimple right? In this example we're declaring a method `withdraw` that can be used to send assets from the contract. It accepts one parameter, a `string` called `value`. It additionally expects the optional `Transfer` argument. To make this a bit more concrete, let's take a look at how one can send assets from a contract using a method decorated with `@send`.\n\n```typescript\nimport { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\n\nconst sendPhaseOneReceipt = await example.withdraw.confirmed('value', {\n  asset: Hash256.NEO,\n  amount: new BigNumber(10),\n  to: 'APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR',\n});\nconst sendPhaseTwoReceipt = await example.completeSend.confirmed(sendPhaseOneReceipt.transaction.hash);\n```\n\nNotice how invoking a method marked with `@send` is identical to invoking a normal method - we simply provide the arguments expected by the contract method. Do note that the final argument, the `Transfer` object is mandatory, regardless of whether or not the contract expects it as the final argument, because it is used to construct the transaction that marks the native assets for withdrawal. Once the first transaction is confirmed, we call `completeSend` with the transaction hash of the first transaction to finalize the withdrawal. Notice that `completeSend` is generated automatically by the NEO•ONE client APIs and may be used as the second step for any method marked with `@send`.\n\nBefore we move on to using the `@send` decorator in a smart contract, let's quickly cover how we can claim the accumulated `GAS` of a smart contract that has had `NEO` sent to it. We can decorate a method with `@claim` to allow `GAS` to be claimed when invoking that method. With that said, there are things that make `@claim` methods different:\n\n  1. `@claim` methods may not modify contract storage. They act like `@constant` methods.\n  2. `@claim` methods may not access `Blockchain.currentTransaction`, instead they may optionally accept the `ClaimTransaction` that the method was invoked in as the final argument.\n\nLet's take a look at an example:\n\n```typescript\nimport { ClaimTransaction, claim, SmartContract } from '@neo-one/smart-contract';\n\nexport class Example extends SmartContract {\n  @claim\n  public claimGAS(transaction: ClaimTransaction): void {\n    // Check internal state against the ClaimTransaction and throw an error if the claim should not proceed.\n  }\n}\n```\n\nJust like the other method decorators, we throw an error to indicate if the claim should not proceed. Methods marked with `@claim` are invoked just like a normal method, so we'll skip showing another example and let you dive into trying out these 2 decorators.\n\n## Instructions\n\nWe've started you off with a partial NEP-5 implementation of `CNEO`, it's up to you to implement the methods marked with `@send` and `@claim`.\n\nThe `unwrap` method should do the following:\n\n  1. Throw an error if the `asset` transferred is not `NEO`.\n  2. Throw an error if the balance of the `to` address of the `Transfer` is less than the `amount` of the `Transfer`\n  3. Deduct `amount` from the balance of the `to` address.\n  4. Deduct `amount` from the `mutableSupply` of the contract.\n  5. Emit a transfer notification with `undefined` set as the `to` address (which represents burning the token)\n\nSince there's not currently an efficient way to allow users to claim `GAS` for their `CNEO`, we'll make the `claim` method do the following:\n\n  1. Throw an error if `!Address.isCaller(this.owner)`.\n\nThen at least the owner of `CNEO` can claim and distribute `GAS`.\n\n## Test\n\nThe tests for this chapter verify that `CNEO` can be unwrapped and GAS can be claimed. They're worth checking out to see how the smart contract methods are invoked in action. They also test the NEP-5 functionality by using `CNEO` with the `Escrow` contract.\n\n## Wrap Up\n\nThis chapter introduced the `@send` and `@claim` decorators and used them to implement `CNEO`, a NEP-5 compatible wrapper around `NEO`. At this point, we have 3 fully functioning smart contracts, but you may have noticed that the interaction between them is a bit cumbersome. Currently we require two transactions, a pre-approval transaction followed by the actual action. In the next chapter we'll look at how we can modify the NEP-5 contract to support both the transfer (without pre-approval) and the action in a single safe transaction.\n",files:[{path:"one/contracts/CNEO.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  claim,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  send,\n  SmartContract,\n  Transfer,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class CNEO extends SmartContract {\n  public readonly name = 'CNEO';\n  public readonly symbol = 'CNEO';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @receive\n  public wrap(): void {\n    const transaction = Blockchain.currentTransaction;\n    const { references } = transaction;\n    if (references.length === 0) {\n      // Nothing to refund\n      throw new Error('Invalid wrap');\n    }\n\n    // We're only going to credit one address, so just pick the first one from the references.\n    const sender = references[0].address;\n    // We loop over the entire reference list, so users will want to consolidate prior to invoking.\n    if (references.some((reference) => reference.asset.equals(Hash256.NEO) && !reference.address.equals(sender))) {\n      throw new Error('Invalid wrap');\n    }\n\n    let amount = 0;\n    for (const output of transaction.outputs) {\n      if (output.address.equals(this.address)) {\n        // Don't allow transactions that send anything but NEO to the contract.\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid wrap');\n        }\n\n        amount += output.value;\n      }\n    }\n\n    if (amount === 0) {\n      throw new Error('Invalid wrap');\n    }\n\n    this.balances.set(sender, this.balanceOf(sender) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, sender, amount);\n  }\n\n  @send\n  public unwrap(transfer: Transfer): void {\n    // Implement me\n  }\n\n  @claim\n  public claim(): void {\n    // Implement me\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  claim,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  send,\n  SmartContract,\n  Transfer,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class CNEO extends SmartContract {\n  public readonly name = 'CNEO';\n  public readonly symbol = 'CNEO';\n  public readonly decimals = 8;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(public readonly owner: Address = Deploy.senderAddress) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @receive\n  public wrap(): void {\n    const transaction = Blockchain.currentTransaction;\n    const { references } = transaction;\n    if (references.length === 0) {\n      // Nothing to refund\n      throw new Error('Invalid wrap');\n    }\n\n    // We're only going to credit one address, so just pick the first one from the references.\n    const sender = references[0].address;\n    // We loop over the entire reference list, so users will want to consolidate prior to invoking.\n    if (references.some((reference) => reference.asset.equals(Hash256.NEO) && !reference.address.equals(sender))) {\n      throw new Error('Invalid wrap');\n    }\n\n    let amount = 0;\n    for (const output of transaction.outputs) {\n      if (output.address.equals(this.address)) {\n        // Don't allow transactions that send anything but NEO to the contract.\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid wrap');\n        }\n\n        amount += output.value;\n      }\n    }\n\n    if (amount === 0) {\n      throw new Error('Invalid wrap');\n    }\n\n    this.balances.set(sender, this.balanceOf(sender) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, sender, amount);\n  }\n\n  @send\n  public unwrap(transfer: Transfer): void {\n    if (!transfer.asset.equals(Hash256.NEO)) {\n      throw new Error('Invalid unwrap');\n    }\n\n    const balance = this.balanceOf(transfer.to);\n    if (balance < transfer.amount) {\n      throw new Error('Invalid unwrap');\n    }\n\n    this.balances.set(transfer.to, balance - transfer.amount);\n    this.mutableSupply -= transfer.amount;\n    notifyTransfer(transfer.to, undefined, transfer.amount);\n  }\n\n  @claim\n  public claim(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid claim');\n    }\n  }\n}\n"},{path:"one/contracts/Escrow.one.ts",solution:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  declareEvent,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceClaimed',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\n\ninterface Token {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => boolean;\n}\ndeclareEvent<Address | undefined, Address | undefined, Fixed<8>>('transfer', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address, asset: Address): Fixed<8> {\n    const balance = this.balances.get([from, to, asset]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to, asset) + amount, asset);\n      notifyBalanceAvailable(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceClaimed(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceRefunded(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>, asset: Address): void {\n    this.balances.set([from, to, asset], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/CNEO.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('CNEO', () => {\n  test('can wrap and unwrap NEO and be used as a NEP-5 token', async () => {\n    await withContracts(async ({ cneo, escrow, client, masterAccountID, networkName, accountIDs }) => {\n      expect(cneo).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Wrap NEO so we have some available to use in the Escrow\n      const neoAmount = new BigNumber(1000);\n      const wrapReceipt = await cneo.wrap.confirmed({\n        sendTo: [\n          {\n            amount: neoAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (wrapReceipt.result.state === 'FAULT') {\n        throw new Error(wrapReceipt.result.message);\n      }\n      expect(wrapReceipt.result.value).toBeUndefined();\n\n      // Pre-approve the transfer by the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const additionalAmount = new BigNumber(50);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const approveReceipt = await cneo.approveSendTransfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount.plus(additionalAmount),\n      );\n      if (approveReceipt.result.state === 'FAULT') {\n        throw new Error(approveReceipt.result.message);\n      }\n      expect(approveReceipt.result.value).toEqual(true);\n\n      // Depost into the Escrow account\n      const cneoAddress = cneo.definition.networks[networkName].address;\n      const cneoAccountID = { network: networkName, address: cneoAddress };\n      const escrowReceipt = await escrow.deposit.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        escrowAmount,\n        cneoAddress,\n      );\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      expect(event.parameters.asset).toEqual(cneoAddress);\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, cneoAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Claim half of the escrow balance\n      const claimAmount = escrowAmount.dividedBy(2);\n      const claimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount,\n        cneoAddress,\n        // Set the from address as the toAccountID since only the `to` address should be able to claim from the Escrow account.\n        { from: toAccountID },\n      );\n      if (claimReceipt.result.state === 'FAULT') {\n        throw new Error(claimReceipt.result.message);\n      }\n      expect(claimReceipt.result.value).toEqual(true);\n      // Notice how the receipt has the events for both the CNEO contract we invoked as well as the Escrow contract.\n      event = claimReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      event = claimReceipt.events[1];\n      expect(event.name).toEqual('balanceClaimed');\n      if (event.name !== 'balanceClaimed') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      expect(event.parameters.asset).toEqual(cneoAddress);\n\n      // Verify the escrow balance has been deducted\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, cneoAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Unwrap the claimed CNEO\n      const unwrapReceipt = await cneo.unwrap.confirmed(\n        {\n          amount: claimAmount,\n          asset: Hash256.NEO,\n          to: toAccountID.address,\n        },\n        { from: toAccountID },\n      );\n      if (unwrapReceipt.result.state === 'FAULT') {\n        throw new Error(unwrapReceipt.result.message);\n      }\n      expect(unwrapReceipt.result.value).toBeUndefined();\n      const unwrapEvent = unwrapReceipt.events[0];\n      expect(unwrapEvent.name).toEqual('transfer');\n      if (unwrapEvent.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(unwrapEvent.parameters.from).toEqual(toAccountID.address);\n      expect(unwrapEvent.parameters.to).toBeUndefined();\n      expect(unwrapEvent.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n\n      // Complete the send\n      const completeReceipt = await cneo.completeSend.confirmed(unwrapReceipt.transaction.hash, {\n        from: toAccountID,\n      });\n      if (completeReceipt.result.state === 'FAULT') {\n        throw new Error(completeReceipt.result.message);\n      }\n      expect(completeReceipt.result.value).toBeUndefined();\n\n      // Verify the balance and total supply have been deducted and that the toAccount has the NEO\n      const [masterBalance, toBalance, totalSupply, toAccount, cneoAccountBefore] = await Promise.all([\n        cneo.balanceOf(masterAccountID.address),\n        cneo.balanceOf(toAccountID.address),\n        cneo.totalSupply(),\n        client.getAccount(toAccountID),\n        client.getAccount(cneoAccountID),\n      ]);\n      expect(masterBalance.toNumber()).toEqual(neoAmount.minus(escrowAmount).toNumber());\n      expect(toBalance.toNumber()).toEqual(0);\n      expect(totalSupply.toNumber()).toEqual(neoAmount.minus(claimAmount).toNumber());\n      expect(toAccount.balances[Hash256.NEO].toNumber()).toEqual(claimAmount.toNumber());\n\n      // Claim the accumulated GAS\n      await cneo.claim.confirmed();\n      const cneoAccountAfter = await client.getAccount(cneoAccountID);\n      expect(cneoAccountBefore.balances[Hash256.GAS]).toBeUndefined();\n      expect(cneoAccountAfter.balances[Hash256.GAS]).toBeDefined();\n      expect(cneoAccountAfter.balances[Hash256.GAS].toNumber()).toBeGreaterThan(0);\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]},{title:"Forward Arguments",documentation:"# Chapter 8: Forward Arguments\n\nWe've learned in previous chapters that one technique for safe interaction between smart contracts is to pre-approve actions that the other contract may take on behalf of a user account. In this chapter, we'll learn how we can enable safe interactions through inversion of control - that is, we'll allow other contracts a chance to react to an action taken.\n\nThis chapter will be quite dense as we dive into a rather advanced, but powerful, concept, so be prepared!\n\n## Learn\n\nWe'll structure the inversion of control through convention, that is, whenever we take an action `foo` who's target is a smart contract, we'll invoke `approveReceiveFoo` on that contract. This enables a key interaction between smart contracts - the target contracts not only react to the action, but they can disallow it entirely. Let's take a look at an example.\n\n```typescript\nimport { Address, ForwardValue, SmartContract } from '@neo-one/smart-contract';\n\ninterface ActionContract {\n  readonly approveReceiveTakeAction: (\n    value: string,\n    ...args: ForwardValue[]\n  ) => boolean;\n}\n\nexport class Example extends SmartContract {\n  public takeAction(value: string, on: Address, ...approveArgs: ForwardValue[]): boolean {\n    const contract = Contract.for(on);\n    if (contract !== undefined && !Address.isCaller(on)) {\n      const smartContract = SmartContract.for<ActionContract>(on);\n      if (!smartContract.approveReceiveTakeAction(value, ...approveArgs)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n```\n\nLet's break this down piece by piece. We have a method called `takeAction` which expects two arguments, a `string` called `value` and the target of the action, an `Address` call `on`. We also have a [rest parameter](https://www.typescriptlang.org/docs/handbook/functions.html#rest-parameters) with a new type, `ForwardValue`. A `ForwardValue` is an opaque type that could be anything and is intended not to be used by the current method, but instead \"forwarded\" to another smart contract method. In a moment we'll show how that works in the client APIs which will make it a bit more clear how these forwarded arguments are used and why they're useful.\n\nInside of the `takeAction` method we check to see if the `on` `Address` is a contract address by attempting to create the contract for `on`, i.e. `Contract.for(on)`. If it exists, then the result will be defined. Then we instantiate the `SmartContract` for `on` and invoke its `approveReceiveTakeAction` method, forwarding any additional arguments we received in our invocation. Notice that we also check that the `on` `Address` is not the current caller, since there would be no point in invoking the contract that called us to see if the current call is approved - by virtue of being called by that contract we can safely assume the call is approved.\n\nLet's look at another example contract that implements the `approveReceiveTakeAction` method.\n\n```typescript\nimport { SmartContract, ForwardedValue } from '@neo-one/smart-contract';\n\nexport class OtherExample extends SmartContract {\n  public approveReceiveTakeAction(value: string, otherValue: ForwardedValue<string>): boolean {\n    // Do something with `value` and `otherValue`, potentially returning `false`.\n\n    return true;\n  }\n}\n```\n\nHere we've again specified the `value` argument from the `takeAction` call that we're approving. We've also specified that we expect a `ForwardedValue` of type `string`. Similar to the `Fixed` type, the `ForwardedValue` type does not have any effect on the execution semantics of the smart contract, rather it effects the generated NEO•ONE client APIs. Before we take a look at the client APIs, let's recap what we've seen so far.\n\n  1. Smart contracts can (and should) specify rest parameters that they will forward to an invocation on another contract to approve the action.\n  2. Smart contracts can specify that they expect forwarded values on methods that they expect to be called by another smart contract.\n\nNow let's put it all together with how one would invoke the `takeAction` method.\n\n```typescript\n// Assume we're working with a known `network`\nconst otherExampleAddress = otherExample.definition.networks[network].address;\nconst receipt = await example.takeAction(\n  'value',\n  otherExampleAddress,\n  ...otherExample.forwardApproveReceiveTakeActionArgs('otherValue')\n);\n```\n\nHere we see the generated NEO•ONE client APIs in action for `ForwardedValue`s. By marking the `otherValue` parameter as a `ForwardedValue`, the `forwardApproveReceiveTakeActionArgs` method is generated. This method is intended to be spread as the rest parameter for the `takeAction` method.\n\nWith `ForwardValue`, `ForwardedValue` and the convention of approving actions taken where the target is a smart contract, we have all the ingredients required to allow safe smart contract interaction in a single transaction. Try implementing it for yourself in the next section to enable the `Escrow` contract to manage balances in a single transaction.\n\n## Instructions\n\nWe'll need to modify both the `Token` contract and the `Escrow` contract to enable single transaction deposits. In the `Token` contract:\n\n  1. Add a rest parameter `approveArgs` with type `ForwardValue[]`.\n  2. Use the same pattern as the first example above to invoke a method called `approveReceiveTransfer` on the `to` `Address` if it's a smart contract (and not the current caller).\n\nIn the `Escrow` contract:\n\n  1. Add a method `approveReceiveTransfer` which has a `from` `Address`, an `amount` `Fixed<8>` and a `to` `ForwardedValue<Address>` parameter.\n  2. If `Blockchain.currentCallerContract` is `undefined`, return `false`\n  3. Increase the escrow balance of `from`, `to` and `Blockchain.currentCallerContract` (as the asset) by `amount`.\n  4. Emit a `'balanceAvailable'` notification.\n  5. Return `true`.\n\n## Test\n\nThe tests for this chapter verify the same end result as previous chapters' `Escrow` contract tests. However, notice that the pre-approve and deposit process has been replaced with a single call to the `Token` contract `transfer` method with forwarded arguments. We've copied the relevant code below:\n\n```typescript\nconst escrowAmount = new BigNumber(100);\nconst escrowAddress = escrow.definition.networks[networkName].address;\nconst transferReceipt = await token.transfer.confirmed(\n  masterAccountID.address,\n  escrowAddress,\n  escrowAmount,\n  ...escrow.forwardApproveReceiveTransferArgs(toAccountID.address),\n);\n```\n\n## Wrap Up\n\nThis chapter introduced the concept of reactive contracts with forwarded values. By making it this far, you've started from scratch, potentially with zero knowledge of smart contracts, implemented not one, but two full smart contracts, built the UI for an ICO and learned the fundamentals of developing dapps on NEO. Congratulations!\n\nWe've reached the end of the course, but your journey into dapp development is just beginning. From here you can start on another course (coming soon!) or get started with [setting up a local development environment](/docs/environment-setup) with NEO•ONE to build your own unique dapp. We've covered the majority of the topics in the [Main Guide](/docs/hello-world) as well as a few from the [Advanced Guide](/docs/native-assets), but you may still find them useful.\n\nIf you enjoyed the course or if you have any feedback at all, let us know! Click the smiley face in the lower right hand side of the editor to Tweet us feedback. We'd love to hear from you! Alternatively, click the `Help` button to find other channels like Discord where you can come tell us what you think.\n\nThanks for taking part in the course, we hope you enjoyed it!\n",files:[{path:"one/contracts/Escrow.one.ts",initial:"import {\n  Address,\n  constant,\n  createEventNotifier,\n  declareEvent,\n  Fixed,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceClaimed',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\n\ninterface Token {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => boolean;\n}\ndeclareEvent<Address | undefined, Address | undefined, Fixed<8>>('transfer', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address, asset: Address): Fixed<8> {\n    const balance = this.balances.get([from, to, asset]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to, asset) + amount, asset);\n      notifyBalanceAvailable(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceClaimed(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceRefunded(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>, asset: Address): void {\n    this.balances.set([from, to, asset], amount);\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  declareEvent,\n  Fixed,\n  ForwardedValue,\n  MapStorage,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyBalanceAvailable = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceAvailable',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceClaimed = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceClaimed',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\nconst notifyBalanceRefunded = createEventNotifier<Address, Address, Fixed<8>, Address>(\n  'balanceRefunded',\n  'from',\n  'to',\n  'amount',\n  'asset',\n);\n\ninterface Token {\n  readonly transfer: (from: Address, to: Address, amount: Fixed<8>) => boolean;\n}\ndeclareEvent<Address | undefined, Address | undefined, Fixed<8>>('transfer', 'from', 'to', 'amount');\n\nexport class Escrow extends SmartContract {\n  private readonly balances = MapStorage.for<[Address, Address, Address], Fixed<8>>();\n\n  @constant\n  public balanceOf(from: Address, to: Address, asset: Address): Fixed<8> {\n    const balance = this.balances.get([from, to, asset]);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public approveReceiveTransfer(from: Address, amount: Fixed<8>, to: ForwardedValue<Address>): boolean {\n    const asset = Blockchain.currentCallerContract;\n    if (asset === undefined) {\n      return false;\n    }\n\n    this.setBalance(from, to, this.balanceOf(from, to, asset) + amount, asset);\n    notifyBalanceAvailable(from, to, amount, asset);\n\n    return true;\n  }\n\n  public deposit(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(from, this.address, amount)) {\n      this.setBalance(from, to, this.balanceOf(from, to, asset) + amount, asset);\n      notifyBalanceAvailable(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public claim(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(to)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, to, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceClaimed(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public refund(from: Address, to: Address, amount: Fixed<8>, asset: Address): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const available = this.balanceOf(from, to, asset);\n    if (available < amount) {\n      return false;\n    }\n\n    const token = SmartContract.for<Token>(asset);\n    if (token.transfer(this.address, from, amount)) {\n      this.setBalance(from, to, available - amount, asset);\n      notifyBalanceRefunded(from, to, amount, asset);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private setBalance(from: Address, to: Address, amount: Fixed<8>, asset: Address): void {\n    this.balances.set([from, to, asset], amount);\n  }\n}\n"},{path:"one/contracts/Token.one.ts",initial:"import {\n  Address,\n  Blockchain,\n  constant,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n",solution:"import {\n  Address,\n  Blockchain,\n  constant,\n  Contract,\n  createEventNotifier,\n  Deploy,\n  Fixed,\n  ForwardValue,\n  Hash256,\n  MapStorage,\n  receive,\n  sendUnsafe,\n  SmartContract,\n} from '@neo-one/smart-contract';\n\nconst notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n  'transfer',\n  'from',\n  'to',\n  'amount',\n);\nconst notifyApproveSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'approveSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\nconst notifyRevokeSendTransfer = createEventNotifier<Address, Address, Fixed<8>>(\n  'revokeSendTransfer',\n  'from',\n  'by',\n  'amount',\n);\n\ninterface TokenPayableContract {\n  readonly approveReceiveTransfer: (\n    from: Address,\n    amount: Fixed<8>,\n    ...args: ForwardValue[]\n  ) => boolean;\n}\n\nexport class Token extends SmartContract {\n  public readonly name = 'Eon';\n  public readonly symbol = 'EON';\n  public readonly decimals = 8;\n  public readonly amountPerNEO = 100_000;\n  private readonly balances = MapStorage.for<Address, Fixed<8>>();\n  private readonly approvedTransfers = MapStorage.for<[Address, Address], Fixed<8>>();\n  private mutableRemaining: Fixed<8> = 10_000_000_000_00000000;\n  private mutableSupply: Fixed<8> = 0;\n\n  public constructor(\n    public readonly owner: Address = Deploy.senderAddress,\n    public readonly icoStartTimeSeconds = Blockchain.currentBlockTime + 60 * 60,\n    public readonly icoDurationSeconds = 86400,\n  ) {\n    super();\n    if (!Address.isCaller(owner)) {\n      throw new Error('Sender was not the owner.');\n    }\n  }\n\n  @constant\n  public get totalSupply(): Fixed<8> {\n    return this.mutableSupply;\n  }\n\n  @constant\n  public balanceOf(address: Address): Fixed<8> {\n    const balance = this.balances.get(address);\n\n    return balance === undefined ? 0 : balance;\n  }\n\n  public transfer(from: Address, to: Address, amount: Fixed<8>, ...approveArgs: ForwardValue[]): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    const by = Blockchain.currentCallerContract;\n    const approvedAmount = this.approvedTransfer(from, by);\n    const reduceApproved = approvedAmount >= amount;\n    if (!reduceApproved && !Address.isCaller(from)) {\n      return false;\n    }\n\n    const contract = Contract.for(to);\n    if (contract !== undefined && !Address.isCaller(to)) {\n      const smartContract = SmartContract.for<TokenPayableContract>(to);\n      if (!smartContract.approveReceiveTransfer(from, amount, ...approveArgs)) {\n        return false;\n      }\n    }\n\n    const fromBalance = this.balanceOf(from);\n    if (fromBalance < amount) {\n      return false;\n    }\n\n    const toBalance = this.balanceOf(to);\n    this.balances.set(from, fromBalance - amount);\n    this.balances.set(to, toBalance + amount);\n    notifyTransfer(from, to, amount);\n\n    if (by !== undefined && reduceApproved) {\n      this.approvedTransfers.set([from, by], approvedAmount - amount);\n    }\n\n    return true;\n  }\n\n  @constant\n  public approvedTransfer(from: Address, by: Address | undefined): Fixed<8> {\n    if (by === undefined) {\n      return 0;\n    }\n\n    const approved = this.approvedTransfers.get([from, by]);\n\n    return approved === undefined ? 0 : approved;\n  }\n\n  public approveSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], this.approvedTransfer(from, by) + amount);\n    notifyApproveSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  public revokeSendTransfer(from: Address, by: Address, amount: Fixed<8>): boolean {\n    if (amount < 0) {\n      throw new Error(`Amount must be greater than 0: ${amount}`);\n    }\n\n    if (!Address.isCaller(from)) {\n      return false;\n    }\n\n    const approved = this.approvedTransfer(from, by);\n    if (approved < amount) {\n      return false;\n    }\n\n    this.approvedTransfers.set([from, by], approved - amount);\n    notifyRevokeSendTransfer(from, by, amount);\n\n    return true;\n  }\n\n  @constant\n  public get remaining(): Fixed<8> {\n    return this.mutableRemaining;\n  }\n\n  @receive\n  public mintTokens(): void {\n    if (!this.hasStarted() || this.hasEnded()) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    const { references, outputs } = Blockchain.currentTransaction;\n    if (references.length === 0) {\n      throw new Error('Invalid mintTokens');\n    }\n    const sender = references[0].address;\n\n    let amount = 0;\n    for (const output of outputs) {\n      if (output.address.equals(this.address)) {\n        if (!output.asset.equals(Hash256.NEO)) {\n          throw new Error('Invalid mintTokens');\n        }\n\n        amount += output.value * this.amountPerNEO;\n      }\n    }\n\n    if (amount > this.remaining) {\n      throw new Error('Invalid mintTokens');\n    }\n\n    this.mutableRemaining -= amount;\n    this.issue(sender, amount);\n  }\n\n  @sendUnsafe\n  public withdraw(): void {\n    if (!Address.isCaller(this.owner)) {\n      throw new Error('Invalid withdraw');\n    }\n  }\n\n  private issue(addr: Address, amount: Fixed<8>): void {\n    this.balances.set(addr, this.balanceOf(addr) + amount);\n    this.mutableSupply += amount;\n    notifyTransfer(undefined, addr, amount);\n  }\n\n  private hasStarted(): boolean {\n    return Blockchain.currentBlockTime >= this.icoStartTimeSeconds;\n  }\n\n  private hasEnded(): boolean {\n    return Blockchain.currentBlockTime > this.icoStartTimeSeconds + this.icoDurationSeconds;\n  }\n}\n"},{path:"one/tests/Escrow.test.ts",solution:"import { Hash256 } from '@neo-one/client';\nimport BigNumber from 'bignumber.js';\nimport { withContracts } from '../generated/test';\n\njest.setTimeout(60000);\n\ndescribe('Escrow', () => {\n  test('holds funds claimable by two parties', async () => {\n    await withContracts(async ({ token, escrow, developerClient, masterAccountID, networkName, accountIDs }) => {\n      expect(token).toBeDefined();\n      expect(escrow).toBeDefined();\n\n      // `accountIDs` contains accounts with NEO and GAS and they are preconfigured in the `client`\n      const toAccountID = accountIDs[0];\n\n      // Fast forward to the start of the ICO so that we can mint some tokens.\n      await developerClient.fastForwardOffset(60 * 60);\n      // Mint tokens so we have some available to use in the Escrow\n      const mintNEOAmount = new BigNumber(10);\n      const mintReceipt = await token.mintTokens.confirmed({\n        sendTo: [\n          {\n            amount: mintNEOAmount,\n            asset: Hash256.NEO,\n          },\n        ],\n      });\n      if (mintReceipt.result.state === 'FAULT') {\n        throw new Error(mintReceipt.result.message);\n      }\n      expect(mintReceipt.result.value).toBeUndefined();\n\n      // Deposit into the Escrow account\n      const escrowAmount = new BigNumber(100);\n      const escrowAddress = escrow.definition.networks[networkName].address;\n      const escrowReceipt = await token.transfer.confirmed(\n        masterAccountID.address,\n        escrowAddress,\n        escrowAmount,\n        ...escrow.forwardApproveReceiveTransferArgs(toAccountID.address),\n      );\n      if (escrowReceipt.result.state === 'FAULT') {\n        throw new Error(escrowReceipt.result.message);\n      }\n      expect(escrowReceipt.result.value).toEqual(true);\n      let event = escrowReceipt.events[0];\n      expect(event.name).toEqual('balanceAvailable');\n      if (event.name !== 'balanceAvailable') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n      const tokenAddress = token.definition.networks[networkName].address;\n      expect(event.parameters.asset).toEqual(tokenAddress);\n      event = escrowReceipt.events[1];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(escrowAddress);\n      expect(event.parameters.amount.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Verify the escrow balance matches the above.\n      let balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.toNumber());\n\n      // Claim half of the escrow balance\n      const claimAmount = escrowAmount.dividedBy(2);\n      const claimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount,\n        tokenAddress,\n        // Set the from address as the toAccountID since only the `to` address should be able to claim from the Escrow account.\n        { from: toAccountID },\n      );\n      if (claimReceipt.result.state === 'FAULT') {\n        throw new Error(claimReceipt.result.message);\n      }\n      expect(claimReceipt.result.value).toEqual(true);\n      // Notice how the receipt has the events for both the Token contract we invoked as well as the Escrow contract.\n      event = claimReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      event = claimReceipt.events[1];\n      expect(event.name).toEqual('balanceClaimed');\n      if (event.name !== 'balanceClaimed') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(claimAmount.toNumber());\n      expect(event.parameters.asset).toEqual(tokenAddress);\n\n      // Verify the escrow balance has been deducted\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Try claiming the remainder + 1 (i.e. more than the balance of the escrow account)\n      const failedClaimReceipt = await escrow.claim.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        claimAmount.plus(1),\n        tokenAddress,\n        { from: toAccountID },\n      );\n      if (failedClaimReceipt.result.state === 'FAULT') {\n        throw new Error(failedClaimReceipt.result.message);\n      }\n      expect(failedClaimReceipt.result.value).toEqual(false);\n\n      // Verify the escrow balance is still the same.\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(escrowAmount.minus(claimAmount).toNumber());\n\n      // Refund the remainder of the escrow account\n      const refundAmount = escrowAmount.minus(claimAmount);\n      const refundReceipt = await escrow.refund.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        refundAmount,\n        tokenAddress,\n      );\n      if (refundReceipt.result.state === 'FAULT') {\n        throw new Error(refundReceipt.result.message);\n      }\n      expect(refundReceipt.result.value).toEqual(true);\n      event = refundReceipt.events[0];\n      expect(event.name).toEqual('transfer');\n      if (event.name !== 'transfer') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(escrowAddress);\n      expect(event.parameters.to).toEqual(masterAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n      event = refundReceipt.events[1];\n      expect(event.name).toEqual('balanceRefunded');\n      if (event.name !== 'balanceRefunded') {\n        throw new Error('For TS');\n      }\n      expect(event.parameters.from).toEqual(masterAccountID.address);\n      expect(event.parameters.to).toEqual(toAccountID.address);\n      expect(event.parameters.amount.toNumber()).toEqual(refundAmount.toNumber());\n      expect(event.parameters.asset).toEqual(tokenAddress);\n\n      // Verify the escrow balance is now 0\n      balance = await escrow.balanceOf(masterAccountID.address, toAccountID.address, tokenAddress);\n      expect(balance.toNumber()).toEqual(0);\n\n      // Try to refund more (and fail)\n      const failedRefundReceipt = await escrow.refund.confirmed(\n        masterAccountID.address,\n        toAccountID.address,\n        new BigNumber(1),\n        tokenAddress,\n      );\n      if (failedRefundReceipt.result.state === 'FAULT') {\n        throw new Error(failedRefundReceipt.result.message);\n      }\n      expect(failedRefundReceipt.result.value).toEqual(false);\n\n      // Verify that claim throws an error in the exceptional case that we pass a negative number\n      let error: Error | undefined;\n      try {\n        await escrow.claim.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), tokenAddress, {\n          from: toAccountID,\n        });\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n\n      // Verify that refund throws an error in the exceptional case that we pass a negative number\n      error = undefined;\n      try {\n        await escrow.refund.confirmed(masterAccountID.address, toAccountID.address, new BigNumber(-1), tokenAddress);\n      } catch (err) {\n        error = err;\n      }\n      expect(error).toBeDefined();\n    });\n  });\n});\n"},{path:"package.json",solution:'{\n  "dependencies": {\n    "bignumber.js": "9.0.0"\n  }\n}\n'}]}]}]}}},1126:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTkzLjYwOXB4IiBoZWlnaHQ9IjE5My42MDlweCIgdmlld0JveD0iMCAwIDE5My42MDkgMTkzLjYwOSIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTkzLjYwOSAxOTMuNjA5Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxyZWN0IGZpbGw9Im5vbmUiIHdpZHRoPSIxOTMuNjA5IiBoZWlnaHQ9IjE5My42MDkiLz4NCjxnPg0KCTxjaXJjbGUgZmlsbD0iIzVCNTA2QiIgY3g9Ijk2LjgwNSIgY3k9Ijk2LjgwNSIgcj0iNzguODE1Ii8+DQoJPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMUE5OUQ2IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0xMzIuNDgxLDE0OS41NTUiLz4NCgk8cGF0aCBmaWxsPSIjNDAzODRDIiBkPSJNMTIzLjM4OCwxNDkuNDA0bDI1LjIyNS01Ljk4NWwtMy44NzMtMS4zNTFjLTIuNjMyLTAuOTE3LTUuNDQ4LTEuMTc2LTguMjAzLTAuNzUzbC0xNC4zNTksMi4yMDUNCgkJbDI0LjE4OC0xMi44NDNsLTUuNDk3LTAuNjQzYy0xLjgzMi0wLjIxNC0zLjY4OCwwLjA0Mi01LjM5MywwLjc0M0wxMDIuODgsMTQ0LjE4bC0xLjcxMywxMC40OTZoMzYuMzU1bC0zLjc3NC0zLjA2OA0KCQljLTEuMTcyLTAuOTUzLTIuNjA0LTEuNTMzLTQuMTEtMS42NjNMMTIzLjM4OCwxNDkuNDA0eiIvPg0KCTxwYXRoIGZpbGw9IiM0MDM4NEMiIGQ9Ik01My43NDMsMTM0LjI3Mkg4NS44bDExLjIwNy0xLjcyNGMzLjU2Ni0wLjU0OSw2LjkzNi0xLjk4OSw5Ljc5Ny00LjE4OGw1Ljc2OC00LjQzMkg2OC4yODQNCgkJYy01LjM4NywwLTEwLjM1NSwyLjkwNS0xMi45OTcsNy42TDUzLjc0MywxMzQuMjcyeiIvPg0KCTxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzFBOTlENiIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNODUuOTE5LDE1Ni44MjQiLz4NCgk8cG9seWdvbiBmaWxsPSIjNUI1MDZCIiBwb2ludHM9IjU4LjQ5OSwxNzguODYxIDc3LjQ0NSwxNTQuNjc2IDYyLjI4OCwxNDkuNTU1IAkiLz4NCgk8cGF0aCBmaWxsPSIjMkUyODM3IiBkPSJNMTAxLjM3NiwxNDAuNDE0bDE5LjUxNS0xNC4xMmMxLjM5LTEuMDA2LDMuMDIzLTEuNjIxLDQuNzMxLTEuNzhsNC45NjYtMC40NjVsLTI5LjQyMywzMC42MjcNCgkJbC0zNC4wNDMtMC4wMzZsLTguNjI1LDI0LjIyMmwtMjIuMTQ5LTEzLjY3NmwxOS4xMzMtMzQuMDAyYzIuMzM5LTQuMTU4LDcuMzg4LTUuOTUxLDExLjgyNi00LjIwMkwxMDEuMzc2LDE0MC40MTR6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTEzNi42ODUsMTAyLjIzYzAuNzksMi44MjIsMi45MzgsNS4wNjIsNS43MjUsNS45NjljLTIuNzg2LDAuOTA2LTQuOTM1LDMuMTQ1LTUuNzI1LDUuOTY2bC0wLjE4NiwwLjY2NA0KCQlsLTAuMTg2LTAuNjY0Yy0wLjc5LTIuODIxLTIuOTM4LTUuMDYxLTUuNzI1LTUuOTY2YzIuNzg2LTAuOTA3LDQuOTM1LTMuMTQ3LDUuNzI1LTUuOTY5bDAuMTg2LTAuNjYyTDEzNi42ODUsMTAyLjIzeiIvPg0KCTxwYXRoIGZpbGw9IiMwMEZGOUMiIGQ9Ik01Ny44NDUsNDEuNjM4YzAuNDQ4LDEuNTk5LDEuNjY2LDIuODY4LDMuMjQ2LDMuMzhjLTEuNTgxLDAuNTE1LTIuNzk4LDEuNzg0LTMuMjQ2LDMuMzgzbC0wLjEwNiwwLjM3OQ0KCQlsLTAuMTA1LTAuMzc4Yy0wLjQ0OC0xLjYtMS42NjYtMi44NzEtMy4yNDYtMy4zODVjMS41OC0wLjUxMiwyLjc5OC0xLjc4MiwzLjI0Ni0zLjM4MWwwLjEwNi0wLjM4TDU3Ljg0NSw0MS42Mzh6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTE0Mi41MTcsOTAuMTc2YzAuNDQ5LDEuNjA1LDEuNjcyLDIuODc5LDMuMjU4LDMuMzkzYy0xLjU4NywwLjUxNi0yLjgwOSwxLjc5MS0zLjI1OCwzLjM5NmwtMC4xMDYsMC4zNzgNCgkJbC0wLjEwNi0wLjM4Yy0wLjQ1LTEuNjA1LTEuNjcyLTIuODc5LTMuMjU4LTMuMzk1YzEuNTg1LTAuNTE0LDIuODA4LTEuNzg4LDMuMjU4LTMuMzkzbDAuMTA2LTAuMzhMMTQyLjUxNyw5MC4xNzZ6Ii8+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTUzLjc0Myw1MS4wOTFjLTEuMTQxLDAtMi4wNjQsMC45MjUtMi4wNjQsMi4wNjVjMCwxLjE0LDAuOTI0LDIuMDY1LDIuMDY0LDIuMDY1czIuMDY0LTAuOTI2LDIuMDY0LTIuMDY1DQoJCUM1NS44MDgsNTIuMDE2LDU0Ljg4NCw1MS4wOTEsNTMuNzQzLDUxLjA5MXogTTUzLjc0Myw1NC4wOTRjLTAuNTE4LDAtMC45MzgtMC40Mi0wLjkzOC0wLjkzOHMwLjQyLTAuOTM3LDAuOTM4LTAuOTM3DQoJCXMwLjkzOCwwLjQxOSwwLjkzOCwwLjkzN1M1NC4yNjEsNTQuMDk0LDUzLjc0Myw1NC4wOTR6Ii8+DQoJPHBhdGggZmlsbD0iIzQwMzg0QyIgZD0iTTEzMC42ODMsNTIuNzE0aC04LjI5MlY0MS4xMjJjMC0yLjI4LDEuODQ5LTQuMTI5LDQuMTI5LTQuMTI5aDAuMDM0YzIuMjgsMCw0LjEyOSwxLjg0OSw0LjEyOSw0LjEyOQ0KCQlWNTIuNzE0eiIvPg0KCTxwYXRoIGZpbGw9IiMzNjJFNDMiIGQ9Ik0xMjcuODQ3LDM3LjIyYy0wLjQwOS0wLjEzNi0wLjgzOS0wLjIyNy0xLjI5My0wLjIyN2gtMC4wMzRjLTIuMjgsMC00LjEyOSwxLjg0OS00LjEyOSw0LjEyOXYxMS41OTJoMi42MTkNCgkJVjQxLjEyMkMxMjUuMDEsMzkuMjk2LDEyNi4yMDMsMzcuNzY1LDEyNy44NDcsMzcuMjJ6Ii8+DQoJPHJlY3QgeD0iNjcuMzY5IiB5PSI0NS4wMjMiIGZpbGw9IiNGQUY4RkMiIHdpZHRoPSI1NS4wMjIiIGhlaWdodD0iNjMuMTc1Ii8+DQoJPHBhdGggZmlsbD0iI0NDQkVFMCIgZD0iTTEyMi4zOTIsNDUuMDIzSDY3LjM2OXYtMy45MDFjMC0yLjI4MSwxLjg0OS00LjEyOSw0LjEyOS00LjEyOWg1NS4wMjJjLTIuMjgsMC00LjEyOSwxLjg0OS00LjEyOSw0LjEyOQ0KCQlWNDUuMDIzeiIvPg0KCTxjaXJjbGUgZmlsbD0iI0ZGNDY2QSIgY3g9IjcxLjE4NyIgY3k9IjQxLjAwOSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiNFRkZGMDAiIGN4PSI3Ny44MDQiIGN5PSI0MS4wMDkiIHI9IjEuNjU0Ii8+DQoJPGNpcmNsZSBmaWxsPSIjMDBGRjlDIiBjeD0iODQuNDIxIiBjeT0iNDEuMDA5IiByPSIxLjY1NCIvPg0KCTxwb2x5Z29uIGZpbGw9IiMwMEUzOEIiIHBvaW50cz0iMTAyLjA3MSwxMTcuODI1IDk0Ljg4LDExMy41MDcgODcuNjg4LDExNy44MjUgODcuNjg4LDkzLjI3MiAxMDIuMDcxLDkzLjI3MiAJIi8+DQoJPGc+DQoJCTxwb2x5Z29uIGZpbGw9IiNDQ0JFRTAiIHBvaW50cz0iODkuNjg4LDkwLjg5IDg3LjY4OCw5MC44OSA4Ny42ODgsNzguODM5IDgyLjI3NCw3My40MjQgODIuMjc0LDUzLjE1NyA4NC4yNzQsNTMuMTU3IA0KCQkJODQuMjc0LDcyLjU5NiA4OS42ODgsNzguMDExIAkJIi8+DQoJPC9nPg0KCTxnPg0KCQk8cmVjdCB4PSI5My44OCIgeT0iNjcuOTkxIiBmaWxsPSIjQ0NCRUUwIiB3aWR0aD0iMiIgaGVpZ2h0PSIyMy45NDUiLz4NCgk8L2c+DQoJPGc+DQoJCTxwb2x5Z29uIGZpbGw9IiNDQ0JFRTAiIHBvaW50cz0iMTAyLjA3MSw5MC44OSAxMDAuMDcxLDkwLjg5IDEwMC4wNzEsNzIuNjcyIDEwNS40ODcsNjcuMjU3IDEwNS40ODcsNTguODEgMTA3LjQ4Nyw1OC44MSANCgkJCTEwNy40ODcsNjguMDg1IDEwMi4wNzEsNzMuNSAJCSIvPg0KCTwvZz4NCgkNCgkJPGNpcmNsZSBmaWxsPSIjRkFGOEZDIiBzdHJva2U9IiNDQ0JFRTAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBjeD0iMTA2LjQ4NSIgY3k9IjU4LjgwOSIgcj0iMy42NDMiLz4NCgkNCgkJPGNpcmNsZSBmaWxsPSIjRkFGOEZDIiBzdHJva2U9IiNDQ0JFRTAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBjeD0iODMuMjc0IiBjeT0iNTMuMTU3IiByPSIzLjY0MyIvPg0KCQ0KCQk8Y2lyY2xlIGZpbGw9IiNGQUY4RkMiIHN0cm9rZT0iI0NDQkVFMCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI5NC44OCIgY3k9IjY3Ljk5MSIgcj0iMy42NDMiLz4NCgk8Zz4NCgkJPHBhdGggZmlsbD0iIzAwRTM4QiIgZD0iTTk0Ljg4LDEwMi44OTVjLTYuMDQ0LDAtMTAuOTYxLTQuOTE3LTEwLjk2MS0xMC45NjFzNC45MTctMTAuOTYxLDEwLjk2MS0xMC45NjENCgkJCWM2LjA0MywwLDEwLjk2LDQuOTE3LDEwLjk2LDEwLjk2MVMxMDAuOTIzLDEwMi44OTUsOTQuODgsMTAyLjg5NXoiLz4NCgkJPHBhdGggZmlsbD0iI0ZBRjhGQyIgZD0iTTk0Ljg4LDgxLjk3M2M1LjUwMSwwLDkuOTYsNC40Niw5Ljk2LDkuOTYxcy00LjQ1OSw5Ljk2MS05Ljk2LDkuOTYxcy05Ljk2MS00LjQ2LTkuOTYxLTkuOTYxDQoJCQlTODkuMzc5LDgxLjk3Myw5NC44OCw4MS45NzMgTTk0Ljg4LDc5Ljk3M2MtNi41OTUsMC0xMS45NjEsNS4zNjYtMTEuOTYxLDExLjk2MXM1LjM2NiwxMS45NjEsMTEuOTYxLDExLjk2MQ0KCQkJYzYuNTk1LDAsMTEuOTYtNS4zNjYsMTEuOTYtMTEuOTYxUzEwMS40NzUsNzkuOTczLDk0Ljg4LDc5Ljk3M0w5NC44OCw3OS45NzN6Ii8+DQoJPC9nPg0KPC9nPg0KPC9zdmc+DQo="},1127:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTkzLjYwOXB4IiBoZWlnaHQ9IjE5My42MDlweCIgdmlld0JveD0iMCAwIDE5My42MDkgMTkzLjYwOSIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTkzLjYwOSAxOTMuNjA5Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxyZWN0IGZpbGw9Im5vbmUiIHdpZHRoPSIxOTMuNjA5IiBoZWlnaHQ9IjE5My42MDkiLz4NCjxnPg0KCTxjaXJjbGUgZmlsbD0iIzVCNTA2QiIgY3g9Ijk2LjgwNCIgY3k9Ijk2LjkwMyIgcj0iNzguODE1Ii8+DQoJPHBhdGggZmlsbD0iIzQwMzg0QyIgZD0iTTgzLjk4OCw2MS44MDhMNTQuMTc0LDkxLjYyM2gzLjU5OWMxLjk2OSwwLDMuODkxLTAuNjA5LDUuNTAxLTEuNzQzbDYuNDY4LTQuNTU4bC01LjQzMSwxNC4wMWwzLjM4NS0xLjUxOQ0KCQljMi4wMTUtMC45MDQsMy42NTMtMi40NzgsNC42MzgtNC40NTRsMi40MzgtNC44OTN2MTcuMjhsMi4yMTctMi43NDNjMS4zMjEtMS42MzYsMi4yMDItMy41ODMsMi41NTctNS42NTZsMi42MjctMTUuMzU4DQoJCUw4My45ODgsNjEuODA4eiIvPg0KCTxwb2x5Z29uIGZpbGw9IiM1QjUwNkIiIHBvaW50cz0iMTM0LjQ2MSw1LjExNSAxNDIuMDMzLDQ5LjI4MSAxMzQuNDYxLDQ5LjI4MSAxMzAuNzQyLDkuMTMxIAkiLz4NCgk8cGF0aCBmaWxsPSIjMkUyODM3IiBkPSJNMTM0LjQ2MSw1LjExNXY1Mi4xNTRjMCwyLjI2LTAuODAyLDQuNDQ3LTIuMjYyLDYuMTcybC0zMC41ODEsMzYuMTE2di02LjczOA0KCQljMC0yLjQ0MiwwLjQ4LTQuODYxLDEuNDEzLTcuMTE4bDYuNjYtMTYuMTA3TDgyLjgxLDc0LjkwNGw4LjAxMiwxNC4xNmMwLjgxNSwxLjQ0MSwxLjI0NCwzLjA3LDEuMjQ0LDQuNzI2djUuNzY2bC0xNy40Ni0yMi44MDgNCgkJYy0xLjM4LTEuODAyLTEuMjEyLTQuMzQ3LDAuMzkzLTUuOTUxbDM2LjM0NC0zNi4zNDNsLTMuNTMzLTI5LjMzOUgxMzQuNDYxeiIvPg0KCTxnPg0KCQk8Zz4NCgkJCTxwYXRoIGZpbGw9IiM4RTgyQTMiIGQ9Ik05Ny4yNzMsMTI4LjUzNWgtMC44NjF2LTEuNDIzYzAtMC42OTksMC40NDMtMS4zMzIsMS4xLTEuNTdsMC40OTgtMC4xODMNCgkJCQljMC4wMTgtMC4wMDYsMC4wMzUtMC4wMTIsMC4wNDktMC4wMTljLTAuMDE0LTAuMDA2LTAuMDMxLTAuMDEyLTAuMDQ5LTAuMDJsLTIuNjI3LTAuOTUzYy0wLjY2Ni0wLjI0Mi0wLjc2NC0wLjYyMi0wLjc2NC0wLjgyOQ0KCQkJCWMwLTAuMjA0LDAuMS0wLjU4NSwwLjc2NC0wLjgyNWwyLjYyOS0wLjk1M2MwLjAxNi0wLjAwOCwwLjAzMS0wLjAxMiwwLjA0NS0wLjAyYy0wLjAxNC0wLjAwNi0wLjAyOS0wLjAxMi0wLjA0NS0wLjAxOA0KCQkJCWwtMi42MjktMC45NTNjLTAuNjY0LTAuMjQxLTAuNzY0LTAuNjIxLTAuNzY0LTAuODI2czAuMS0wLjU4NiwwLjc2NC0wLjgyNmwyLjYyOS0wLjk1M2MwLjAxNi0wLjAwNiwwLjAyOS0wLjAxMiwwLjA0NS0wLjAxOA0KCQkJCWMtMC4wMTYtMC4wMDYtMC4wMjktMC4wMTItMC4wNDctMC4wMThsLTIuNjI3LTAuOTUxYy0wLjY2NC0wLjI0My0wLjc2NC0wLjYyMi0wLjc2NC0wLjgyNmMwLTAuMjA1LDAuMS0wLjU4NiwwLjc2NC0wLjgyNg0KCQkJCWwyLjYyOS0wLjk1MmMwLjAxNi0wLjAwNiwwLjAyOS0wLjAxMiwwLjA0My0wLjAxOGMtMC4wMTQtMC4wMDUtMC4wMjctMC4wMTEtMC4wNDUtMC4wMTdsLTIuNjI3LTAuOTUyDQoJCQkJYy0wLjY2NC0wLjI0MS0wLjc2NC0wLjYyMS0wLjc2NC0wLjgyN2MwLTAuMjA0LDAuMS0wLjU4NiwwLjc2NC0wLjgyNWwyLjYyNy0wLjk1MmMwLjAxOC0wLjAwNSwwLjAzMS0wLjAxMiwwLjA0NS0wLjAxNw0KCQkJCWMtMC4wMTQtMC4wMDUtMC4wMjctMC4wMTMtMC4wNDUtMC4wMThsLTIuNjI3LTAuOTUyYy0wLjY2NC0wLjI0LTAuNzY0LTAuNjIxLTAuNzY0LTAuODI2YzAtMC4yMDQsMC4xLTAuNTg0LDAuNzY0LTAuODI4DQoJCQkJbDIuNjI3LTAuOTUxYzAuMDE4LTAuMDA0LDAuMDMxLTAuMDEyLDAuMDQ1LTAuMDE4Yy0wLjAxNC0wLjAwNC0wLjAyNy0wLjAxMi0wLjA0NS0wLjAxNmwtMi42MjctMC45NTENCgkJCQljLTAuNjY0LTAuMjQtMC43NjQtMC42MjEtMC43NjQtMC44MjZjMC0wLjIwNywwLjEtMC41ODUsMC43NjQtMC44MjhsMi42MjctMC45NDljMC4wMTgtMC4wMDYsMC4wMzEtMC4wMTMsMC4wNDUtMC4wMTkNCgkJCQljLTAuMDE0LTAuMDA3LTAuMDI3LTAuMDExLTAuMDQ1LTAuMDE3bC0yLjYyNy0wLjk1MWMtMC42NjQtMC4yMzgtMC43NjQtMC42MjEtMC43NjQtMC44MjZzMC4xLTAuNTg2LDAuNzY0LTAuODI2bDAuNDk0LTAuMTgxDQoJCQkJYzAuMzItMC4xMTYsMC41MzUtMC40MjEsMC41MzUtMC43NjF2LTEwLjMzaDAuODYxdjEwLjMzYzAsMC43MDMtMC40NDMsMS4zMzItMS4xMDIsMS41NzJsLTAuNDk2LDAuMTc5DQoJCQkJYy0wLjAxNiwwLjAwNC0wLjAzMSwwLjAxMS0wLjA0NSwwLjAxN2MwLjAxNCwwLjAwNywwLjAyOSwwLjAxNCwwLjA0NSwwLjAxOWwyLjYyNywwLjk0OWMwLjY2NiwwLjI0MSwwLjc2NiwwLjYyMiwwLjc2NiwwLjgyNg0KCQkJCWMwLDAuMjA1LTAuMSwwLjU4NS0wLjc2NiwwLjgyNmwtMi42MjcsMC45NTJjLTAuMDE2LDAuMDA2LTAuMDMxLDAuMDEyLTAuMDQ1LDAuMDE4YzAuMDE0LDAuMDA2LDAuMDI5LDAuMDExLDAuMDQ1LDAuMDE3DQoJCQkJbDIuNjI3LDAuOTVjMC42NjYsMC4yNDIsMC43NjYsMC42MjEsMC43NjYsMC44MjZjMCwwLjIwNy0wLjEsMC41ODgtMC43NjYsMC44MjhsLTIuNjI3LDAuOTQ5DQoJCQkJYy0wLjAxNiwwLjAxLTAuMDMxLDAuMDE0LTAuMDQ3LDAuMDJjMC4wMTYsMC4wMDYsMC4wMzEsMC4wMTQsMC4wNDcsMC4wMmwyLjYyNywwLjk0OWMwLjY2NiwwLjI0MiwwLjc2NiwwLjYyMSwwLjc2NiwwLjgyNw0KCQkJCXMtMC4xLDAuNTg1LTAuNzY2LDAuODI1bC0yLjYyNywwLjk1MWMtMC4wMTYsMC4wMDctMC4wMzEsMC4wMTQtMC4wNDUsMC4wMThjMC4wMTQsMC4wMDgsMC4wMjksMC4wMTQsMC4wNDUsMC4wMThsMi42MjcsMC45NTENCgkJCQljMC42NjYsMC4yNDIsMC43NjYsMC42MjMsMC43NjYsMC44MjdjMCwwLjIwNi0wLjEsMC41ODctMC43NjYsMC44MjdsLTIuNjI3LDAuOTQ5Yy0wLjAxNiwwLjAwNi0wLjAzMSwwLjAxNC0wLjA0NSwwLjAyDQoJCQkJYzAuMDE0LDAuMDA0LDAuMDI5LDAuMDEsMC4wNDUsMC4wMTZsMi42MjcsMC45NTNjMC42NjYsMC4yMzksMC43NjYsMC42MjEsMC43NjYsMC44MjZjMCwwLjIwMy0wLjEsMC41ODYtMC43NjYsMC44MjQNCgkJCQlsLTIuNjI3LDAuOTU1Yy0wLjAxNiwwLjAwNi0wLjAzMSwwLjAxMi0wLjA0NSwwLjAxOGMwLjAxNCwwLjAwNiwwLjAyOSwwLjAxLDAuMDQ1LDAuMDE2bDIuNjI3LDAuOTU1DQoJCQkJYzAuNjY2LDAuMjQsMC43NjYsMC42MiwwLjc2NiwwLjgyNmMwLDAuMjA1LTAuMSwwLjU4Ni0wLjc2NCwwLjgyN2wtMi42MjksMC45NTNjLTAuMDE4LDAuMDA4LTAuMDMzLDAuMDEyLTAuMDQ5LDAuMDE4DQoJCQkJYzAuMDE2LDAuMDA4LDAuMDMxLDAuMDE1LDAuMDQ5LDAuMDIxbDIuNjI3LDAuOTUzYzAuNjY2LDAuMjQyLDAuNzY2LDAuNjI1LDAuNzY2LDAuODI4YzAsMC4yMDUtMC4xLDAuNTg4LTAuNzY0LDAuODI3DQoJCQkJbC0wLjQ5OCwwLjE4NGMtMC4zMTgsMC4xMTYtMC41MzMsMC40MjEtMC41MzMsMC43NjFWMTI4LjUzNXoiLz4NCgkJPC9nPg0KCQk8cmVjdCB4PSI5NC4xNDYiIHk9IjEyNy4wMDYiIGZpbGw9IiM4RTgyQTMiIHdpZHRoPSI1LjM5MyIgaGVpZ2h0PSI4LjAzNCIvPg0KCQk8cmVjdCB4PSI5MS4zNDYiIHk9IjEwMi4wMTIiIGZpbGw9IiNGOEY1RkQiIHdpZHRoPSIxLjA0MSIgaGVpZ2h0PSIzMy4wMjgiLz4NCgkJPHJlY3QgeD0iMTAxLjI5OSIgeT0iMTAyLjAxMiIgZmlsbD0iI0Y4RjVGRCIgd2lkdGg9IjEuMDQxIiBoZWlnaHQ9IjMzLjAyOCIvPg0KCQk8cmVjdCB4PSI5MC4zMDMiIHk9IjEzNi44MDEiIGZpbGw9IiNGOEY1RkQiIHdpZHRoPSIxMy4wNzQiIGhlaWdodD0iOC4yNTQiLz4NCgkJPHBhdGggZmlsbD0iI0Y4RjVGRCIgZD0iTTg5LjI2NiwxNDYuODE0djkuMzM0YzAsMS43MjIsMS4zOTYsMy4xMTgsMy4xMTgsMy4xMThoOC45MThjMS43MjIsMCwzLjExOC0xLjM5NiwzLjExOC0zLjExOHYtOS4zMzQNCgkJCUg4OS4yNjZ6Ii8+DQoJCTxjaXJjbGUgZmlsbD0iI0ZGNDY2QSIgY3g9Ijk2Ljg0NCIgY3k9IjE1My4wNDMiIHI9IjEuNjU0Ii8+DQoJCTxwYXRoIGZpbGw9IiM4RTgyQTMiIGQ9Ik0xMDAuMzgxLDE2Mi4wODdjMC41OCwwLDEuMDUxLTAuNDc0LDEuMDUxLTEuMDUySDk5LjMzQzk5LjMzLDE2MS42MTQsOTkuNzk5LDE2Mi4wODcsMTAwLjM4MSwxNjIuMDg3eiIvPg0KCQk8cGF0aCBmaWxsPSIjOEU4MkEzIiBkPSJNOTMuMjI5LDE2Mi4wODdjMC41OCwwLDEuMDUxLTAuNDc0LDEuMDUxLTEuMDUyaC0yLjEwMkM5Mi4xNzgsMTYxLjYxNCw5Mi42NDYsMTYyLjA4Nyw5My4yMjksMTYyLjA4N3oiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg=="},1128:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTkzLjYwOXB4IiBoZWlnaHQ9IjE5My42MDlweCIgdmlld0JveD0iMCAwIDE5My42MDkgMTkzLjYwOSIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTkzLjYwOSAxOTMuNjA5Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxyZWN0IGZpbGw9Im5vbmUiIHdpZHRoPSIxOTMuNjA5IiBoZWlnaHQ9IjE5My42MDkiLz4NCjxnPg0KCTxjaXJjbGUgZmlsbD0iIzVCNTA2QiIgY3g9Ijk2LjgwMyIgY3k9Ijk2LjgwNSIgcj0iNzguODE1Ii8+DQoJPHJlY3QgeD0iMTAxLjEyNyIgeT0iMTE0LjMzOSIgZmlsbD0iIzQwMzg0QyIgd2lkdGg9IjI2IiBoZWlnaHQ9IjI2Ii8+DQoJPHJlY3QgeD0iNTAuODUiIHk9Ijc5LjY5IiBmaWxsPSIjNDAzODRDIiB3aWR0aD0iMjIuNDg0IiBoZWlnaHQ9IjI2Ii8+DQoJPGc+DQoJCTxyZWN0IHg9IjEwOS42MjUiIHk9IjQ4LjU1OCIgZmlsbD0iIzQwMzg0QyIgd2lkdGg9IjIiIGhlaWdodD0iNTcuMTMzIi8+DQoJPC9nPg0KCTxnPg0KCQk8cmVjdCB4PSI5NS44MDMiIHk9IjQ4LjU1OCIgZmlsbD0iIzQwMzg0QyIgd2lkdGg9IjIiIGhlaWdodD0iNTcuMTMzIi8+DQoJPC9nPg0KCTxnPg0KCQk8cmVjdCB4PSI4MS45ODIiIHk9IjQ4LjU1OCIgZmlsbD0iIzQwMzg0QyIgd2lkdGg9IjIiIGhlaWdodD0iNTcuMTMzIi8+DQoJPC9nPg0KCTxwYXRoIGZpbGw9IiM1QjUwNkIiIGQ9Ik04Mi45OCw1Ni4yMjFjLTMuODM0LDAtNi45NTMsMy4xMi02Ljk1Myw2Ljk1NnMzLjExOSw2Ljk1Nyw2Ljk1Myw2Ljk1N2MzLjgzNiwwLDYuOTU3LTMuMTIxLDYuOTU3LTYuOTU3DQoJCVM4Ni44MTYsNTYuMjIxLDgyLjk4LDU2LjIyMXoiLz4NCgk8cGF0aCBmaWxsPSIjRkY0NjZBIiBzdHJva2U9IiM0MDM4NEMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNODIuOTgsNjYuMzQNCgkJYy0yLjkyLDAtNS4yODctMi4zNzMtNS4yODctNS4yOTJjMC0yLjkyNCwyLjM2Ny01LjI5LDUuMjg3LTUuMjljMi45MjIsMCw1LjI5MSwyLjM2Niw1LjI5MSw1LjI5DQoJCUM4OC4yNzEsNjMuOTY3LDg1LjkwMiw2Ni4zNCw4Mi45OCw2Ni4zNHoiLz4NCgk8cGF0aCBmaWxsPSIjNDAzODRDIiBkPSJNMTI1LjQsNjUuMjA0bC02LjI5NywxNC41MzhsMy42MDYsOS4yNWwwLjc3Ni0xLjM1OGMxLjUyOC0yLjY3NSwyLjExLTUuNzg2LDEuNjUzLTguODMzbDUuNjQ1LTQuODYNCgkJbC0xLjk4NSwxNC4wNDFsMy41ODcsMTAuMTgybDMuNTIyLDIuNDY3bDEzLjA2MS0yMi4xOTZMMTI1LjQsNjUuMjA0eiIvPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjOUI5OEY2IiBkPSJNNjguNDQ5LDU1LjU2MWMwLjgxMiwxLjIxMywxLjI4NSwyLjY3LDEuMjg1LDQuMjM5YzAsMy4xMDMtMS44NTIsNS43NjctNC41MDYsNi45NjVsMS40NzcsMy4yOA0KCQkJYzMuOTA2LTEuNzYyLDYuNjI5LTUuNjgyLDYuNjI5LTEwLjI0NWMwLTIuMzA4LTAuNjk3LTQuNDUxLTEuODg5LTYuMjM1TDY4LjQ0OSw1NS41NjF6Ii8+DQoJCTxwYXRoIGZpbGw9IiNGRjQ2NkEiIGQ9Ik02Mi4wOTIsNTIuMTU5YzEuOTg4LDAsMy43OTMsMC43NjUsNS4xNTIsMi4wMDhsMi40MjgtMi42NTNjLTItMS44My00LjY1NC0yLjk1Ni03LjU4LTIuOTU2DQoJCQljLTAuNjkxLDAtMS4zNjUsMC4wNzEtMi4wMjMsMC4xOTFsMC42NDgsMy41NEM2MS4xNjQsNTIuMjA4LDYxLjYyMyw1Mi4xNTksNjIuMDkyLDUyLjE1OXoiLz4NCgkJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTYyLjA5Miw2Ny40NDJjLTQuMjIxLDAtNy42NDEtMy40MjItNy42NDEtNy42NDNjMC0zLjEwMywxLjg1Mi01Ljc2Nyw0LjUwNi02Ljk2M2wtMS40NzctMy4yODINCgkJCWMtMy45MDYsMS43NjItNi42MzEsNS42ODItNi42MzEsMTAuMjQ1YzAsNi4yMDksNS4wMzMsMTEuMjQyLDExLjI0MiwxMS4yNDJjMC42OTMsMCwxLjM2Ny0wLjA3MSwyLjAyNS0wLjE5MWwtMC42NDgtMy41MzgNCgkJCUM2My4wMjEsNjcuMzk0LDYyLjU2Miw2Ny40NDIsNjIuMDkyLDY3LjQ0MnoiLz4NCgk8L2c+DQoJPHJlY3QgeD0iNTQuMDYyIiB5PSI5Mi4yMzYiIGZpbGw9IiM5Qjk4RjYiIHdpZHRoPSIzLjIxMyIgaGVpZ2h0PSIxMy40NTQiLz4NCgk8cmVjdCB4PSI2MC40ODYiIHk9Ijg0LjIxMiIgZmlsbD0iIzAwRkY5QyIgd2lkdGg9IjMuMjEzIiBoZWlnaHQ9IjIxLjQ3OSIvPg0KCTxyZWN0IHg9IjY2LjkxIiB5PSI5OS45MTEiIGZpbGw9IiNGRjQ2NkEiIHdpZHRoPSIzLjIxMyIgaGVpZ2h0PSI1Ljc3OSIvPg0KCTxjaXJjbGUgZmlsbD0iIzAwRkY5QyIgY3g9IjEwNi41MTYiIGN5PSIxMTkuNzI5IiByPSIxLjY1NCIvPg0KCTxjaXJjbGUgZmlsbD0iIzlCOThGNiIgY3g9IjExNC4xMjciIGN5PSIxMTkuNzI5IiByPSIxLjY1NCIvPg0KCTxjaXJjbGUgZmlsbD0iIzAwRkY5QyIgY3g9IjUyLjUwNCIgY3k9IjExOS43MjkiIHI9IjEuNjU0Ii8+DQoJPGNpcmNsZSBmaWxsPSIjOUI5OEY2IiBjeD0iNTcuNTAyIiBjeT0iMTE5LjcyOSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiNGRjQ2NkEiIGN4PSIxMjEuNzM4IiBjeT0iMTE5LjcyOSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiM5Qjk4RjYiIGN4PSIxMDYuNTE2IiBjeT0iMTM0Ljk0OSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiNGRjQ2NkEiIGN4PSIxMTQuMTI3IiBjeT0iMTM0Ljk0OSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiMwMEZGOUMiIGN4PSIxMjEuNzM4IiBjeT0iMTM0Ljk0OSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiNGRjQ2NkEiIGN4PSIxMDYuNTE2IiBjeT0iMTI3LjMzOSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiMwMEZGOUMiIGN4PSIxMTQuMTI3IiBjeT0iMTI3LjMzOSIgcj0iMS42NTQiLz4NCgk8Y2lyY2xlIGZpbGw9IiM5Qjk4RjYiIGN4PSIxMjEuNzM4IiBjeT0iMTI3LjMzOSIgcj0iMS42NTQiLz4NCgk8cGF0aCBmaWxsPSIjNUI1MDZCIiBkPSJNOTYuODAzLDg4LjM3MWMtMy44MzQsMC02Ljk1NSwzLjEyLTYuOTU1LDYuOTU2czMuMTIxLDYuOTU3LDYuOTU1LDYuOTU3YzMuODM2LDAsNi45NTUtMy4xMjEsNi45NTUtNi45NTcNCgkJUzEwMC42MzksODguMzcxLDk2LjgwMyw4OC4zNzF6Ii8+DQoJPHBhdGggZmlsbD0iIzlCOThGNiIgc3Ryb2tlPSIjNDAzODRDIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTk2LjgwMyw5OC40OQ0KCQljLTIuOTIyLDAtNS4yODktMi4zNzMtNS4yODktNS4yOTJjMC0yLjkyNCwyLjM2Ny01LjI5LDUuMjg5LTUuMjlzNS4yODksMi4zNjYsNS4yODksNS4yOQ0KCQlDMTAyLjA5Miw5Ni4xMTcsOTkuNzI1LDk4LjQ5LDk2LjgwMyw5OC40OXoiLz4NCgk8cGF0aCBmaWxsPSIjNUI1MDZCIiBkPSJNMTEwLjYyNSw3Mi4zMDJjLTMuODM0LDAtNi45NTUsMy4xMi02Ljk1NSw2Ljk1NnMzLjEyMSw2Ljk1Nyw2Ljk1NSw2Ljk1N2MzLjgzNiwwLDYuOTU1LTMuMTIxLDYuOTU1LTYuOTU3DQoJCVMxMTQuNDYxLDcyLjMwMiwxMTAuNjI1LDcyLjMwMnoiLz4NCgk8cGF0aCBmaWxsPSIjMDBGRjlDIiBzdHJva2U9IiM0MDM4NEMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMTEwLjYyNSw4Mi40MjENCgkJYy0yLjkyMiwwLTUuMjg5LTIuMzczLTUuMjg5LTUuMjkyYzAtMi45MjQsMi4zNjctNS4yOSw1LjI4OS01LjI5czUuMjg5LDIuMzY2LDUuMjg5LDUuMjkNCgkJQzExNS45MTQsODAuMDQ4LDExMy41NDcsODIuNDIxLDExMC42MjUsODIuNDIxeiIvPg0KCTxwb2x5Z29uIGZpbGw9IiM1QjUwNkIiIHBvaW50cz0iMTQ2LjU1NywxODIuOTMgMTM2LjEyNywxMzMuMjk1IDE1NS4zNzcsMTIwLjEyMSAJIi8+DQoJPHBhdGggZmlsbD0iIzJFMjgzNyIgZD0iTTE0Ni41NTcsMTgyLjkzdi02MS4zNjlsLTIxLjIzOS0xMi4zODdsLTIxLjUyMi0yMS4xNzZoNS41NzZjMy4xODgsMCw2LjMyMSwwLjgxOCw5LjEwMywyLjM3NQ0KCQlsMTMuOTExLDcuNzkxbDguNDk2LTE1LjU4N2wtMTUuNDgxLTE3LjM3M2wtMTEuMTAyLDEuODI3Yy0yLjE1MiwwLjM1NC00LjM1OSwwLjE2MS02LjQxNy0wLjU2MmwtNC4wODYtMS40MzZsMTkuNDktNy42MDQNCgkJYzEuMzMxLTAuNTE5LDIuODI4LTAuMzgsNC4wNCwwLjM3NmwxOC44OTcsMTEuNzg0YzEuNTM3LDAuOTU4LDIuODUxLDIuMjM1LDMuODUzLDMuNzQzbDEzLjA3MiwxOS42NzcNCgkJYzEuMDgsMS42MjUsMS43NzEsMy40NzgsMi4wMTcsNS40MTNsOC45MTQsNjkuODg4TDE0Ni41NTcsMTgyLjkzeiIvPg0KCTxnPg0KCQk8cmVjdCB4PSI4NC4yODMiIHk9IjEzNC40MjgiIGZpbGw9IiM4RTgyQTMiIHdpZHRoPSI4LjE5NyIgaGVpZ2h0PSIxLjk1Ii8+DQoJPC9nPg0KCTxnPg0KCQk8cmVjdCB4PSI4NC4yODMiIHk9IjEzMC41MjciIGZpbGw9IiM4RTgyQTMiIHdpZHRoPSI4LjE5NyIgaGVpZ2h0PSIxLjk1Ii8+DQoJPC9nPg0KCTxnPg0KCQk8cmVjdCB4PSI4NC4yODMiIHk9IjEyNi42MjciIGZpbGw9IiM4RTgyQTMiIHdpZHRoPSI4LjE5NyIgaGVpZ2h0PSIxLjk1Ii8+DQoJPC9nPg0KCTxnPg0KCQk8cG9seWdvbiBmaWxsPSIjNDAzODRDIiBwb2ludHM9IjcxLjA1NywxMjguMTM2IDU5LjI2LDExNi4zMzkgNTAuODUsMTE2LjMzOSA1MC44NSwxMTQuMzM5IDYwLjA4OCwxMTQuMzM5IDcyLjQ3MSwxMjYuNzIyIAkJIi8+DQoJPC9nPg0KCTxnPg0KCQk8cG9seWdvbiBmaWxsPSIjNDAzODRDIiBwb2ludHM9IjcyLjQ3MSwxMjguMTM2IDcxLjA1NywxMjYuNzIyIDgzLjQzOSwxMTQuMzM5IDkyLjQ4LDExNC4zMzkgOTIuNDgsMTE2LjMzOSA4NC4yNjgsMTE2LjMzOSAJCSIvPg0KCTwvZz4NCgk8Zz4NCgkJPHBvbHlnb24gZmlsbD0iIzQwMzg0QyIgcG9pbnRzPSI2MC4wODgsMTQwLjMzOSA1MC44NSwxNDAuMzM5IDUwLjg1LDEzOC4zMzkgNTkuMjYsMTM4LjMzOSA3MS4wNTcsMTI2LjU0MiA3Mi40NzEsMTI3Ljk1NiAJCSIvPg0KCTwvZz4NCgk8Zz4NCgkJPHBvbHlnb24gZmlsbD0iIzQwMzg0QyIgcG9pbnRzPSI5Mi40OCwxNDAuMzM5IDgzLjQzOSwxNDAuMzM5IDcxLjA1NywxMjcuOTU2IDcyLjQ3MSwxMjYuNTQyIDg0LjI2OCwxMzguMzM5IDkyLjQ4LDEzOC4zMzkgCQkiLz4NCgk8L2c+DQoJPHBhdGggZmlsbD0iIzAwRkY5QyIgc3Ryb2tlPSIjNDAzODRDIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTcxLjc2NCwxMTYuNTQyDQoJCWMtNS4zNjMsMC05LjcxMyw0LjM0OS05LjcxMyw5LjcxNGMwLDUuMzYzLDQuMzUsOS43MTMsOS43MTMsOS43MTNjNS4zNjUsMCw5LjcxMy00LjM1LDkuNzEzLTkuNzEzDQoJCUM4MS40NzcsMTIwLjg5MSw3Ny4xMjksMTE2LjU0Miw3MS43NjQsMTE2LjU0MnoiLz4NCgk8Zz4NCgkJPHBhdGggZmlsbD0iIzAwRkY5QyIgZD0iTTcxLjc2NCwxMzAuODA3Yy0yLjUxLDAtNC41NTEtMi4wNDItNC41NTEtNC41NTNzMi4wNDEtNC41NTMsNC41NTEtNC41NTNzNC41NTEsMi4wNDIsNC41NTEsNC41NTMNCgkJCVM3NC4yNzMsMTMwLjgwNyw3MS43NjQsMTMwLjgwN3oiLz4NCgkJPHBhdGggZmlsbD0iIzVCNTA2QiIgZD0iTTcxLjc2NCwxMjIuNzAxYzEuOTYxLDAsMy41NTEsMS41OSwzLjU1MSwzLjU1M2MwLDEuOTYtMS41OSwzLjU1My0zLjU1MSwzLjU1M3MtMy41NTEtMS41OTMtMy41NTEtMy41NTMNCgkJCUM2OC4yMTMsMTI0LjI5MSw2OS44MDMsMTIyLjcwMSw3MS43NjQsMTIyLjcwMSBNNzEuNzY0LDEyMC43MDFjLTMuMDYxLDAtNS41NTEsMi40OTEtNS41NTEsNS41NTNzMi40OSw1LjU1Myw1LjU1MSw1LjU1Mw0KCQkJczUuNTUxLTIuNDkxLDUuNTUxLTUuNTUzUzc0LjgyNCwxMjAuNzAxLDcxLjc2NCwxMjAuNzAxTDcxLjc2NCwxMjAuNzAxeiIvPg0KCTwvZz4NCjwvZz4NCjwvc3ZnPg0K"},1129:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTQwLjE0OXB4IiBoZWlnaHQ9IjE5MC40NTdweCIgdmlld0JveD0iMCAwIDE0MC4xNDkgMTkwLjQ1NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTQwLjE0OSAxOTAuNDU3Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwb2x5Z29uIGZpbGw9IiMwMEZGOUMiIHBvaW50cz0iMTE0LjI0OSwxNzcuMTI2IDExNC4yNDksMC43ODYgNzYuNDYyLDAuNzg2IDc2LjQ2MiwxMy4zODEgMTAxLjY1MywxMy4zODEgMTAxLjY1MywxNzcuMTI2IA0KCQk3Ni40NjIsMTc3LjEyNiA3Ni40NjIsMTg5LjcyMiAxMzkuNDQsMTg5LjcyMiAxMzkuNDQsMTc3LjEyNiAJIi8+DQoJPGc+DQoJCTxwYXRoIGZpbGw9IiMwMEZGOUMiIGQ9Ik0zMi4zNzgsMC43ODZjLTE3LjM5MywwLTMxLjQ5LDE0LjA5OC0zMS40OSwzMS40ODl2MTI1Ljk1N2MwLDE3LjM5MSwxNC4wOTgsMzEuNDksMzEuNDksMzEuNDkNCgkJCWMxNy4zOTEsMCwzMS40ODgtMTQuMSwzMS40ODgtMzEuNDlWMzIuMjc0QzYzLjg2NiwxNC44ODMsNDkuNzY5LDAuNzg2LDMyLjM3OCwwLjc4NnogTTEzLjQ4MywzMi4yNzQNCgkJCWMwLTEwLjQzNCw4LjQ1OS0xOC44OTMsMTguODk1LTE4Ljg5M2MxMC40MzQsMCwxOC44OTMsOC40NTksMTguODkzLDE4Ljg5M2wwLDB2MzUuMThsLTM3Ljc4NywzNy43ODdWMzIuMjc0TDEzLjQ4MywzMi4yNzR6DQoJCQkgTTUxLjI3MSwxNTguMjMxYzAsMTAuNDM2LTguNDU5LDE4Ljg5My0xOC44OTMsMTguODkzYy0xMC40MzYsMC0xOC44OTUtOC40NTctMTguODk1LTE4Ljg5M2wwLDB2LTM1LjE3OGwzNy43ODctMzcuNzg3VjE1OC4yMzENCgkJCUw1MS4yNzEsMTU4LjIzMXoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg=="},1130:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTQwLjE0OXB4IiBoZWlnaHQ9IjE5MC40NTdweCIgdmlld0JveD0iMCAwIDE0MC4xNDkgMTkwLjQ1NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTQwLjE0OSAxOTAuNDU3Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGZpbGw9IiMwMEZGOUMiIGQ9Ik0xMzkuNDc1LDcyLjY3M1YzMi4yNzZjMC0xNy4zOTEtMTQuMDk4LTMxLjQ4OS0zMS40ODgtMzEuNDg5Yy0xNy4zOTMsMC0zMS40OSwxNC4wOTgtMzEuNDksMzEuNDg5aDEyLjU5OA0KCQljMC0xMC40MzQsOC40NTctMTguODkzLDE4Ljg5My0xOC44OTNjMTAuNDM0LDAsMTguODkzLDguNDU5LDE4Ljg5MywxOC44OTNsMCwwdjM1LjE3OGwtNTAuNDE4LDUwLjQxOGwwLjAzNSw3MS44NTJoNjIuOTc5di0xMi41OTYNCgkJSDg5LjA5MnYtNTQuMDc0TDEzOS40NzUsNzIuNjczeiIvPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMzIuMzc3LDAuNzg2Yy0xNy4zOTMsMC0zMS40OSwxNC4wOTgtMzEuNDksMzEuNDg5djEyNS45NTljMCwxNy4zOTEsMTQuMDk4LDMxLjQ4OCwzMS40OSwzMS40ODgNCgkJCWMxNy4zOTEsMCwzMS40ODgtMTQuMDk4LDMxLjQ4OC0zMS40ODhWMzIuMjc0QzYzLjg2NiwxNC44ODMsNDkuNzY4LDAuNzg2LDMyLjM3NywwLjc4NnogTTEzLjQ4MywzMi4yNzQNCgkJCWMwLTEwLjQzNCw4LjQ1OS0xOC44OTMsMTguODk1LTE4Ljg5M2MxMC40MzQsMCwxOC44OTMsOC40NTksMTguODkzLDE4Ljg5M2wwLDB2MzUuMThsLTM3Ljc4NywzNy43ODdWMzIuMjc0TDEzLjQ4MywzMi4yNzR6DQoJCQkgTTUxLjI3LDE1OC4yMzNjMCwxMC40MzQtOC40NTksMTguODkzLTE4Ljg5MywxOC44OTNjLTEwLjQzNiwwLTE4Ljg5NS04LjQ1OS0xOC44OTUtMTguODkzbDAsMHYtMzUuMThMNTEuMjcsODUuMjY3VjE1OC4yMzMNCgkJCUw1MS4yNywxNTguMjMzeiIvPg0KCTwvZz4NCjwvZz4NCjwvc3ZnPg0K"},1131:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTQwLjE0OXB4IiBoZWlnaHQ9IjE5MC40NTdweCIgdmlld0JveD0iMCAwIDE0MC4xNDkgMTkwLjQ1NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTQwLjE0OSAxOTAuNDU3Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMzIuMzc2LDAuNzg2Yy0xNy4zOTEsMC0zMS40ODgsMTQuMDk4LTMxLjQ4OCwzMS40ODl2MTI1Ljk1N2MwLDE3LjM5MSwxNC4wOTgsMzEuNDksMzEuNDg4LDMxLjQ5DQoJCQljMTcuMzkyLDAsMzEuNDkxLTE0LjEsMzEuNDkxLTMxLjQ5VjMyLjI3NEM2My44NjcsMTQuODgzLDQ5Ljc2OCwwLjc4NiwzMi4zNzYsMC43ODZ6IE0xMy40ODQsMzIuMjc0DQoJCQljMC0xMC40MzQsOC40NTgtMTguODkzLDE4Ljg5Mi0xOC44OTNjMTAuNDM1LDAsMTguODk0LDguNDU5LDE4Ljg5NCwxOC44OTNoMC4wMDJ2MzUuMThsLTM3Ljc4OCwzNy43ODdMMTMuNDg0LDMyLjI3NA0KCQkJTDEzLjQ4NCwzMi4yNzR6IE01MS4yNywxNTguMjMxYzAsMTAuNDM2LTguNDU5LDE4Ljg5My0xOC44OTQsMTguODkzYy0xMC40MzQsMC0xOC44OTItOC40NTctMTguODkyLTE4Ljg5M2gtMC4wMDF2LTM1LjE3OA0KCQkJbDM3Ljc4OC0zNy43ODd2NzIuOTY1SDUxLjI3eiIvPg0KCTwvZz4NCgk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMTM5LjQzOSw0MC42ODF2LTguNDA0YzAtMTcuMzktMTQuMDk4LTMxLjQ5LTMxLjQ4OC0zMS40OWMtMTcuMzkyLDAtMzEuNDg5LDE0LjA5OC0zMS40ODksMzEuNDg4aDEyLjU5Nw0KCQljMC0xMC40MzQsOC40NTgtMTguODkyLDE4Ljg5My0xOC44OTJ2MC4wMDJjMTAuNDM0LDAsMTguODkzLDguNDU3LDE4Ljg5MywxOC44OTJoMC4wMDF2OC40MDRjMCwxMC40MzQtOC40NTksMTguODkzLTE4Ljg5MywxOC44OTMNCgkJdjEyLjU5NnYwLjAwMmMxMC40MzQsMCwxOC44OTMsOC40NTksMTguODkzLDE4Ljg5M3Y2Ny4xN2gtMC4wMDFjMCwxMC40MzQtOC40NTksMTguODkzLTE4Ljg5MywxOC44OTNsMCwwDQoJCWMtMTAuNDM1LDAtMTguODkzLTguNDU5LTE4Ljg5My0xOC44OTNINzYuNDYyYzAsMTcuMzkxLDE0LjA5OCwzMS40ODgsMzEuNDg5LDMxLjQ4OGMxNy4zOTEsMCwzMS40ODgtMTQuMDk4LDMxLjQ4OC0zMS40ODh2LTY3LjE3DQoJCWMwLTEwLjMwMS00Ljk0OC0xOS40NDctMTIuNTk2LTI1LjE5MUMxMzQuNDkxLDYwLjEyOCwxMzkuNDM5LDUwLjk4MSwxMzkuNDM5LDQwLjY4MXoiLz4NCjwvZz4NCjwvc3ZnPg0K"},1132:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTQwLjE0OXB4IiBoZWlnaHQ9IjE5MC40NTdweCIgdmlld0JveD0iMCAwIDE0MC4xNDkgMTkwLjQ1NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTQwLjE0OSAxOTAuNDU3Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMzIuMzc4LDAuNzg2Yy0xNy4zOTMsMC0zMS40OSwxNC4wOTgtMzEuNDksMzEuNDg4djEyNS45NTljMCwxNy4zOTEsMTQuMDk4LDMxLjQ4OCwzMS40OSwzMS40ODgNCgkJCWMxNy4zOTEsMCwzMS40ODgtMTQuMDk4LDMxLjQ4OC0zMS40ODhWMzIuMjczQzYzLjg2NiwxNC44ODMsNDkuNzY5LDAuNzg2LDMyLjM3OCwwLjc4NnogTTEzLjQ4MywzMi4yNzMNCgkJCWMwLTEwLjQzNCw4LjQ1OS0xOC44OTIsMTguODk1LTE4Ljg5MmMxMC40MzQsMCwxOC44OTMsOC40NTgsMTguODkzLDE4Ljg5MmwwLDB2MzUuMThMMTMuNDgzLDEwNS4yNFYzMi4yNzNMMTMuNDgzLDMyLjI3M3oNCgkJCSBNNTEuMjcxLDE1OC4yMzJjMCwxMC40MzQtOC40NTksMTguODkzLTE4Ljg5MywxOC44OTNjLTEwLjQzNiwwLTE4Ljg5NS04LjQ1OS0xOC44OTUtMTguODkzbDAsMHYtMzUuMThsMzcuNzg3LTM3Ljc4N1YxNTguMjMyDQoJCQlMNTEuMjcxLDE1OC4yMzJ6Ii8+DQoJPC9nPg0KCTxwb2x5Z29uIGZpbGw9IiMwMEZGOUMiIHBvaW50cz0iMTM5LjQ0LDEzOS4zMzggMTI2Ljg0NSwxMzkuMzM4IDEyNi44NDUsOTUuMjU0IDExNC4yNDksOTUuMjU0IDExNC4yNDksMTM5LjMzOCA4OS4wNTgsMTM5LjMzOCANCgkJODkuMDU4LDAuNzg2IDc2LjQ2MiwwLjc4NiA3Ni40NjIsMTUxLjkzNCAxMTQuMjQ5LDE1MS45MzQgMTE0LjI0OSwxODkuNzIxIDEyNi44NDUsMTg5LjcyMSAxMjYuODQ1LDE1MS45MzQgMTM5LjQ0LDE1MS45MzQgCSIvPg0KPC9nPg0KPC9zdmc+DQo="},1133:function(e,n){e.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMTQwLjE0OXB4IiBoZWlnaHQ9IjE5MC40NTdweCIgdmlld0JveD0iMCAwIDE0MC4xNDkgMTkwLjQ1NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTQwLjE0OSAxOTAuNDU3Ig0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjMDBGRjlDIiBkPSJNMzIuMzc1LDAuNzg2Yy0xNy4zOTEsMC0zMS40ODgsMTQuMDk4LTMxLjQ4OCwzMS40ODh2MTI1Ljk1OWMwLDE3LjM5MSwxNC4wOTgsMzEuNDg4LDMxLjQ4OCwzMS40ODgNCgkJCXMzMS40OS0xNC4wOTgsMzEuNDktMzEuNDg4VjMyLjI3M0M2My44NjUsMTQuODgzLDQ5Ljc2NiwwLjc4NiwzMi4zNzUsMC43ODZ6IE0xMy40ODIsMzIuMjczYzAtMTAuNDM0LDguNDU5LTE4Ljg5MiwxOC44OTMtMTguODkyDQoJCQlzMTguODkzLDguNDU4LDE4Ljg5MywxOC44OTJoMC4wMDJ2MzUuMThMMTMuNDgyLDEwNS4yNFYzMi4yNzNMMTMuNDgyLDMyLjI3M3ogTTUxLjI2OCwxNTguMjMyDQoJCQljMCwxMC40MzQtOC40NTksMTguODkzLTE4Ljg5MywxOC44OTNzLTE4Ljg5My04LjQ1OS0xOC44OTMtMTguODkzbDAsMHYtMzUuMThMNTEuMjcsODUuMjY2djcyLjk2N0g1MS4yNjh6Ii8+DQoJPC9nPg0KCTxwYXRoIGZpbGw9IiMwMEZGOUMiIGQ9Ik0xMzkuNDM5LDkxLjA2MmMwLTE3LjM5MS0xNC4wOTgtMzEuNDg4LTMxLjQ4OC0zMS40ODhjLTcuMDksMC0xMy42MzEsMi4zNDQtMTguODk1LDYuMjk3di01Mi40OWg1MC4zODMNCgkJVjAuNzg2SDc2LjQ2MXY5MC4yNzdoMTIuNTk2aDAuMDAyYzAtMTAuNDM0LDguNDU3LTE4Ljg5MywxOC44OTMtMTguODkzYzEwLjQzNCwwLDE4Ljg5Myw4LjQ1OSwxOC44OTMsMTguODkzbC0wLjAwMiw2Ny4xNw0KCQljMCwxMC40MzQtOC40NTcsMTguODkzLTE4Ljg5MywxOC44OTNjLTEwLjQzNCwwLTE4Ljg5My04LjQ1OS0xOC44OTMtMTguODkzSDc2LjQ2MWMwLDE3LjM5MSwxNC4wOTgsMzEuNDg4LDMxLjQ4OCwzMS40ODgNCgkJczMxLjQ5LTE0LjA5NiwzMS40OS0zMS40ODZsMCwwVjkxLjA2MkwxMzkuNDM5LDkxLjA2MnoiLz4NCjwvZz4NCjwvc3ZnPg0K"},668:function(e,n,t){"use strict";t.r(n),t.d(n,"App",(function(){return $n}));var o=t(7),a=t(4),r=t(57),s=t(0),i=t.n(s),c=t(351),d=t(1122),l=t(1),u=(t(73),t(384));const m=(e,n)=>`Lesson ${n+1}: ${e}`,p=(e,n)=>`/course/${e}/${n+1}`,h=(e,n)=>`Chapter ${n+1}: ${e}`,f=(e,n,t)=>`/course/${e}/${n+1}/${t+1}`;var w=t(1125);const b=t.n(w).a,y=e=>b[e.course],g=e=>b[e.course].lessons[e.lesson],v=e=>b[e.course].lessons[e.lesson].chapters[e.chapter];var x=t(588),A=t(1123),k=t.n(A),T=t(435),N=t(1139),M=t(586),E=t.n(M),S=t(587);const I=E()();Object(x.b)(!1);const C=I("COMPLETE_CHAPTER"),D=Object(S.reducerWithInitialState)({progress:{}}).case(C,(e,{course:n,lesson:t,chapter:o})=>Object(x.a)(e,e=>{void 0===e.progress[n]&&(e.progress[n]={}),void 0===e.progress[n][t]&&(e.progress[n][t]={}),e.progress[n][t][o]=!0})),j=k.a.createInstance({name:"neo-one-course"}),L=(e,{course:n,lesson:t,chapter:o})=>void 0!==e.progress[n]&&(void 0!==e.progress[n][t]&&e.progress[n][t][o]),O=(e,{course:n,lesson:t})=>void 0===e.progress[n]||void 0===e.progress[n][t]?{}:e.progress[n][t],B=(e,{course:n})=>void 0===e.progress[n]?{}:e.progress[n];var z=t(3),R=t(1196);const F=Object(o.a)(R.a,{target:"e134ujks0"})("color:",Object(a.prop)("theme.gray0"),";padding:16px;margin:0;");const{useState:U}=s,Q=Object(o.a)(a.Box,{target:"evasvyc0"})({name:"14nzdtj",styles:"display:grid;grid:'header' auto 'solution' 1fr / auto;grid-gap:0;min-height:0;max-height:480px;width:100%;"}),P=Object(o.a)(a.Box,{target:"evasvyc1"})({name:"1vbobq5",styles:"display:grid;grid-auto-flow:column;grid-auto-columns:auto;grid-gap:0;overflow-x:auto;justify-content:start;"}),W=Object(o.a)(F,{target:"evasvyc2"})({name:"145nu0c",styles:"min-height:0;overflow-y:auto;overflow-x:hidden;padding:0;&&& pre{margin:0;}"}),Y=e=>v(e).files.filter(e=>void 0!==e.initial),q=e=>{var{selected:n}=e,t=Object(z.__rest)(e,["selected"]);const[o,r]=U(Y(n)[0].path),i=Y(n).find(e=>e.path===o);return void 0===i&&r(Y(n)[0].path),s.createElement(Q,Object.assign({},t),s.createElement(P,null,Y(n).map((e,n)=>s.createElement(a.FileTab,{key:e.path,"data-test":"docs-solution-file-tab-"+e.path,first:0===n,selected:e.path===o,file:{path:e.path,writable:!1},onClick:()=>r(e.path),omitReadOnly:!0}))),s.createElement(W,{"data-test":"docs-solution-markdown",source:`\`\`\`typescript\n${void 0===i?"":i.solution}\`\`\``}))};var G=t(75);const H=a.Button.withComponent(G.a,{target:"e85241m0"}),Z=Object(c.b)(void 0,(e,{selected:n,complete:t,onClick:o})=>({onClick:()=>{t||e(C(n)),o()}}))(e=>{var{selected:n,onClick:t,complete:o}=e,a=Object(z.__rest)(e,["selected","onClick","complete"]);const r=(e=>g(e).chapters[e.chapter+1])(n),i=(e=>y(e).lessons[e.lesson+1])(n);let c,d;return void 0!==r?(c=f(n.course,n.lesson,n.chapter+1),d=o?"Next":"Skip"):void 0!==i?(c=p(n.course,n.lesson+1),d=o?"Next":"Skip"):(c="/course",d=o?"Complete Course":"Skip"),s.createElement(H,Object.assign({},a,{"data-test":"next-button",to:c,onClick:t}),d)}),J=a.Button.withComponent(G.a,{target:"e4dl1ge0"}),_=e=>{var{selected:n,onClick:t}=e,o=Object(z.__rest)(e,["selected","onClick"]);const a=(e=>g(e).chapters[e.chapter-1])(n),r=(e=>y(e).lessons[e.lesson-1])(n);let i;if(void 0!==a)i=f(n.course,n.lesson,n.chapter-1);else{if(void 0===r)return null;i=f(n.course,n.lesson-1,r.chapters.length-1)}return s.createElement(J,Object.assign({},o,{"data-test":"previous-button",to:i,onClick:t}),"Back")};const V=Object(o.a)(a.DispatchWrapper,{target:"ekxo5mf0"})("display:grid;grid:'solution' auto 'footer' auto / auto;grid-gap:0;min-height:0;border-top:1px solid ",Object(l.prop)("theme.gray5"),";"),$=Object(o.a)(a.DispatchWrapper,{target:"ekxo5mf1"})({name:"1d1goq5",styles:"display:grid;grid-gap:8px;padding:8px;grid-auto-flow:column;grid-auto-columns:auto;"}),X=Object(o.a)($,{target:"ekxo5mf2"})({name:"x4dmss",styles:"justify-content:space-between;"}),K=Object(o.a)($,{target:"ekxo5mf3"})({name:"k1xozo",styles:"justify-content:start;"}),ee=Object(o.a)($,{target:"ekxo5mf4"})({name:"1b1rfkc",styles:"justify-content:end;"}),ne=Object(o.a)(a.Hidden,{target:"ekxo5mf5"})({name:"1ndmg0m",styles:"display:flex;min-height:0;"}),te=Object(c.b)((e,{selected:n})=>({complete:L(e,n)}))(e=>{var{selected:n,complete:t}=e,o=Object(z.__rest)(e,["selected","complete"]);const{visible:r,hide:i,toggle:c}=Object(a.useHidden)();return s.createElement(V,null,s.createElement(ne,{visible:r,unmount:!0},s.createElement(q,{selected:n})),s.createElement(X,Object.assign({},o),s.createElement(K,null,s.createElement(_,{selected:n,onClick:i})),s.createElement(ee,null,s.createElement(a.Button,{"data-test":"docs-footer-solution-button",onClick:c},r?"Hide":"Show"," Solution"),s.createElement(Z,{selected:n,onClick:i,complete:t}))))}),oe=Object(o.a)(a.Box,{target:"elumtle0"})("display:grid;background-color:",Object(a.prop)("theme.black"),";grid-template:'docs' 1fr 'footer' auto / auto;grid-gap:0;min-height:0;min-width:0;"),ae=Object(o.a)(F,{target:"elumtle1"})("background-color:",Object(a.prop)("theme.black"),";min-height:0;overflow-y:auto;overflow-x:hidden;"),re=e=>{var{selected:n}=e,t=Object(z.__rest)(e,["selected"]);return s.createElement(oe,Object.assign({},t),s.createElement(ae,{source:v(n).documentation,openAllLinksInNewTab:!0,resetScroll:!0}),s.createElement(te,{selected:n}))};var se=t(1173);const ie=e=>v(e).files.some(e=>"public/index.html"===e.path),ce=Object(c.b)(void 0,(e,{selected:n})=>({onTestsPass:()=>e(C(n))}))(e=>{var{selected:n,onTestsPass:t}=e,o=Object(z.__rest)(e,["selected","onTestsPass"]);const a=ie(n);return s.createElement(se.a,Object.assign({},o,{id:f(n.course,n.lesson,n.chapter),createPreviewURL:()=>"http://localhost:8080",initialFiles:v(n).files.map(e=>({path:e.path,content:void 0===e.initial?e.solution:e.initial,writable:void 0!==e.initial,open:!0})),initialOptions:{preview:{enabled:a,open:a}},build:a,onTestsPass:t}))});const de=Object(o.a)(a.Box,{target:"ef43y2m0"})("background-color:",Object(a.switchProp)("bg",{current:Object(a.prop)("theme.primaryDark"),complete:Object(a.prop)("theme.primary"),incomplete:Object(a.prop)("theme.accent")}),";height:100%;display:block;"),le=de.withComponent(G.a,{target:"ef43y2m4"}),ue=Object(o.a)(a.Box,{target:"ef43y2m1"})({name:"1bx5ylf",styles:"display:block;position:relative;"}),me=Object(o.a)(a.Tooltip,{target:"ef43y2m2"})({name:"epvm6",styles:"white-space:nowrap;"}),pe=Object(o.a)(a.Box,{target:"ef43y2m3"})({name:"szci25",styles:"display:grid;grid-auto-flow:column;gap:4px;height:8px;"}),he=s.memo(({title:e})=>s.createElement(me,{placement:"bottom"},s.createElement(a.TooltipArrow,null),e)),fe=s.memo(({idx:e,items:n,item:t,isCurrent:o})=>s.createElement(ue,null,o||t.complete||0===e||n[e-1].complete?s.createElement(le,{to:t.to,key:e,bg:o?"current":t.complete?"complete":"incomplete"}):s.createElement(de,{key:e,bg:"incomplete"}),s.createElement(he,{title:t.title}))),we=({current:e,items:n})=>s.createElement(pe,null,n.map((t,o)=>s.createElement(fe,{key:o,idx:o,item:t,isCurrent:o===e,items:n}))),be=Object(c.b)((e,{slug:n,index:t})=>({progress:O(e,{course:n,lesson:t})}))(({slug:e,index:n,current:t,lesson:o,progress:a})=>s.createElement(we,{current:t,items:o.chapters.map((t,o)=>({complete:a[o],title:h(t.title,o),to:f(e,n,o)}))})),ye=({selected:e})=>s.createElement(be,{current:e.chapter,slug:e.course,index:e.lesson,lesson:g(e)});const ge=Object(o.a)(a.Box,{target:"e1qa2yid0"})({name:"1tqk0gj",styles:"display:grid;overflow:hidden;height:calc(100vh - 56px);width:100%;grid:'progress' 8px 'pane' 1fr / 100%;"}),ve=Object(o.a)(a.Box,{target:"e1qa2yid1"})({name:"lyoaix",styles:"grid-area:progress;"}),xe=Object(c.b)((e,{selected:n})=>({progress:O(e,n)}))(({selected:e,progress:n})=>{if(!(0===e.chapter||n[e.chapter-1])){const t=0===Object.keys(n).length?0:Math.max(...Object.keys(n).map(e=>parseInt(e,10)))+1;return s.createElement(r.Redirect,{to:f(e.course,e.lesson,t)})}return s.createElement(ge,null,s.createElement(u.a,{title:`Lesson ${e.lesson+1} Chapter ${e.chapter+1}: ${v(e).title} - NEO•ONE`}),s.createElement(ve,null,s.createElement(ye,{selected:e})),s.createElement(a.SplitPane,{initialSize:ie(e)?.33:.4,type:"lr",left:s.createElement(re,{selected:e}),right:s.createElement(ce,{selected:e})}))});var Ae=t(1124),ke=t.n(Ae);const Te=Object(o.a)(a.Image,{target:"e10jvl2u0"})({name:"4tnojn",styles:"height:80px;"}),Ne=e=>s.createElement(Te,Object.assign({src:ke.a,alt:"Wake up NEO"},e));var Me=t(312);const Ee=Object(o.a)(a.Box,{target:"ec4qkt0"})("display:grid;background-color:",Object(a.switchProp)("bg",{light:Object(a.prop)("theme.gray0"),darkLight:Object(a.prop)("theme.gray2"),gray5:Object(a.prop)("theme.gray5"),dark:Object(a.prop)("theme.black")}),";color:",Object(a.switchProp)("bg",{dark:Object(a.prop)("theme.gray0"),light:Object(a.prop)("theme.gray6"),darkLight:Object(a.prop)("theme.gray6"),gray5:Object(a.prop)("theme.gray0")}),";padding:16px;width:100%;justify-items:center;@media (max-width:",Object(a.prop)("theme.breakpoints.md"),"){padding:8px;}"),Se=Object(o.a)(a.Link,{target:"eejif6g0"})(Object(l.prop)("theme.fontStyles.subheading"),";"),Ie=Object(o.a)(a.Box,{target:"eejif6g1"})(Object(l.prop)("theme.fonts.axiformaRegular"),";",Object(l.prop)("theme.fontStyles.subheading"),";color:",Object(l.prop)("theme.black"),";"),Ce=Object(o.a)(a.H2,{target:"eejif6g2"})(Object(l.prop)("theme.fonts.axiformaRegular")," ",Object(l.prop)("theme.fontStyles.headline")," color:",Object(l.prop)("theme.black"),";margin:0;"),De=Object(o.a)(a.Box,{target:"eejif6g3"})("display:grid;grid-gap:16px;padding:32px;max-width:","960px",";"),je=()=>s.createElement(Ee,{bg:"darkLight"},s.createElement(De,null,s.createElement(Ce,null,"What are NEO•ONE Courses?"),s.createElement(Ie,null,"NEO•ONE Courses are a free, interactive code school that teach you to build decentralized applications on NEO."),s.createElement(Ie,null,"Build, test and write the UI for smart contracts with the NEO•ONE editor. NEO•ONE Courses distill the essentials of dapp development into bite-sized interactive learning chapters."),s.createElement(Ie,null,"The first course is designed for beginners to NEO•ONE and starts off with the basics. Each course builds on the knowledge gained in the previous ones."),s.createElement(Ie,null,"The courses assume some knowledge of blockchain and NEO concepts, though you don't need to be an expert. Reading through the"," ",s.createElement(Se,{linkColor:"primary",href:"/docs/blockchain-basics",target:"_blank"},"Blockchain Basics")," ","chapter of the main guide will sufficiently prepare you for the course.")));var Le=t(1142);const Oe=e=>{if(!e)return 0;const n=e/36;return Math.round(10*(4+15*n**.25+n/5))},Be=Object(o.a)("div",{target:"e1dbnb0w0"})("height:",Object(l.ifProp)("entered","auto","0"),";overflow:",Object(l.ifProp)("entered","unset","hidden"),";transition:height 300ms cubic-bezier(0.4,0,0.2,1);"),ze=Object(o.a)("div",{target:"e1dbnb0w1"})({name:"h0sct3",styles:"display:'flex';"}),Re=Object(o.a)("div",{target:"e1dbnb0w2"})({name:"8atqhb",styles:"width:100%;"});class Fe extends i.a.Component{constructor(){super(...arguments),this.handleEnter=e=>{e.style.height=0},this.handleEntering=e=>{const n=this.wrapperRef?this.wrapperRef.clientHeight:0,t=Oe(n);e.style.transitionDuration=t+"ms",this.autoTransitionDuration=t,e.style.height=n+"px"},this.handleEntered=e=>{e.style.height="auto"},this.handleExit=e=>{const n=this.wrapperRef?this.wrapperRef.clientHeight:0;e.style.height=n+"px"},this.handleExiting=e=>{const n=this.wrapperRef?this.wrapperRef.clientHeight:0,t=Oe(n);e.style.transitionDuration=t+"ms",this.autoTransitionDuration=t,e.style.height=0},this.addEndListener=(e,n)=>{this.timer=setTimeout(n,this.autoTransitionDuration||0)}}componentWillUnmount(){clearTimeout(this.timer)}render(){return i.a.createElement(Le.a,{onEnter:this.handleEnter,onEntered:this.handleEntered,onEntering:this.handleEntering,onExit:this.handleExit,onExiting:this.handleExiting,addEndListener:this.addEndListener,in:this.props.visible,timeout:{}},(e,n)=>i.a.createElement(Be,Object.assign({entered:"entered"===e},n),i.a.createElement(ze,{ref:e=>{this.wrapperRef=e}},i.a.createElement(Re,null,this.props.children))))}}var Ue=t(1126),Qe=t.n(Ue);const Pe=e=>s.createElement(a.Image,Object.assign({src:Qe.a,alt:"05"},e));var We=t(1127),Ye=t.n(We);const qe=e=>s.createElement(a.Image,Object.assign({src:Ye.a,alt:"05"},e));var Ge=t(1128),He=t.n(Ge);const Ze=e=>s.createElement(a.Image,Object.assign({src:He.a,alt:"05"},e));var Je=t(1133),_e=t.n(Je);var Ve=t(1132),$e=t.n(Ve);var Xe=t(1129),Ke=t.n(Xe);var en=t(1131),nn=t.n(en);var tn=t(1130),on=t.n(tn);const an=[e=>s.createElement(a.Image,Object.assign({src:Ke.a,alt:"01"},e)),e=>s.createElement(a.Image,Object.assign({src:on.a,alt:"02"},e)),e=>s.createElement(a.Image,Object.assign({src:nn.a,alt:"03"},e)),e=>s.createElement(a.Image,Object.assign({src:$e.a,alt:"04"},e)),e=>s.createElement(a.Image,Object.assign({src:_e.a,alt:"05"},e))],rn=e=>{var{num:n}=e,t=Object(z.__rest)(e,["num"]);const o=an[n];return s.createElement(o,Object.assign({},t))};const sn=Object(o.a)(a.Box,{target:"e1g14a5e0"})({name:"jjpzau",styles:"display:grid;grid-gap:8px;grid:'title' auto 'progress' auto / auto;"}),cn=Object(o.a)(a.ButtonBase.withComponent(G.a,{target:"e1g14a5e2"}),{target:"e1g14a5e1"})("width:100%;",Object(l.prop)("theme.fontStyles.headline"),";",Object(l.prop)("theme.fonts.axiformaMedium"),";cursor:pointer;&&&{text-decoration:none;}&:hover{color:",Object(l.prop)("theme.primaryDark"),";text-decoration:none;}"),dn=({slug:e,lesson:n,index:t})=>s.createElement(sn,null,s.createElement(cn,{to:p(e,t),"data-test":`${e}-lesson-${t}`},"Lesson ",t+1,": ",n.title),s.createElement(be,{slug:e,index:t,lesson:n}));const ln=Object(o.a)(a.Box,{target:"e1s8hkiy0"})({name:"1fjcpzr",styles:"display:grid;grid-gap:8px;"}),un=e=>{var{slug:n,lessons:t}=e,o=Object(z.__rest)(e,["slug","lessons"]);return s.createElement(ln,Object.assign({},o),t.map((e,t)=>s.createElement(dn,{key:t,slug:n,index:t,lesson:e})))};const mn={contract:Object(o.a)(Pe,{target:"e1ugira30"})({name:"4yxxwq",styles:"display:block;height:100%;"}),debugging:Object(o.a)(qe,{target:"e1ugira31"})({name:"4yxxwq",styles:"display:block;height:100%;"}),client:Object(o.a)(Ze,{target:"e1ugira32"})({name:"4yxxwq",styles:"display:block;height:100%;"})},pn=Object(o.a)(a.Box,{target:"e1ugira33"})("display:grid;gap:16;width:100%;max-width:","960px",";grid:'image text' auto / auto minmax(480px,1fr);"),hn=Object(o.a)(a.Box,{target:"e1ugira34"})({name:"necw7p",styles:"display:flex;height:136px;width:100%;align-items:center;"}),fn=["light","gray5","darkLight"],wn=Object(o.a)(a.Button,{target:"e1ugira35"})({name:"sd4gz7",styles:"grid-area:button;place-self:center;&&&{text-decoration:none;cursor:pointer;outline:none;}"}),bn=Object(o.a)(a.Box,{target:"e1ugira36"})(Object(a.prop)("theme.fontStyles.headline"),";",Object(a.prop)("theme.fonts.axiformaRegular"),";"),yn=Object(o.a)(a.Box,{target:"e1ugira37"})(Object(a.prop)("theme.fontStyles.subheading"),";",Object(a.prop)("theme.fonts.axiformaMedium"),";"),gn=Object(o.a)(un,{target:"e1ugira38"})({name:"8atqhb",styles:"width:100%;"}),vn=Object(o.a)(rn,{target:"e1ugira39"})({name:"1320mgo",styles:"display:block;height:80%;"}),xn=Object(o.a)(a.Box,{target:"e1ugira310"})({name:"zowza4",styles:"display:grid;grid:'title' auto 'text' auto / auto;grid-gap:8px;"}),An=Object(o.a)(a.Box,{target:"e1ugira311"})("display:grid;grid:",Object(a.prop)("template"),";gap:8;"),kn=Object(o.a)(a.Box,{target:"e1ugira312"})({name:"1iik6sc",styles:"grid-area:text;"}),Tn=Object(o.a)(a.Box,{target:"e1ugira313"})({name:"lyoaix",styles:"grid-area:progress;"}),Nn=Object(o.a)(a.Box,{target:"e1ugira314"})({name:"rtrk04",styles:"grid-area:list;"}),Mn=(e,n,t)=>void 0!==t[n]&&e.chapters.every((e,o)=>t[n][o]),En=Object(c.b)((e,{slug:n})=>({progress:B(e,{course:n})}))(({slug:e,course:n,index:t,progress:o})=>{const r=mn[n.image],i=fn[t%fn.length],{visible:c,toggle:d}=Object(a.useHidden)(0===t);return s.createElement(Ee,{bg:i},s.createElement(pn,null,s.createElement(hn,null,s.createElement(vn,{num:t}),s.createElement(r,null)),s.createElement(An,{template:'\n  "text button" auto\n  "progress empty" auto\n  "list empty" auto\n  / 1fr 160px\n'},s.createElement(kn,null,s.createElement(xn,null,s.createElement(bn,null,n.title),s.createElement(yn,null,n.description))),s.createElement(Tn,null,s.createElement(we,{items:n.lessons.map((n,t)=>({complete:Mn(n,t,o),title:m(n.title,t),to:p(e,t)}))})),s.createElement(wn,{onClick:d},c?"Hide":"Show"," Lessons"),s.createElement(Nn,null,s.createElement(Fe,{visible:c},s.createElement(gn,{slug:e,lessons:n.lessons}))))))});const Sn=Object(o.a)(a.Background,{target:"e1vy6eco0"})("display:flex;color:",Object(l.prop)("theme.gray0"),";justify-content:center;min-height:240px;width:100%;"),In=Object(o.a)(a.Box,{target:"e1vy6eco1"})("color:",Object(l.prop)("theme.gray0"),";",Object(l.prop)("theme.fontStyles.display1"),";",Object(l.prop)("theme.fonts.axiformaRegular"),";"),Cn=Object(o.a)(a.Box,{target:"e1vy6eco2"})({name:"vqybsi",styles:"display:grid;max-width:1100px;margin:56px;gap:24;grid-template-columns:repeat(auto-fill,minmax(480px,1fr));justify-content:start;align-content:start;justify-items:start;align-items:start;width:100%;"}),Dn=Object(o.a)(a.Box,{target:"e1vy6eco3"})({name:"j7qwjs",styles:"display:flex;flex-direction:column;"}),jn=Object(o.a)(a.Box,{target:"e1vy6eco4"})({name:"j7qwjs",styles:"display:flex;flex-direction:column;"}),Ln=e=>s.createElement(jn,Object.assign({},e),s.createElement(Sn,null,s.createElement(Cn,null,s.createElement(Ne,null),s.createElement(In,null,"Learn to Build NEO DApps with NEO•ONE."))),s.createElement(Dn,null,s.createElement(je,null),Object.entries(b).map(([e,n],t)=>s.createElement(En,{key:e,index:t,slug:e,course:n}))),s.createElement(Me.a,null));const On=Object(o.a)(a.Box,{target:"e4zswyj0"})({name:"v2kfba",styles:"height:100%;width:100%;"}),Bn=Object(o.a)(a.Box,{target:"e4zswyj1"})("display:grid;background-color:",Object(l.prop)("theme.gray6"),";padding-top:64px;padding-bottom:128px;width:100%;place-items:center;place-content:center;"),zn=Object(o.a)(a.Box,{target:"e4zswyj2"})("display:grid;background-color:",Object(l.prop)("theme.black"),";max-width:720px;margin:16px;box-shadow:0 6px 4px 4px rgba(0,0,0,0.2);"),Rn=Object(o.a)(a.Button.withComponent(G.a,{target:"e4zswyj6"}),{target:"e4zswyj3"})({name:"1cmcek7",styles:"text-decoration:none;cursor:pointer;border-radius:16px;"}),Fn=Object(o.a)(a.Box,{target:"e4zswyj4"})("display:grid;color:",Object(l.prop)("theme.gray0"),";background-color:",Object(l.prop)("theme.gray4"),";grid-auto-flow:column;align-items:center;justify-content:end;justify-items:end;grid-gap:16px;padding:8px;"),Un=Object(o.a)(a.Box,{target:"e4zswyj5"})(Object(l.prop)("theme.fontStyles.headline"),";"),Qn=({selected:e})=>s.createElement(On,null,s.createElement(u.a,{title:`Lesson ${e.lesson+1}: ${g(e).title} - NEO•ONE`}),s.createElement(Bn,null,s.createElement(zn,null,s.createElement(F,{source:g(e).documentation,openAllLinksInNewTab:!0}),s.createElement(Fn,null,s.createElement(Un,null,"Lesson ",e.lesson+1,": ",g(e).title),s.createElement(Rn,{"data-test":"start",to:`/course/${e.course}/${e.lesson+1}/1`},"Start")))),s.createElement(Me.a,null)),{store:Pn,persistor:Wn}=(()=>{const e=Object(T.c)(Object(N.a)({key:"root",storage:j},D));return{store:e,persistor:Object(N.b)(e)}})(),Yn=e=>s.createElement(r.Redirect,{to:"course"}),qn=e=>s.createElement(Ln,null),Gn=({course:e,lesson:n})=>void 0===e||void 0===n?s.createElement(r.Redirect,{to:"course"}):s.createElement(Qn,{selected:{course:e,lesson:parseInt(n,10)-1}}),Hn=({course:e,lesson:n,chapter:t})=>void 0===e||void 0===n||void 0===t?s.createElement(r.Redirect,{to:"course"}):s.createElement(xe,{selected:{course:e,lesson:parseInt(n,10)-1,chapter:parseInt(t,10)-1}}),Zn=Object(o.a)(a.Box,{target:"ei0971x0"})("@media (max-width:",Object(l.prop)("theme.breakpoints.sm"),"){display:none;}"),Jn=Object(o.a)(a.Box,{target:"ei0971x1"})("display:none;@media (max-width:",Object(l.prop)("theme.breakpoints.sm"),"){display:grid;grid-gap:32px;padding:16px;}"),_n=Object(o.a)("h1",{target:"ei0971x2"})(Object(l.prop)("theme.fonts.axiformaBold")," ",Object(l.prop)("theme.fontStyles.headline")," color:",Object(l.prop)("theme.gray0"),";margin:0;"),Vn=Object(o.a)(a.Box,{target:"ei0971x3"})(Object(l.prop)("theme.fonts.axiformaRegular")," ",Object(l.prop)("theme.fontStyles.subheading")," color:",Object(l.prop)("theme.gray0"),";margin:0;"),$n=()=>s.createElement(s.Fragment,null,s.createElement(Zn,null,s.createElement(c.a,{store:Pn},s.createElement(d.a,{loading:s.createElement(a.Loading,null),persistor:Wn},s.createElement(r.Router,null,s.createElement(qn,{path:"course"}),s.createElement(Gn,{path:"course/:course/:lesson"}),s.createElement(Hn,{path:"course/:course/:lesson/:chapter"}),s.createElement(Yn,{default:!0}))))),s.createElement(Jn,null,s.createElement(_n,null,"Uh oh!"),s.createElement(Vn,null,"Looks like you're trying to start the NEO•ONE Courses from a mobile device. NEO•ONE Courses are an interactive learning experience designed for desktops and laptops. Come back with your laptop or desktop to experience NEO•ONE development.")))}}]);
//# sourceMappingURL=App.c81e5a64.js.map