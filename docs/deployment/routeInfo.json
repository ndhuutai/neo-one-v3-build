{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/deployment","title":"Deployment","content":{"type":"markdown","value":"\nYou've built your smart contract, tested it and built a dapp around it. Now it's time to deploy.\n\nProductionizing your smart contract for deployment to a network other than your local network requires keeping a few things in mind which we will cover in this chapter.\n\n---\n\n[[toc]]\n\n---\n\n## Deployment Specifics\n\n### Properties\n\nSmart contracts may specify an instance property called `properties` to specify some or all of the properties used during deployment:\n\n```typescript\nexport class Contract extends SmartContract {\n  public readonly properties = {\n    codeVersion: '1.0',\n    author: 'Alex DiCarlo',\n    email: 'foo@bar.com',\n    description: 'This Contract is the best one.',\n  };\n}\n```\n\nThese properties have no impact on the execution of the contract, they're simply extra metadata that you may permanently attach to the contract on the blockchain.\n\n### Upgrade\n\nEvery NEO•ONE smart contract automatically contains a public `upgrade` method. This method replaces the smart contract code as well as the static metadata associated with the contract while preserving the smart contract's storage. In other words, this method can be used to change the logic of your smart contract without losing the data.\n\nIn order to make it possible to upgrade your contract, you _must_ specify the `approveUpgrade` `public` method. This method should return a `boolean` indicating if the `upgrade` is approved:\n\n```typescript\nexport class Contract extends SmartContract {\n  public constructor(public readonly owner = Deploy.senderAddress) {}\n\n  public approveUpgrade(): boolean {\n    return Address.isCaller(this.owner);\n  }\n}\n```\n\nUsing `Address.isCaller(this.owner)` is the most typical approach.\n\n::: warning\n\nNote\n\nIf you do not specify the `approveUpgrade` method, it is impossible for you or anyone else to `upgrade` the contract.\n\n:::\n\n### Destroy\n\nAll smart contracts have a `protected` method called `destroy` which any method may use to permanently delete the smart contract. Once `destroy` is called the smart contract can no longer be invoked and the storage is no longer accessible. You're not required to have a method that calls `destroy`, but if you do, it should probably look something like:\n\n```typescript\nexport class Contract extends SmartContract {\n  public constructor(public readonly owner = Deploy.senderAddress) {}\n\n  public permanentlyDestroy(): boolean {\n    if (!Address.isCaller(this.owner)) {\n      return false;\n    }\n\n    this.destroy();\n\n    return true;\n  }\n}\n```\n\n::: warning\n\nNote\n\nWhile the contract can no longer be invoked and the storage is not accessible, all of the past invocations still exist on the blockchain. The storage can still be accessed by replaying the blockchain from the beginning up until the point it was destroyed.\n\n:::\n\n---\n\n### Migration File\n\nTo deploy your contract to a network, you will need to define a `migration` file. The default location for this file is `neo-one/migration.ts`, but it can be [configured](/docs/config-options). A migration file simply exports a function to call the deploy method on your smart contracts with the appropriate arguments. It should look something like this:\n\n```typescript\nimport BigNumber from 'bignumber.js';\nimport { MigrationContracts } from '../src/neo-one';\n\nexport default ({ token, ico, escrow }: MigrationContracts, _network: string) => {\n  token.deploy();\n  ico.deploy(undefined, new BigNumber(1566864121), undefined);\n  escrow.deploy();\n};\n```\n\n### MigrationSmartContract\n\nYou may have noticed the new type we use in the above `migration` file, `MigrationContracts`. This is another type generated by NEO•ONE for use specifically in `migration` files and while it looks the same as its counterpart `SmartContract` it has a key difference in that there is no `.confirmed(...)` properties for any of its contract methods. This is because during migration _every_ contract invocation will be be awaited before proceeding to this next invocation. This can be useful when you would like to deploy contracts in series or if you would like to do some additional bootstrapping after the deployment of a contract.\n\nAs an example, lets say you have an ICO contract and you would like to make sure you are the first person to mint a portion of the tokens. Then, going off the migration file above, we could run something like:\n\n```typescript\nimport BigNumber from 'bignumber.js';\nimport { Hash256 } from '@neo-one/client';\nimport { MigrationContracts } from '../src/neo-one';\n\nexport default ({ token, ico, escrow }: MigrationContracts, _network: string) => {\n  token.deploy();\n  // here we set the startTime of the ICO to be immediate\n  ico.deploy(undefined, new BigNumber(0), undefined);\n  ico.mintTokens([{ amount: new BigNumber(10), asset: Hash256.NEO }]);\n  escrow.deploy();\n};\n```\n\nThis will ensure that after deploying the `ico` contract (and confirming it is deployed) the next action before deploying the `escrow` contract is to mint some of the ICO tokens to the currently selected `UserAccount`. While a more elegant and safe solution might be to allow the owner of the ICO to mint tokens before the timer has started this should make it clear how you can bootstrap a contract during migration.\n\n## Deploying to a Public Network\n\nOnce you have successfully configured your `migration` file as explained above you are all set to deploy your Smart Contract! Using the set of [networks](/docs/config-options) defined in `.neo-one.config.js` you can deploy using the command:\n\n```bash\nyarn neo-one deploy --network <network>\n```\n\nwhere `network` is one of the keys provided by your configuration. By default `yarn neo-one deploy` will use the `test` key.\n\n::: warning\n\nNote\n\nWe HIGHLY recommend deploying to both a local private network _and_ the Neo TestNet before attempting to deploy to the MainNet.\n\n:::\n"},"link":"packages/neo-one-website/docs/1-main-concepts/12-deployment.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/native-assets","title":"Native Assets"},"previous":{"slug":"/docs/dapps","title":"Decentralized Apps"}},"path":"docs/deployment"}
