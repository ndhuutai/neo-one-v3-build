{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/properties-and-storage","title":"Properties and Storage","content":{"type":"markdown","value":"\nNEO•ONE stores persistent data in the class properties of the smart contract.\n\n---\n\n[[toc]]\n\n---\n\n## Properties and Accessors\n\nUsing the mental model of a singleton instance of our smart contract, it becomes clear that all properties of the smart contract are automatically persisted between invocations of the smart contract, just like a normal class instance. In TypeScript we can declare several types of instance properties of a class - [private, protected, public and readonly](https://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers). The following example explores each of these:\n\n```typescript\nexport class HelloWorld extends SmartContract {\n  public mutableString = 'goodnightMoon';\n  public readonly string = 'goodnightMoon';\n  protected mutableNumber = 0;\n  protected readonly number = 0;\n  private mutableBoolean = true;\n  private readonly boolean = true;\n}\n```\n\nEach property uses the property initializer syntax which sets the initial value at construction.\n\nOne thing to consider in the mental model of smart contracts is that at a low-level smart contracts only have methods. So when we define a `public` `readonly` property, it will be translated to a method of the same name that takes no arguments and returns the current value of the property. A `public` mutable property, like `mutableString` above, will translate to two methods, a method of the same name that takes no arguments and returns the current value of the property and a method called `set<property>` that takes one argument and sets the value of that property to the argument. For example, `mutableString` will translate to `mutableString` and `setMutableString` methods.\n\n[Property accessors](https://www.typescriptlang.org/docs/handbook/classes.html#accessors) work identically to properties in terms of the low-level translation to exposed smart contract methods.\n\n::: warning\n\nNote\n\nProperties declared as `protected` or `private` are only \"private\" within the scope of TypeScript - all NEO smart contracts have fully public storage, so no property is ever truly private. In other words, do not store sensitive data within a `private` property with the expectation that no one can view it\n\n:::\n\n---\n\n## Structured Storage\n\nProperties work well for storing primitive values and while you can use an `Array`, `Set` or `Map` as a property for storing structured data, this will store the entire container in a single key in smart contract storage. This is not very efficient, so instead NEO•ONE offers similarly named `ArrayStorage`, `SetStorage` and `MapStorage` classes. These classes are special in that they may only be used as properties of a smart contract class:\n\n```typescript\nexport class HelloWorld extends SmartContract {\n  private readonly mapStorage = MapStorage.for<string, number>();\n  private readonly setStorage = SetStorage.for<string>();\n  private readonly arrayStorage = ArrayStorage.for<string>();\n}\n```\n\nNotice that we construct the structured storage classes using the [static](https://www.typescriptlang.org/docs/handbook/classes.html#static-properties) `for` method and 1-2 [type parameters](https://www.typescriptlang.org/docs/handbook/generics.html), which makes it read as \"<structured storage> for <type>\". For example, the `mapStorage` property is a \"MapStorage for string to number\".\n\nAside from the limitations mentioned above, each of the structured storage classes work identically to their `Array`, `Set` and `Map` counterparts.\n\n---\n\n## Storage Types\n\nThe only limitation on storage types is that you cannot use an instance of a class or a functon. This is because we cannot reliably serialize and deserialize arbitrary instances when we store the values in the underlying smart contract storage. For similar reasons, we cannot store arbitrary functions. However, you may declare a `readonly` property that is a function. This can be useful for declaring event notifiers as properties of the class:\n\n```typescript\nexport class Contract extends SmartContract {\n  private readonly notifyTransfer = createEventNotifier<Address | undefined, Address | undefined, Fixed<8>>(\n    'transfer',\n    'from',\n    'to',\n    'amount',\n  );\n}\n```\n\nWe'll learn more about event notifiers in a later chapter of the guide.\n"},"link":"packages/neo-one-website/docs/1-main-concepts/04-properties-and-storage.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/methods","title":"Methods"},"previous":{"slug":"/docs/standard-library","title":"Standard Library"}},"path":"docs/properties-and-storage"}
