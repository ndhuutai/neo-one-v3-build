{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/standard-library","title":"Standard Library","content":{"type":"markdown","value":"\nNEO•ONE includes a library of standard smart contract values, functions, interfaces and classes.\n\nThis chapter will go into detail on some of the more common values and types that we will use throughout the guide. While working through the rest of the chapters you may want to keep this page handy.\n\nFor more details, check out the [Smart Contract](/reference/@neo-one/smart-contract) reference.\n\n---\n\n[[toc]]\n\n---\n\n## Value Types\n\nThe standard library includes several specialized value types which are defined in a way that makes them difficult to use incorrectly. For example, it's a static compile time error to pass an `Address` where a `Hash256` is expected, even though both are really just [`Buffer`s](https://nodejs.org/api/buffer.html) underneath the hood.\n\n- `Address` - a `Buffer` that represents a NEO address.\n- `Hash256` - a `Buffer` that represents a NEO 256 bit hash, most commonly used for asset ids like `NEO` or `GAS` asset ids.\n- `PublicKey` - a `Buffer` that represents a public key.\n\nEach of the value types can be created from a string literal using the `from` [static method](https://www.typescriptlang.org/docs/handbook/classes.html#static-properties), for example, `Address.from('APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR')`. `Hash256` also contains static properties for the `NEO` and `GAS` `Hash256` values.\n\nThe `Address` type has a commonly used static method, `isCaller`, which is used to check that the passed `Address` directly called and approved the current method invocation.\n\n```typescript\nAddress.isCaller(address);\n```\n\n`Address.isCaller` should be used whenever you want to take an action for a given `Address`. For example, you would want to check `Address.isCaller(address)` before transferring tokens from the `address` to another party.\n\n---\n\n## Tagged Types\n\nTagged types are the same as their underlying type, but we've \"tagged\" them with a piece of compile-time data. NEO•ONE currently contains two tagged types, and their tags are used exclusively for generating the corresponding NEO•ONE client APIs for the smart contract. The most common tagged type and the only one we'll use throughout the guide is the `Fixed` type.\n\nThe `Fixed<T>` type tags a `number` with the number of decimals that it represents. All `number`s in TypeScript smart contracts are integers since there are no floating point values in smart contracts. However, we typically consider the values we're working with to have decimals from the user's point of view and `Fixed<T>` helps capture that notion.\n\nFor example, the `Fixed<2>` type tells the NEO•ONE toolchain that the integer value represents a fixed point decimal with 2 places. In other words, when we have the value `1250` in a smart contract, it really means `12.50` to the user. The NEO•ONE toolchain uses this information to generate client APIs that automatically convert from the integer representation to the decimal point representation and visa-versa.\n\nThis makes it easy to do things like display the result of a smart contract method invocation that returns a `Fixed<2>`. Simply convert it to a string since the client APIs have already converted it to the decimal representation. Similarly, for dapp inputs, simply take the user's decimal value and pass it directly to the NEO•ONE client APIs, under the hood it will convert appropriately.\n\n---\n\n## Blockchain and Transaction Information\n\nThe `Blockchain` value contains several properties pertaining to the current state of the blockchain, the current transaction and the current invocation:\n\n- `Blockchain.currentBlockTime` - the timestamp of the `Block` that this `Transaction` will be included in.\n- `Blockchain.currentHeight` - index of the last `Block` persisted to the blockchain.\n- `Blockchain.currentTransaction` - the current `InvocationTransaction`.\n- `Blockchain.currentCallerContract` - the `Address` of the smart contract that directly invoked this contract. May be `undefined` if the current invocation was not from another smart contract.\n\n---\n\n## Opaque Tag Symbol\n\nIf you look at the definition file for the standard library, you might notice a property `OpaqueTagSymbol0`, `OpaqueTagSymbol1`, `one0` or `one1` that is present on all types, including global types like `Array` or `Map`. In order to emit the most efficient NEO VM bytecode possible, we have specialized implementations of all of the standard library types. One limitation of this approach, however, is that you must explicitly use the types. For example, you can't pass an `Array` where an `Array`-like but not `Array` interface is expected. Adding the `OpaqueTagSymbol0`, `OpaqueTagSymbol1`, `one0`, or `one1` properties helps enforce this as a static type error, but it does not catch all cases (though we're working on improving this).\n\nAs a rule of thumb, don't rely on [\"Duck Typing\"](https://en.wikipedia.org/wiki/Duck_typing), instead always be explicit about the types you're using.\n\n## JavaScript Semantics\n\nThe NEO•ONE compiler is as close to regular TypeScript as possible. But there are a few areas where our compiler does not exactly match normal JavaScript semantics. These areas almost never come up, but could cause strange behavior if you are expecting your Smart Contract code to behave exactly like JavaScript. One of those is when using native `Map`s and `Set`s. In normal JavaScript if you use a structural type as a key in a `Map` or a member in a `Set`, you can only retrieve that key/member later if it's the same reference. Trying to retrieve that key/member with the same value of a different reference will not work in regular JavaScript. But it WILL work in our compiler. The best way to demonstrate this is with examples.\n\n### `Set` Example\n\nThis test would pass in regular TS:\n\n```typescript\nconst x = new Set<ReadonlyArray<number>>();\nconst y = [0];\nconst z = [0];\nx.add(y).add(z);\n\nassertEqual(x.has(y), true);\nassertEqual(x.has(z), true);\nassertEqual(x.has([0]), false); // notice difference here\nassertEqual(x.size, 2); // notice difference here\n\nx.delete(y);\nassertEqual(x.delete(z), true); // notice difference here\nassertEqual(x.delete(z), false);\nassertEqual(x.size, 0);\nassertEqual(x.has(y), false);\nassertEqual(x.has(z), false);\n```\n\nBut this test will pass in our TS compiler:\n\n```typescript\nconst x = new Set<ReadonlyArray<number>>();\nconst y = [0];\nconst z = [0];\nx.add(y).add(z);\n\nassertEqual(x.has(y), true);\nassertEqual(x.has(z), true);\nassertEqual(x.has([0]), true); // notice difference here\nassertEqual(x.size, 1); // notice difference here\n\nx.delete(y);\nassertEqual(x.delete(z), false); // notice difference here\nassertEqual(x.delete(z), false);\nassertEqual(x.size, 0);\nassertEqual(x.has(y), false);\nassertEqual(x.has(z), false);\n```\n\n### `Map` Example\n\nThis test would pass in regular TS:\n\n```typescript\nconst x = new Map<ReadonlyArray<number>, string>();\nconst y = [0];\nconst z = [0];\nx.set(y, 'bar').set(z, 'baz');\n\nassertEqual(x.get(y), 'bar'); // notice difference here\nassertEqual(x.has(y), true);\nassertEqual(x.get(z), 'baz');\nassertEqual(x.has(z), true);\nassertEqual(x.get([0]), undefined); // notice difference here\nassertEqual(x.has([0]), false); // notice difference here\nassertEqual(x.size, 2); // notice difference here\n\nx.delete(y);\nassertEqual(x.delete(z), true); // notice difference here\nassertEqual(x.delete(z), false);\nassertEqual(x.size, 0);\nassertEqual(x.get(y), undefined);\nassertEqual(x.has(y), false);\nassertEqual(x.get(z), undefined);\nassertEqual(x.has(z), false);\n```\n\nBut this test will pass in our TS compiler:\n\n```typescript\nconst x = new Map<ReadonlyArray<number>, string>();\nconst y = [0];\nconst z = [0];\nx.set(y, 'bar').set(z, 'baz');\n\nassertEqual(x.get(y), 'baz'); // notice difference here\nassertEqual(x.has(y), true);\nassertEqual(x.get(z), 'baz');\nassertEqual(x.has(z), true);\nassertEqual(x.get([0]), 'baz'); // notice difference here\nassertEqual(x.has([0]), true); // notice difference here\nassertEqual(x.size, 1); // notice difference here\n\nx.delete(y);\nassertEqual(x.delete(z), false); // notice difference here\nassertEqual(x.delete(z), false);\nassertEqual(x.size, 0);\nassertEqual(x.get(y), undefined);\nassertEqual(x.has(y), false);\nassertEqual(x.get(z), undefined);\nassertEqual(x.has(z), false);\n```\n"},"link":"packages/neo-one-website/docs/1-main-concepts/03-standard-library.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/properties-and-storage","title":"Properties and Storage"},"previous":{"slug":"/docs/smart-contract-basics","title":"Smart Contract Basics"}},"path":"docs/standard-library"}
