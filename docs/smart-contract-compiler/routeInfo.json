{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/smart-contract-compiler","title":"Smart Contract Compiler","content":{"type":"markdown","value":"\n## How Can I Add New Features or Fix Bugs in the Smart Contract Compiler?\n\n### Basics of the Smart Contract Compiler\n\nThe NEO•ONE Smart Contract Compiler is by far the _largest_ NEO•ONE package. The compiler takes in (almost) regular\nTypeScript code and compiles it to [NeoVM](https://docs.neo.org/docs/en-us/basic/technology/neovm.html) bytecode, which can\nthen be deployed to the Neo blockchain and run on the NeoVM. NEO•ONE uses the TypeScript compiler API to parse the TypeScript code\ninto a tree of \"nodes\" with information about each node. Our compiler then \"visits\" each node and begins to output specific\nbytecode for the VM instructions that are needed in order to execute the logic that is specified by the TypeScript code.\nThe bytecode outputted by the compiler corresponds to human-readable opcodes that each correspond to an action that the\nNeoVM will perform. These actions are the manipulation of data by the NeoVM that will ultimately translate to changes to the\nstate of the Neo blockchain.\n\n### Where to Look in the Code\n\nNow that you have a _very_ basic understanding of how the NEO•ONE compiler works, you can start digging into the `neo-one-smart-contract-compiler`\npackage. Most likely you'll be looking in `neo-one-smart-contract-compiler/compiler/<subfolder>` (where `<subfolder>` is one of `constants`, `declaration`, `expression`, `helper`, `scope`, `statement`)\nfor the specific syntax that is broken or where you want to add a feature. For example, if you want to change how we compile the `==` token, you would\nlook for `EqualsEqualsEqualsHelper.ts` in `neo-one-smart-contract-compiler/compiler/helper/relational/EqualsEqualsHelper.ts`. In there you'll see\nhow this helper will \"emit\" different opcodes, syscalls, and other helpers to manipulate the Evaluation Stack. The comment line above each emit shows a\nrepresentation of the Evaluation Stack _after_ that bytecode is evaluated.\n\n### Write Unit Tests for What You're Working On\n\nOnce you have an understanding of what helpers or syntax compilers you need to change in order to make your compiler change, the best way to begin is to write\na unit test that you will run to test your change. You'll see that nearly every helper and syntax compiler has a corresponding set of unit tests in `neo-one-smart-contract-compiler/src/__tests__`.\nFor example, the `IfStatementCompiler.ts` has a set of unit tests in `IfStatementCompiler.test.ts`. In there you'll see that we typically use the built in `assertEqual` method to\ntest if values are what we expect them to be. You'll also see that we have helpers, like the `helpers.executeString()` helper, that make it easy to compile a string and test for certain behavior.\n\nHere is an example unit test you would write to test your changes:\n\n```ts\nimport { helpers } from '../../../__data__';\n\ndescribe('MyNewCompiler', () => {\n  test.only('simple test', async () => {\n    await helpers.executeString(`\n      if (!true) {\n        throw 'Failure';\n      }\n\n      const x = '10';\n      assertEqual(x, '10');\n    `);\n  });\n});\n```\n\n### Start Hacking\n\nOnce you've created a unit test that either recreates the bug you're trying to fix, or tests for the expected behavior of your new feature, you can start to make changes\nto the compiler's source code and run your unit test. If you want to add logging (ie. `console.log`) to the source code to get more information you can, just make sure\nto change the console settings in `neo-one-build-tests/environments/test/jestSetup.js`. From there you should make sure to only run one unit test at a time\nso that you're only getting logs from the compilation of that one unit test. This will make it easier to learn what the compiler is doing when compiling a specific string.\nTo run a specific unit test, rather than all unit tests, run `rush test -t <path/to/testfile>`.\n\nAnd that's it! Once you have this workflow setup you can hack away at the compiler code and run the unit test to test your changes, get logs, etc.\n"},"link":"packages/neo-one-website/docs/4-contributing/2-smart-contract-compiler.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/code-of-conduct","title":"Code of Conduct"},"previous":{"slug":"/docs/codebase-overview","title":"Codebase Overview"}},"path":"docs/smart-contract-compiler"}
