{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/native-assets","title":"Native Assets","content":{"type":"markdown","value":"\nNative assets like NEO and GAS require special handling in smart contracts. This guide will show you how.\n\nNEO employs the [Unspent Transaction Output](https://en.wikipedia.org/wiki/Unspent_transaction_output) (UTXO) system for native assets. Unfortunately, the UTXO system does not play well with smart contracts. Fortunately, NEO•ONE smart contracts abstract away most of the difficulty in handling native assets using the `@receive`, `@send`, `@sendUnsafe` and `@claim` [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html).\n\nOne commonality between every native asset method is that they must throw an error if the transaction should not proceed.\n\n---\n\n[[toc]]\n\n---\n\n## Receive Native Assets\n\nDecorate a method with `@receive` to allow the method to be invoked when receiving native assets:\n\n```typescript\nexport class Contract extends SmartContract {\n  @receive\n  public mintTokens(): void {\n    // Use Blockchain.currentTransaction to validate and process the inputs/outputs.\n    // Throw an error if it's an invalid combination\n  }\n}\n```\n\nMethods decorated with `@receive` may also be decorated with `@sendUnsafe` to enable both sending and receiving assets to be verified by the method.\n\nInvoking a method marked with `@receive` is identical to a normal method, but the transaction options contain an additional property, `sendTo`, which can be used to specify the assets to send to the smart contract:\n\n```typescript\nconst receipt = await contract.mintTokens({\n  sendTo: [\n    {\n      asset: Hash256.NEO,\n      amount: new BigNumber(10),\n    },\n  ],\n});\n```\n\nThere are cases where a smart contract may receive native assets without a corresponding `@receive` method invocation, or sometimes even when the `@receive` method throws an error. Unfortunately this is unavoidable, and to solve these cases every smart contract has an automatically generated method called `refundAssets`. Users may call this method when they have sent assets to the contract that were not properly processed. Using the NEO•ONE client APIs:\n\n```typescript\nconst transactionHash = ... // Hash of the transaction that needs to be refunded\nconst receipt = await contract.refundAssets.confirmed(transactionHash);\n```\n\n---\n\n## Send Native Assets\n\nNEO•ONE provides two methods for sending assets, one that is \"unsafe\" and one that is \"safe\".\n\n### Unsafe\n\nDecorate a method with `@sendUnsafe` to enable assets to be sent from the contract in a single transaction:\n\n```typescript\nexport class Contract extends SmartContract {\n  @sendUnsafe\n  public withdraw(): void {\n    // Typically check something like Address.isCaller(this.owner)\n  }\n}\n```\n\n`@sendUnsafe` is unsafe because it potentially allows the equivalent of double spends. It's possible for a user to construct a series of parallel transactions that enable them to withdraw more than they should be allowed to.\n\n::: warning\n\nNote\n\nOnly decorate a method with `@sendUnsafe` when the method checks that the caller is a \"superuser\", i.e. someone who is not going to attempt to cheat the contract. The most common case is to simply call `Address.isCaller(this.owner)` which checks that the method was only invoked by the owner of the smart contract.\n\n:::\n\nCalling a method marked with `@sendUnsafe` is similar to `@receive` in that it allows an additional options property called `sendFrom` which lets the user specify assets to transfer from the contract:\n\n```typescript\nconst receipt = await contract.withdraw.confirmed({\n  sendFrom: [\n    {\n      asset: Hash256.NEO,\n      amount: new BigNumber(10),\n      to: 'APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR',\n    },\n  ],\n});\n```\n\n### Safe\n\nDecorate a method with `@send` to enable assets to be sent from the contract safely. `@send` requires two transactions to send assets from the contract. At a high level the steps are:\n\n1. The user \"marks\" the assets they wish to withdraw from the contract by constructing a transaction that sends those assets back to the smart contract.\n2. The user constructs a transaction that withdraws the previously \"mark\"ed assets to the desired address.\n\nNEO•ONE abstract this process such that you only need to define a method decorated with `@send` that throws an error on invalid transactions. NEO•ONE handles the rest. This method may also accept a final argument, a `Transfer` object, that contains the details of the pending transfer:\n\n```typescript\ninterface Transfer {\n  readonly amount: Fixed<8>;\n  readonly asset: Hash256;\n  readonly to: Address;\n}\n```\n\nFor example, if you wanted to have a method that required a single argument, `value`, of type `string`, you could define your method like so:\n\n```typescript\nexport class Contract extends SmartContract {\n  @send\n  public withdraw(value: string, transfer: Transfer): void {\n    // Validate the `transfer` should proceed. Throw an error if not.\n  }\n}\n```\n\nCalling a method marked with `@send` is identical to `@sendUnsafe`, however, the transfer will not occur until the `completeSend` method is invoked with the transaction hash of the first transaction:\n\n```typescript\n// This transaction only sends assets from the contract to itself,\n// marking them for withdrawal by a followup transaction.\nconst receipt = await contract.withdraw.confirmed('value', {\n  sendFrom: [\n    {\n      asset: Hash256.NEO,\n      amount: new BigNumber(10),\n      to: 'APyEx5f4Zm4oCHwFWiSTaph1fPBxZacYVR',\n    },\n  ],\n});\n// Complete the withdrawal process using the transaction hash\nconst finalReceipt = await contract.completeSend.confirmed(receipt.transaction.hash);\n```\n\n---\n\n## Claim GAS\n\nDecorate a method with `@claim` to enable claiming GAS. `@claim` methods have a few restrictions:\n\n1. `@claim` methods may not modify contract storage. They act like `@constant` methods.\n2. `@claim` methods may not access `Blockchain.currentTransaction`, instead they may optionally accept the `ClaimTransaction` that the method was invoked in as the final argument.\n\n```typescript\nexport class Contract extends SmartContract {\n  @claim\n  public claim(transaction: ClaimTransaction): void {\n    // Validate the ClaimTransaction and throw an error if it is invalid\n  }\n}\n```\n\nThe NEO•ONE client APIs currently only support claiming all available GAS for a smart contract and sending that GAS back to the smart contract. If you have another use-case that you'd like to see supported, please reach out on [Discord](https://discordapp.com/invite/S86PqDE) or open an issue on [GitHub](https://github.com/neo-one-suite/neo-one/issues/new).\n\n```typescript\nawait contract.claim.confirmed();\n```\n\n::: warning\n\nNote\n\n`@claim` is similar to `@sendUnsafe` in terms of safety and thus you should only allow GAS claims that transfer the GAS to an `Address` that is not the contract itself to be done by superusers. To enable GAS claims for contracts without owners or superusers, instead only allow GAS claims that send the GAS back to the contract, and then implement transferring the GAS to the rightful owner using a method marked with `@send`.\n\n:::\n"},"link":"packages/neo-one-website/docs/2-advanced-guides/00-native-assets.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/forward-values","title":"Forward Values"},"previous":{"slug":"/docs/deployment","title":"Deployment"}},"path":"docs/native-assets"}
