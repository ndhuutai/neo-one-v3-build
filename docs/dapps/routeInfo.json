{"template":"/Users/tainguyen/neo-one/packages/neo-one-website/src/pages/docs","sharedHashesByProp":{},"data":{"current":"/docs/dapps","title":"Decentralized Apps","content":{"type":"markdown","value":"\nBuilding a decentralized app doesn't have to be hard, use these tools from NEO•ONE to make it quick and easy.\n\nIn addition to the client APIs we've already walked through, there are a few properties on the `Client` that help make your app reactive. We'll also cover using the NEO•ONE Developer Tools to help speed up manual testing of your dapp.\n\n---\n\n[[toc]]\n\n---\n\n## Reactive\n\nNEO•ONE uses [Observables](http://reactivex.io/) with [RxJS](http://reactivex.io/rxjs) to enable reactivity in dapps. The `Client` class has several `Observable` properties that can be subscribed to in order to update application state and the application UI. The most commonly used is the `block$` property:\n\n```typescript\nclass Client {\n  /**\n   * Emits a value whenever a block is persisted to the blockchain.\n   *\n   * Immediately emits the latest block/network when subscribed to.\n   */\n  public readonly block$: Observable<{\n    readonly block: Block;\n    readonly network: NetworkType;\n  }>;\n}\n```\n\nThe `Observable` emits a value whenever a new block is persisted to the blockchain for the given network. The `network` property corresponds to the currently selected user account's network. The `Observable` automatically updates to start emitting new blocks from another network whenever the underlying network changes due to a change in the selected user account.\n\nWe can update application state that depends on new blocks by subscribing to the `block$` `Observable`:\n\n```typescript\nclient.block$.subscribe(({ block, network }) => {\n  // Update application state using the latest block and network\n});\n```\n\n::: warning\n\nTip\n\nIf you're using React, check out the `FromStream` component in the [React](/docs/react) advanced guide for a streamlined way to integrate `Observable`s in your application. If you're using Angular or Vue, check out the [Angular](/docs/angular) or [Vue](/docs/vue) advanced guides for examples with those frameworks.\n\n:::\n\nOne common use-case is to update the user balance whenever a new block is persisted. For example, if we're displaying the user's NEO and GAS balance:\n\n```typescript\nclient.block$\n  .pipe(\n    switchMap(async () => {\n      const userAccount = client.getCurrentUserAccount();\n      if (userAccount === undefined) {\n        return undefined;\n      }\n\n      const account = await client.getAccount(userAccount.id);\n\n      return { neo: account.balances[Hash256.NEO], gas: account.balances[Hash256.GAS] };\n    }),\n  )\n  .subscribe((result) => {\n    if (result === undefined) {\n      // Update the UI when a user account is not selected\n    } else {\n      const { neo, gas } = result;\n      // Update the UI with the new neo and gas values.\n    }\n  });\n```\n\nThis is a fairly common pattern, so `Client` already exposes an `Observable` for it:\n\n```typescript\nclass Client {\n  /**\n   * Emits a value whenever a new user account is selected and whenever a block is persisted to the blockchain.\n   *\n   * Immediately emits the latest value when subscribed to.\n   */\n  public readonly accountState$: Observable<\n    | {\n        readonly currentUserAccount: UserAccount;\n        readonly account: Account;\n      }\n    | undefined\n  >;\n}\n```\n\nThus, we can simplify the above example to just:\n\n```typescript\nclient.accountState$.subscribe((result) => {\n  if (result === undefined) {\n    // Update the UI when a user account is not selected\n  } else {\n    const neo = result.account.balances[Hash256.NEO];\n    const gas = result.account.balances[Hash256.GAS];\n    // Update the UI with the new neo and gas values.\n  }\n});\n```\n\nTake a look at the [@neo-one/client](/reference/@neo-one/client) reference for details on all available `Observable`s.\n\n---\n\n## Developer Tools\n\nNEO•ONE Developer Tools simplify the process of developing and manually testing your dapp. They contain all of the functionality necessary to control your private network:\n\n- Immediately run consensus\n- Fast forward to a future time\n- Reset the local network to it's initial state\n- Full wallet implementation with the same set of pre-configured wallets as tests\n- Settings for controlling automatic consensus and system fees, seconds per block and adding NEP-5 token addresses to the wallet\n- Notifications when transactions are confirmed with links to view the transaction on a local NEO Tracker instance\n\nEnabling the Developer Tools is easy:\n\n```typescript\nconst client = createClient();\nconst developerClients = createDeveloperClients();\nDeveloperTools.enable({ client, developerClients });\n```\n\nSimply use the generated helper functions in `src/neo-one/client.ts` to construct the various clients the Developer Tools require and then call `enable`.\n\n::: warning\n\nNote\n\nIf you've integrated NEO•ONE using the [React](/docs/react) advanced guide, then the Developer Tools are automatically enabled with no additional calls or configuration required.\n\n:::\n\nWhen building for production, the Developer Tools are automatically replaced with an empty implementation, so they won't show up for your users nor affect the bundle size.\n"},"link":"packages/neo-one-website/docs/1-main-concepts/11-dapps.md","sidebar":[{"title":"Installation","numbered":false,"subsections":[{"title":"Getting Started","slug":"/docs/getting-started"},{"title":"Environment Setup","slug":"/docs/environment-setup"},{"title":"CLI","slug":"/docs/cli"},{"title":"Playground","slug":"/docs/playground"}]},{"title":"Main Concepts","numbered":true,"subsections":[{"title":"Hello World","slug":"/docs/hello-world"},{"title":"Blockchain Basics","slug":"/docs/blockchain-basics"},{"title":"Smart Contract Basics","slug":"/docs/smart-contract-basics"},{"title":"Standard Library","slug":"/docs/standard-library"},{"title":"Properties and Storage","slug":"/docs/properties-and-storage"},{"title":"Methods","slug":"/docs/methods"},{"title":"Events and Logs","slug":"/docs/events-and-logs"},{"title":"Calling Smart Contracts","slug":"/docs/calling-smart-contracts"},{"title":"Client APIs","slug":"/docs/client-apis"},{"title":"Smart Contract APIs","slug":"/docs/smart-contract-apis"},{"title":"Testing","slug":"/docs/testing"},{"title":"Decentralized Apps","slug":"/docs/dapps"},{"title":"Deployment","slug":"/docs/deployment"}]},{"title":"Advanced Guides","numbered":false,"subsections":[{"title":"Native Assets","slug":"/docs/native-assets"},{"title":"Forward Values","slug":"/docs/forward-values"},{"title":"User Accounts","slug":"/docs/user-accounts"},{"title":"Extended Client APIs","slug":"/docs/extended-client-apis"},{"title":"Raw Client APIs","slug":"/docs/Raw-client-apis"},{"title":"React","slug":"/docs/react"},{"title":"Angular","slug":"/docs/angular"},{"title":"Vue","slug":"/docs/vue"},{"title":"dAPI Support","slug":"/docs/dapi-support"},{"title":"Configuration Options","slug":"/docs/config-options"}]},{"title":"Node","numbered":false,"subsections":[{"title":"Local Docker Development","slug":"/docs/node-docker"},{"title":"Kubernetes","slug":"/docs/node-kubernetes"},{"title":"Docker Compose","slug":"/docs/node-compose"},{"title":"Building From Source","slug":"/docs/node-source"},{"title":"Heroku Deployment","slug":"/docs/node-heroku"},{"title":"Configuration Reference","slug":"/docs/node-configuration"}]},{"title":"Contributing","numbered":false,"subsections":[{"title":"How to Contribute","slug":"/docs/how-to-contribute"},{"title":"Codebase Overview","slug":"/docs/codebase-overview"},{"title":"Smart Contract Compiler","slug":"/docs/smart-contract-compiler"},{"title":"Code of Conduct","slug":"/docs/code-of-conduct"}]}],"next":{"slug":"/docs/deployment","title":"Deployment"},"previous":{"slug":"/docs/testing","title":"Testing"}},"path":"docs/dapps"}
