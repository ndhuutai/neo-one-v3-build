{"version":3,"sources":["webpack:///transpiler.init.ts","webpack:///Transpiler.ts","webpack:///transpile.ts","webpack:///index.ts","webpack:///comlink.ts","webpack:///endpoint.ts"],"names":["expose","self","Transpiler","path","value","initialized","transpile","code","codeIn","map","cwd","filename","sourceFileName","sourceMaps","presets","plugins","isTSX","location","origin","sourceMap","TRANSFERABLE_TYPES","ArrayBuffer","MessagePort","uid","Math","floor","random","Number","MAX_SAFE_INTEGER","proxyValueSymbol","Symbol","throwSymbol","transferHandlers","Map","canHandle","obj","Function","serialize","port1","port2","MessageChannel","deserialize","proxy","Error","message","stack","Object","assign","pingPongMessageCounter","endpoint","target","isWindow","windowEndpoint","isEndpoint","activateEndpoint","cbProxy","cb","callPath","Proxy","construct","_target","argumentsList","type","apply","_thisArg","length","slice","property","then","r","Promise","resolve","bind","concat","set","_proxy","async","args","irequest","wrapValue","unwrapValue","msg","transferables","id","attachMessageHandler","handler","event","data","f","removeEventListener","detachMessageHandler","postMessage","pingPongMessage","transferableProperties","proxyValue","rootObj","iresult","that","reduce","propName","e","makeInvocationResult","arg","key","transferHandler","wrappedChildren","iterateUnhandledProperties","handleProperty","visited","WeakSet","has","add","isView","keys","push","wrappedValue","wrappedChild","get","isRawWrappedValue","wrappedChildValue","join","newValue","replaceValueInObjectAtPath","newVal","lastKey","w","constructor","name","addEventListener","transfer","isMessagePort","start","every","prop","isTransferable","thing","some","iterateAllProperties","getEndpoint","endpointIn","close","isWorker","worker","terminate","activate","endpointEndpoint"],"mappings":"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","file":"workers.21.6f4f4c8c.js","sourcesContent":["import { comlink } from '@neo-one/worker';\nimport { Transpiler } from './Transpiler';\n\ncomlink.expose(Transpiler, self);\n","import { transpile, TranspileResult } from './transpile';\n\nexport class Transpiler {\n  public async transpile(path: string, value: string): Promise<TranspileResult> {\n    return transpile(path, value);\n  }\n}\n","// tslint:disable no-submodule-imports no-import-side-effect\n// @ts-ignore\nimport babelPluginProposalAsyncGeneratorFunctions from '@babel/plugin-proposal-async-generator-functions';\n// @ts-ignore\nimport babelPluginProposalClassProperties from '@babel/plugin-proposal-class-properties';\n// @ts-ignore\nimport babelPluginProposalNumericSeparator from '@babel/plugin-proposal-numeric-separator';\n// @ts-ignore\nimport babelPluginProposalObjectRestSprerad from '@babel/plugin-proposal-object-rest-spread';\n// @ts-ignore\nimport babelPluginProposalOptionalCatchBinding from '@babel/plugin-proposal-optional-catch-binding';\n// @ts-ignore\nimport babelPluginTransformModulesCommonJS from '@babel/plugin-transform-modules-commonjs';\n// @ts-ignore\nimport babelPluginTransformTypeScript from '@babel/plugin-transform-typescript';\n// @ts-ignore\nimport babelPresetReact from '@babel/preset-react';\n// @ts-ignore\nimport * as Babel from '@babel/standalone';\nimport { RawSourceMap } from 'source-map';\n\n// tslint:disable-next-line no-let\nlet initialized = false;\nconst initialize = () => {\n  if (initialized) {\n    return;\n  }\n  initialized = true;\n\n  Babel.registerPreset('@babel/preset-react', babelPresetReact);\n  Babel.registerPlugin('@babel/plugin-proposal-class-properties', babelPluginProposalClassProperties);\n  Babel.registerPlugin('@babel/plugin-proposal-object-rest-spread', babelPluginProposalObjectRestSprerad);\n  Babel.registerPlugin('@babel/plugin-proposal-optional-catch-binding', babelPluginProposalOptionalCatchBinding);\n  Babel.registerPlugin('@babel/plugin-proposal-async-generator-functions', babelPluginProposalAsyncGeneratorFunctions);\n  Babel.registerPlugin('@babel/plugin-proposal-numeric-separator', babelPluginProposalNumericSeparator);\n  Babel.registerPlugin('@babel/plugin-transform-typescript', babelPluginTransformTypeScript);\n  Babel.registerPlugin('@babel/plugin-transform-modules-commonjs', babelPluginTransformModulesCommonJS);\n};\n\nexport interface TranspileResult {\n  readonly code: string;\n  readonly sourceMap: RawSourceMap;\n}\n\nexport const transpile = (path: string, value: string): TranspileResult => {\n  initialize();\n\n  const { code: codeIn, map } = Babel.transform(value, {\n    cwd: '/',\n    filename: path,\n    sourceFileName: path,\n    sourceMaps: 'both',\n    presets: ['@babel/preset-react'],\n    plugins: [\n      '@babel/plugin-proposal-class-properties',\n      '@babel/plugin-proposal-object-rest-spread',\n      '@babel/plugin-proposal-optional-catch-binding',\n      '@babel/plugin-proposal-async-generator-functions',\n      '@babel/plugin-proposal-numeric-separator',\n      '@babel/plugin-transform-modules-commonjs',\n      ['@babel/plugin-transform-typescript', { isTSX: true }],\n    ],\n  });\n\n  const sourceURL = `//# sourceURL=${location.origin}${path}`;\n  const code = `${codeIn}\\n${sourceURL}`;\n\n  return { code, sourceMap: map };\n};\n","import * as comlink from './comlink';\nimport * as endpoint from './endpoint';\n\nexport { comlink, endpoint };\nexport * from './WorkerManager';\nexport { Disposable } from './types';\n","// tslint:disable\nexport interface Endpoint {\n  postMessage(message: any, transfer?: any[]): void;\n  addEventListener(type: string, listener: (event: MessageEvent) => void, options?: {}): void;\n  removeEventListener(type: string, listener: (event: MessageEvent) => void, options?: {}): void;\n}\nexport type Proxy = Function;\ntype CBProxyCallback = (bpcd: CBProxyCallbackDescriptor) => {}; // eslint-disable-line no-unused-vars\ntype Transferable = MessagePort | ArrayBuffer; // eslint-disable-line no-unused-vars\nexport type Exposable = Function | Object; // eslint-disable-line no-unused-vars\n\ninterface InvocationResult {\n  type: 'RETURN';\n  id?: string;\n  value: WrappedValue;\n}\n\ntype WrappedValue = RawWrappedValue | HandledWrappedValue;\n\ninterface PropertyIteratorEntry {\n  value: {};\n  path: string[];\n}\n\ninterface WrappedChildValue {\n  path: string[];\n  wrappedValue: HandledWrappedValue;\n}\n\ninterface RawWrappedValue {\n  type: 'RAW';\n  value: {};\n  wrappedChildren?: WrappedChildValue[];\n}\n\ninterface HandledWrappedValue {\n  type: string;\n  value: {};\n}\n\ntype CBProxyCallbackDescriptor = CBPCDGet | CBPCDApply | CBPCDConstruct | CBPCDSet; // eslint-disable-line no-unused-vars\n\ninterface CBPCDGet {\n  type: 'GET';\n  callPath: PropertyKey[];\n}\n\ninterface CBPCDApply {\n  type: 'APPLY';\n  callPath: PropertyKey[];\n  argumentsList: {}[];\n}\n\ninterface CBPCDConstruct {\n  type: 'CONSTRUCT';\n  callPath: PropertyKey[];\n  argumentsList: {}[];\n}\n\ninterface CBPCDSet {\n  type: 'SET';\n  callPath: PropertyKey[];\n  property: PropertyKey;\n  value: {};\n}\n\ntype InvocationRequest =\n  | GetInvocationRequest\n  | ApplyInvocationRequest\n  | ConstructInvocationRequest\n  | SetInvocationRequest;\n\ninterface GetInvocationRequest {\n  id?: string;\n  type: 'GET';\n  callPath: PropertyKey[];\n}\n\ninterface ApplyInvocationRequest {\n  id?: string;\n  type: 'APPLY';\n  callPath: PropertyKey[];\n  argumentsList: WrappedValue[];\n}\n\ninterface ConstructInvocationRequest {\n  id?: string;\n  type: 'CONSTRUCT';\n  callPath: PropertyKey[];\n  argumentsList: WrappedValue[];\n}\n\ninterface SetInvocationRequest {\n  id?: string;\n  type: 'SET';\n  callPath: PropertyKey[];\n  property: PropertyKey;\n  value: WrappedValue;\n}\n\nexport interface TransferHandler {\n  canHandle: (obj: {}) => Boolean;\n  serialize: (obj: {}) => {};\n  deserialize: (obj: {}) => {};\n}\n\nconst TRANSFERABLE_TYPES = [ArrayBuffer, MessagePort];\nconst uid: number = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n\nconst proxyValueSymbol = Symbol('proxyValue');\nconst throwSymbol = Symbol('throw');\nconst proxyTransferHandler: TransferHandler = {\n  canHandle: (obj: {}): Boolean => {\n    return obj && ((obj as any)[proxyValueSymbol] || obj instanceof Function);\n  },\n  serialize: (obj: {}): {} => {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return port2;\n  },\n  deserialize: (obj: {}): {} => {\n    return proxy(obj as MessagePort);\n  },\n};\n\nconst throwTransferHandler = {\n  canHandle: (obj: {}): Boolean => (obj && (obj as any)[throwSymbol]) || obj instanceof Error,\n  serialize: (obj: any): {} => {\n    const message = obj && obj.message;\n    const stack = obj && obj.stack;\n    return Object.assign({}, obj, { message, stack });\n  },\n  deserialize: (obj: {}): {} => {\n    throw Object.assign(Error(), obj);\n  },\n};\n\nexport const transferHandlers: Map<string, TransferHandler> = new Map([\n  ['PROXY', proxyTransferHandler] as const,\n  ['THROW', throwTransferHandler] as const,\n]);\n\nlet pingPongMessageCounter: number = 0;\n\nexport function proxy(endpoint: Endpoint | Window, target?: any): Proxy {\n  if (isWindow(endpoint)) endpoint = windowEndpoint(endpoint);\n  if (!isEndpoint(endpoint))\n    throw Error('endpoint does not have all of addEventListener, removeEventListener and postMessage defined');\n\n  activateEndpoint(endpoint);\n  return cbProxy(\n    async (irequest) => {\n      let args: WrappedValue[] = [];\n      if (irequest.type === 'APPLY' || irequest.type === 'CONSTRUCT') args = irequest.argumentsList.map(wrapValue);\n      const response = await pingPongMessage(\n        endpoint as Endpoint,\n        Object.assign({}, irequest, { argumentsList: args }),\n        transferableProperties(args),\n      );\n      const result = response.data as InvocationResult;\n      return unwrapValue(result.value);\n    },\n    [],\n    target,\n  );\n}\n\nexport function proxyValue<T>(obj: T): T {\n  if (obj instanceof MessagePort) {\n    return obj;\n  }\n\n  (obj as any)[proxyValueSymbol] = true;\n  return obj;\n}\n\nexport function expose(rootObj: Exposable, endpoint: Endpoint | Window): void {\n  if (isWindow(endpoint)) endpoint = windowEndpoint(endpoint);\n  if (!isEndpoint(endpoint))\n    throw Error('endpoint does not have all of addEventListener, removeEventListener and postMessage defined');\n\n  activateEndpoint(endpoint);\n  attachMessageHandler(endpoint, async function (event: MessageEvent) {\n    if (!event.data.id || !event.data.callPath) return;\n    let iresult;\n    const irequest = event.data as InvocationRequest;\n    try {\n      const that = await irequest.callPath.slice(0, -1).reduce((obj, propName) => obj[propName], rootObj as any);\n      let args: Array<{}> = [];\n\n      if (irequest.type === 'APPLY' || irequest.type === 'CONSTRUCT') {\n        args = irequest.argumentsList.map(unwrapValue);\n      }\n      if (irequest.type === 'APPLY') {\n        if (irequest.callPath.length > 0) {\n          iresult = await that[irequest.callPath[irequest.callPath.length - 1]](...args);\n        } else {\n          iresult = await that(...args);\n        }\n      }\n      if (irequest.type === 'CONSTRUCT') {\n        if (irequest.callPath.length > 0) {\n          iresult = await new that[irequest.callPath[irequest.callPath.length - 1]](...args);\n        } else {\n          iresult = await new that(...args);\n        }\n        iresult = proxyValue(iresult);\n      }\n      if (irequest.type === 'SET' || irequest.type === 'GET') {\n        const obj = irequest.callPath.length > 0 ? await that[irequest.callPath[irequest.callPath.length - 1]] : that;\n        if (irequest.type === 'SET') {\n          obj[irequest.property] = irequest.value;\n          // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n          // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n          iresult = true;\n        } else {\n          iresult = obj;\n        }\n      }\n    } catch (e) {\n      iresult = e;\n      iresult[throwSymbol] = true;\n    }\n\n    iresult = makeInvocationResult(irequest, iresult);\n    return (endpoint as Endpoint).postMessage(iresult, transferableProperties([iresult]));\n  });\n}\n\nfunction wrapValue(arg: {}): WrappedValue {\n  // Is arg itself handled by a TransferHandler?\n  for (const [key, transferHandler] of transferHandlers) {\n    if (transferHandler.canHandle(arg)) {\n      return {\n        type: key,\n\n        value: transferHandler.serialize(arg),\n      };\n    }\n  }\n\n  // If not, traverse the entire object and find handled values.\n  let wrappedChildren: WrappedChildValue[] = [];\n  iterateUnhandledProperties(arg, (value, path) => {\n    for (const [key, transferHandler] of transferHandlers) {\n      if (transferHandler.canHandle(value)) {\n        wrappedChildren.push({\n          path,\n          wrappedValue: {\n            type: key,\n            value: transferHandler.serialize(value),\n          },\n        });\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  for (const wrappedChild of wrappedChildren) {\n    const container = wrappedChild.path.slice(0, -1).reduce((obj, key) => obj[key], arg as any);\n    container[wrappedChild.path[wrappedChild.path.length - 1]] = null;\n  }\n  return {\n    type: 'RAW',\n    value: arg,\n    wrappedChildren,\n  };\n}\n\nfunction unwrapValue(arg: WrappedValue): {} {\n  if (transferHandlers.has(arg.type)) {\n    const transferHandler = transferHandlers.get(arg.type)!;\n    return transferHandler.deserialize(arg.value);\n  } else if (isRawWrappedValue(arg)) {\n    for (const wrappedChildValue of arg.wrappedChildren || []) {\n      if (!transferHandlers.has(wrappedChildValue.wrappedValue.type))\n        throw Error(`Unknown value type \"${arg.type}\" at ${wrappedChildValue.path.join('.')}`);\n      const transferHandler = transferHandlers.get(wrappedChildValue.wrappedValue.type)!;\n      const newValue = transferHandler.deserialize(wrappedChildValue.wrappedValue.value);\n      replaceValueInObjectAtPath(arg.value, wrappedChildValue.path, newValue);\n    }\n    return arg.value;\n  } else {\n    throw Error(`Unknown value type \"${arg.type}\"`);\n  }\n}\n\nfunction replaceValueInObjectAtPath(obj: {}, path: string[], newVal: {}) {\n  const lastKey = path.slice(-1)[0];\n  const lastObj = path.slice(0, -1).reduce((obj: any, key: string) => obj[key], obj);\n  lastObj[lastKey] = newVal;\n}\n\nfunction isRawWrappedValue(arg: WrappedValue): arg is RawWrappedValue {\n  return arg.type === 'RAW';\n}\n\nfunction windowEndpoint(w: Window): Endpoint {\n  if (self.constructor.name !== 'Window') throw Error('self is not a window');\n  return {\n    addEventListener: self.addEventListener.bind(self) as any,\n    removeEventListener: self.removeEventListener.bind(self) as any,\n    postMessage: (msg, transfer) => w.postMessage(msg, '*', transfer),\n  };\n}\n\nexport function isEndpoint(endpoint: any): endpoint is Endpoint {\n  return 'addEventListener' in endpoint && 'removeEventListener' in endpoint && 'postMessage' in endpoint;\n}\n\nfunction activateEndpoint(endpoint: Endpoint): void {\n  if (isMessagePort(endpoint)) endpoint.start();\n}\n\nfunction attachMessageHandler(endpoint: Endpoint, f: (e: MessageEvent) => void): void {\n  // Checking all possible types of `endpoint` manually satisfies TypeScript’s\n  // type checker. Not sure why the inference is failing here. Since it’s\n  // unnecessary code I’m going to resort to `any` for now.\n  // if(isWorker(endpoint))\n  //   endpoint.addEventListener('message', f);\n  // if(isMessagePort(endpoint))\n  //   endpoint.addEventListener('message', f);\n  // if(isOtherWindow(endpoint))\n  //   endpoint.addEventListener('message', f);\n  (endpoint as any).addEventListener('message', f);\n}\n\nfunction detachMessageHandler(endpoint: Endpoint, f: (e: MessageEvent) => void): void {\n  // Same as above.\n  (<any>endpoint).removeEventListener('message', f);\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === 'MessagePort';\n}\n\nfunction isWindow(endpoint: Endpoint | Window): endpoint is Window {\n  // TODO: This doesn’t work on cross-origin iframes.\n  // return endpoint.constructor.name === 'Window';\n  return ['window', 'length', 'location', 'parent', 'opener'].every((prop) => prop in endpoint);\n}\n\n/**\n * `pingPongMessage` sends a `postMessage` and waits for a reply. Replies are\n * identified by a unique id that is attached to the payload.\n */\nfunction pingPongMessage(endpoint: Endpoint, msg: Object, transferables: Transferable[]): Promise<MessageEvent> {\n  const id = `${uid}-${pingPongMessageCounter++}`;\n\n  return new Promise((resolve) => {\n    attachMessageHandler(endpoint, function handler(event: MessageEvent) {\n      if (event.data.id !== id || event.data.type !== 'RETURN') return;\n      detachMessageHandler(endpoint, handler);\n      resolve(event);\n    });\n\n    // Copy msg and add `id` property\n    msg = Object.assign({}, msg, { id });\n    endpoint.postMessage(msg, transferables);\n  });\n}\n\nfunction cbProxy(cb: CBProxyCallback, callPath: PropertyKey[] = [], target = function () {}): Proxy {\n  return new Proxy(target, {\n    construct(_target, argumentsList, proxy) {\n      return cb({\n        type: 'CONSTRUCT',\n        callPath,\n        argumentsList,\n      });\n    },\n    apply(_target, _thisArg, argumentsList) {\n      // We use `bind` as an indicator to have a remote function bound locally.\n      // The actual target for `bind()` is currently ignored.\n      if (callPath[callPath.length - 1] === 'bind') return cbProxy(cb, callPath.slice(0, -1));\n      return cb({\n        type: 'APPLY',\n        callPath: callPath[callPath.length - 1] === 'apply' ? callPath.slice(0, -1) : callPath,\n        argumentsList: callPath[callPath.length - 1] === 'apply' ? argumentsList[1] : argumentsList,\n      });\n    },\n    get(_target, property, proxy) {\n      if (property === proxyValueSymbol) {\n        return true;\n      }\n\n      if (property === 'then' && callPath.length === 0) {\n        return { then: () => proxy };\n      } else if (property === 'then') {\n        const r = cb({\n          type: 'GET',\n          callPath,\n        });\n        return Promise.resolve(r).then.bind(r);\n      } else {\n        return cbProxy(cb, callPath.concat(property), (<any>_target)[property]);\n      }\n    },\n    set(_target, property, value, _proxy): boolean {\n      if (property === proxyValueSymbol) {\n        return true;\n      }\n\n      return cb({\n        type: 'SET',\n        callPath,\n        property,\n        value,\n      }) as boolean;\n    },\n  });\n}\n\nexport function isTransferable(thing: {}): thing is Transferable {\n  return TRANSFERABLE_TYPES.some((type) => thing instanceof type);\n}\n\nfunction iterateUnhandledProperties(\n  value: {} | undefined,\n  handleProperty: (value: any, path: string[]) => boolean,\n  path: string[] = [],\n  visited: WeakSet<{}> | null = null,\n): void {\n  if (!value) return;\n  if (!visited) visited = new WeakSet<{}>();\n  if (visited.has(value)) return;\n  if (typeof value === 'string') return;\n  if (typeof value === 'object') visited.add(value);\n  if (ArrayBuffer.isView(value)) return;\n  if (handleProperty(value, path)) return;\n\n  const keys = Object.keys(value);\n  for (const key of keys) iterateUnhandledProperties((value as any)[key], handleProperty, [...path, key], visited);\n}\n\nfunction* iterateAllProperties(\n  value: {} | undefined,\n  path: string[] = [],\n  visited: WeakSet<{}> | null = null,\n): Iterable<PropertyIteratorEntry> {\n  if (!value) return;\n  if (!visited) visited = new WeakSet<{}>();\n  if (visited.has(value)) return;\n  if (typeof value === 'string') return;\n  if (typeof value === 'object') visited.add(value);\n  if (ArrayBuffer.isView(value)) return;\n  yield { value, path };\n\n  const keys = Object.keys(value);\n  for (const key of keys) yield* iterateAllProperties((value as any)[key], [...path, key], visited);\n}\n\nexport function transferableProperties(obj: {}[] | undefined): Transferable[] {\n  const r: Transferable[] = [];\n  for (const prop of iterateAllProperties(obj)) {\n    if (isTransferable(prop.value)) r.push(prop.value);\n  }\n  return r;\n}\n\nfunction makeInvocationResult(irequest: InvocationRequest, obj: {}): InvocationResult {\n  return {\n    type: 'RETURN',\n    id: irequest.id,\n    value: wrapValue(obj),\n  };\n}\n","// tslint:disable no-any\nimport * as comlink from './comlink';\n\nexport type EndpointLike = comlink.Endpoint | Window | Worker | WorkerEndpoint;\nexport interface WorkerEndpoint extends comlink.Endpoint {\n  readonly start: () => void;\n  readonly close: () => void;\n}\n\nfunction isWorkerEndpoint(endpoint: EndpointLike): endpoint is WorkerEndpoint {\n  return ['postMessage', 'addEventListener', 'removeEventListener', 'start', 'close'].every((prop) => prop in endpoint);\n}\n\nfunction isWindow(endpoint: EndpointLike): endpoint is Window {\n  return ['window', 'length', 'location', 'parent', 'opener'].every((prop) => prop in endpoint);\n}\n\nfunction isWorker(endpoint: EndpointLike): endpoint is Worker {\n  return ['onmessage', 'postMessage', 'terminate', 'addEventListener', 'removeEventListener'].every(\n    (prop) => prop in endpoint,\n  );\n}\n\nfunction windowEndpoint(w: Window): WorkerEndpoint {\n  if (self.constructor.name !== 'Window') {\n    throw Error('self is not a window');\n  }\n\n  return {\n    addEventListener: self.addEventListener.bind(self) as any,\n    removeEventListener: self.removeEventListener.bind(self) as any,\n    postMessage: (msg, transfer) => w.postMessage(msg, '*', transfer),\n    start: () => {\n      // do nothing\n    },\n    close: () => {\n      // do nothing\n    },\n  };\n}\n\nfunction workerEndpoint(worker: Worker): WorkerEndpoint {\n  return {\n    addEventListener: worker.addEventListener.bind(worker) as any,\n    removeEventListener: worker.removeEventListener.bind(worker) as any,\n    postMessage: worker.postMessage.bind(worker) as any,\n    start: () => {\n      // do nothing\n    },\n    close: worker.terminate.bind(worker),\n  };\n}\n\nfunction endpointEndpoint(endpoint: comlink.Endpoint): WorkerEndpoint {\n  return {\n    addEventListener: endpoint.addEventListener.bind(endpoint),\n    removeEventListener: endpoint.removeEventListener.bind(endpoint),\n    postMessage: endpoint.postMessage.bind(endpoint),\n    start: () => {\n      activate(endpoint);\n    },\n    close: () => {\n      if ((endpoint as any).close) {\n        (endpoint as any).close();\n      }\n    },\n  };\n}\n\nexport function getEndpoint(endpointIn: EndpointLike): WorkerEndpoint {\n  return isWorkerEndpoint(endpointIn)\n    ? endpointIn\n    : isWindow(endpointIn)\n    ? windowEndpoint(endpointIn)\n    : isWorker(endpointIn)\n    ? workerEndpoint(endpointIn)\n    : endpointEndpoint(endpointIn);\n}\n\nexport function activate(endpoint: any): void {\n  if (endpoint.start) {\n    endpoint.start();\n  }\n}\n"],"sourceRoot":""}