self.webpackChunk([18],{1148:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UnknownChangeTypeError=t.KeyNotFoundError=t.UnknownTypeError=t.NotFoundError=void 0;const s=a(25);t.NotFoundError=s.makeErrorWithCode("NOT_FOUND",()=>"Not found."),t.UnknownTypeError=s.makeErrorWithCode("UNKNOWN_TYPE",e=>"Unknown type"+(void 0===e?".":", found: "+e)),t.KeyNotFoundError=s.makeErrorWithCode("KEY_NOT_FOUND",e=>`Key ${e} not found in database.`),t.UnknownChangeTypeError=s.makeErrorWithCode("UNKNOWN_CHANGE_TYPE",()=>"Unknown change type.")},13:function(e,t,a){"use strict";a.r(t);var s=a(2234);a(93).a.expose(s.a,self)},1426:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1882);Object.defineProperty(t,"keys",{enumerable:!0,get:function(){return s.keys}})},1427:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.deserializeBlockHash=t.serializeBlockHash=t.deserializeHeaderHash=t.serializeHeaderHash=void 0;const s=a(24);t.serializeHeaderHash=e=>s.common.uInt256ToBuffer(e),t.deserializeHeaderHash=e=>s.common.bufferToUInt256(e),t.serializeBlockHash=e=>s.common.uInt256ToBuffer(e),t.deserializeBlockHash=e=>s.common.bufferToUInt256(e)},1517:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CoinUnspentError=t.CoinClaimedError=t.InvalidClaimError=t.UnknownVerifyError=t.WitnessVerifyError=t.ScriptVerifyError=t.GenesisBlockNotRegisteredError=void 0;const s=a(25);t.GenesisBlockNotRegisteredError=s.makeErrorWithCode("GENESIS_BLOCK_NOT_REGISTERED",()=>"Genesis block was not registered with storage."),t.ScriptVerifyError=s.makeErrorWithCode("SCRIPT_VERIFY",e=>e),t.WitnessVerifyError=s.makeErrorWithCode("WITNESS_VERIFY",()=>"Witness verification failed."),t.UnknownVerifyError=s.makeErrorWithCode("UNKNOWN_VERIFY",e=>e),t.InvalidClaimError=s.makeErrorWithCode("INVALID_CLAIM",(e,t)=>`Invalid Claim. Coin with asset: ${e} does not match governing hash: ${t}`),t.CoinClaimedError=s.makeErrorWithCode("COIN_CLAIMED",(e,t)=>`Coin with asset: ${e}, value: ${t} is already claimed.`),t.CoinUnspentError=s.makeErrorWithCode("COIN_UNSPENT",e=>e+" coins unspent.")},1518:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getValidators=t.processStateTransaction=t.getDescriptorChanges=void 0;const s=a(18),n=a(24),r=a(48),i=a(43),o=s.__importDefault(a(29)),c=a(1901),d=async(e,t,a)=>{let s=await Promise.all(a.inputs.map(async t=>({output:await e.output.get(t),negative:!0})));s=s.concat(a.outputs.map(e=>({output:e,negative:!1}))),await Promise.all(s.map(async({output:a,negative:s})=>(async(e,t,a,s)=>{let{value:r}=a;s&&(r=r.neg());const[i]=await Promise.all([t.getAccount(a.address),t.updateAccountBalance(a.address,a.asset,r)]);n.common.uInt256Equal(a.asset,e.settings.governingToken.hash)&&i.votes.length>0&&await Promise.all([Promise.all(i.votes.map(async e=>t.updateValidatorVotes(e,r))),t.updateValidatorsCountVotes(i.votes.length-1,r)])})(e,t,a,s)));const i=[...new Set(s.map(({output:e})=>n.common.uInt160ToHex(e.address)))].map(e=>n.common.hexToUInt160(e)),o=await Promise.all(i.map(async e=>(await t.getAccount(e)).votes)),c=[...new Set(o.reduce((e,t)=>e.concat(t.map(e=>n.common.ecPointToHex(e))),[]))].map(e=>n.common.hexToECPoint(e));await Promise.all(c.map(async e=>{const a=await t.getValidator(e);!a.registered&&a.votes.eq(r.utils.ZERO)&&await t.deleteValidator(e)}))};t.getDescriptorChanges=async({transactions:e,getAccount:t,governingTokenHash:a})=>{const s={},i={},c={},d=[],l=e.reduce((e,t)=>e.concat(t.descriptors),[]),u=l.filter(e=>64===e.type),h=Object.entries(o.default.groupBy(u,e=>n.common.uInt160ToHex(n.common.bufferToUInt160(e.key))));await Promise.all(h.map(async([e,o])=>{const c=await t(n.common.hexToUInt160(e)),l=c.getBalance(a);for(const e of c.votes){const t=n.common.ecPointToHex(e);i[t]=(void 0===i[t]?r.utils.ZERO:i[t]).sub(l)}const u=o[o.length-1],h=new r.BinaryReader(u.value),m=h.readArray(()=>h.readECPoint());m.length!==c.votes.length&&(c.votes.length>0&&(d[c.votes.length-1]=(void 0===d[c.votes.length-1]?r.utils.ZERO:d[c.votes.length-1]).sub(l)),m.length>0&&(d[m.length-1]=(void 0===d[m.length-1]?r.utils.ZERO:d[m.length-1]).add(l))),s[e]=m;for(const e of m){const t=n.common.ecPointToHex(e);i[t]=(void 0===i[t]?r.utils.ZERO:i[t]).add(l)}}));const m=l.filter(e=>72===e.type);for(const e of m){const t=n.common.bufferToECPoint(e.key);c[n.common.ecPointToHex(t)]=e.value.some(e=>0!==e)}const y={};for(const[e,t]of Object.entries(i))y[e]={votes:t};for(const[e,t]of Object.entries(c)){const a=void 0===y[e]?{}:y[e];y[e]={registered:t,votes:a.votes}}return{accountChanges:s,validatorChanges:y,validatorsCountChanges:d}},t.processStateTransaction=async({validatorChanges:e,validatorsCountChanges:t,tryGetValidatorsCount:a,addValidatorsCount:s,updateValidatorsCount:i,tryGetValidator:o,addValidator:c,deleteValidator:d,updateValidator:l})=>{const u=await a(),h=void 0===u?[]:[...u.votes];[...t.entries()].forEach(([e,t])=>{h[e]=t}),await Promise.all([Promise.all(Object.entries(e).map(async([e,{registered:t,votes:a}])=>{const s=n.common.hexToECPoint(e),i=await o({publicKey:s});void 0===i?await c(new r.Validator({publicKey:s,registered:t,votes:a})):(void 0!==t&&!t||void 0===t&&!i.registered)&&(void 0!==a&&a.eq(r.utils.ZERO)||void 0===a&&i.votes.eq(r.utils.ZERO))?await d({publicKey:i.publicKey}):await l(i,{votes:a,registered:t})})),void 0===u?s(new r.ValidatorsCount({votes:h})):i(u,{votes:h})])},t.getValidators=async(e,a)=>{const s=new c.ValidatorCache(e);await Promise.all(a.map(async t=>d(e,s,t)));const{validatorChanges:l,validatorsCountChanges:u}=await t.getDescriptorChanges({transactions:a.filter(e=>e.type===r.TransactionType.State&&e instanceof r.StateTransaction),getAccount:async e=>s.getAccount(e),governingTokenHash:e.settings.governingToken.hashHex});await t.processStateTransaction({validatorChanges:l,validatorsCountChanges:u,tryGetValidatorsCount:async()=>s.getValidatorsCount(),addValidatorsCount:async e=>s.addValidatorsCount(e),updateValidatorsCount:async e=>{await s.updateValidatorsCount(e)},tryGetValidator:async e=>s.getValidator(e.publicKey),addValidator:async e=>s.addValidator(e),deleteValidator:async e=>s.deleteValidator(e.publicKey),updateValidator:async(e,t)=>s.updateValidator(e.publicKey,t)});const[h,m]=await Promise.all([s.getValidatorsCount(),s.getAllValidators()]),y=Math.max(r.utils.weightedAverage(r.utils.weightedFilter(h.votes.map((e,t)=>({count:t,votes:void 0===e?r.utils.ZERO:e})).filter(({votes:e})=>e.gt(r.utils.ZERO)),.25,.75,({count:e})=>new i.BN(e)).map(([{count:e},t])=>({value:e,weight:t}))),e.settings.standbyValidators.length),g=new Set(e.settings.standbyValidators.map(e=>n.common.ecPointToHex(e))),p=new Set(o.default.take(m.filter(e=>e.registered&&e.votes.gt(r.utils.ZERO)||g.has(n.common.ecPointToHex(e.publicKey))).sort((e,t)=>e.votes.eq(t.votes)?n.common.ecPointCompare(e.publicKey,t.publicKey):-e.votes.cmp(t.votes)).map(e=>n.common.ecPointToHex(e.publicKey)),y)),v=[...g];for(let e=0;e<v.length&&p.size<y;e+=1)p.add(v[e]);return[...p].map(e=>n.common.hexToECPoint(e)).sort((e,t)=>n.common.ecPointCompare(e,t))}},1519:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.wrapExecuteScripts=void 0;const s=a(24),n=a(48);t.wrapExecuteScripts=async e=>{try{const t=await e();return t.state===s.VMState.Halt?new n.InvocationResultSuccess({gasConsumed:t.gasConsumed,gasCost:t.gasCost,stack:t.stack}):new n.InvocationResultError({gasConsumed:t.gasConsumed,gasCost:t.gasCost,stack:t.stack,message:void 0===t.errorMessage?"Unknown Error":t.errorMessage})}catch(e){return new n.InvocationResultError({gasConsumed:s.utils.ZERO,gasCost:s.utils.ZERO,stack:[],message:e.message})}}},1520:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BlockSentContext=void 0;const s=a(924);class n extends s.Context{cloneExpectedView({expectedView:e}){return new n({type:this.type,previousHash:this.previousHash,blockIndex:this.blockIndex,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds})}}t.BlockSentContext=n},1521:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InitialContext=void 0;const s=a(924);class n extends s.Context{cloneExpectedView({expectedView:e}){return new n({type:this.type,previousHash:this.previousHash,blockIndex:this.blockIndex,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds})}}t.InitialContext=n},1522:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SignatureSentContext=void 0;const s=a(994),n=a(1523);class r extends s.HeaderContext{clone({type:e,primaryIndex:t,viewNumber:a}){return new r({type:e,viewNumber:a,myIndex:this.myIndex,primaryIndex:t,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:this.signatures,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}cloneExpectedView({expectedView:e}){return new r({type:this.type,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:this.signatures,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}cloneSignatures({signatures:e}){return new r({type:this.type,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:e,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}cloneRequestSent(){return new n.RequestSentContext({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:this.signatures,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}}t.SignatureSentContext=r},1523:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RequestSentContext=void 0;const s=a(994);class n extends s.HeaderContext{constructor({viewNumber:e,myIndex:t,primaryIndex:a,expectedView:s,validators:n,blockReceivedTimeSeconds:r,transactions:i,signatures:o,header:c}){super({type:"primary",viewNumber:e,myIndex:t,primaryIndex:a,expectedView:s,validators:n,blockReceivedTimeSeconds:r,transactions:i,signatures:o,header:c})}cloneExpectedView({expectedView:e}){return new n({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:this.signatures,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}cloneSignatures({signatures:e}){return new n({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:e,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}}t.RequestSentContext=n},1524:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ViewChangingContext=void 0;const s=a(924);class n extends s.Context{constructor({previousHash:e,blockIndex:t,viewNumber:a,myIndex:s,primaryIndex:n,expectedView:r,validators:i,blockReceivedTimeSeconds:o}){super({type:"backup",previousHash:e,blockIndex:t,viewNumber:a,myIndex:s,primaryIndex:n,expectedView:r,validators:i,blockReceivedTimeSeconds:o})}cloneExpectedView({expectedView:e}){return new n({previousHash:this.previousHash,blockIndex:this.blockIndex,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds})}}t.ViewChangingContext=n},1533:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.assertCommand=t.InvalidCommandError=t.Command=void 0;const s=a(25);var n;!function(e){e.addr="addr",e.block="block",e.consensus="consensus",e.filteradd="filteradd",e.filterclear="filterclear",e.filterload="filterload",e.getaddr="getaddr",e.getblocks="getblocks",e.getdata="getdata",e.getheaders="getheaders",e.headers="headers",e.inv="inv",e.mempool="mempool",e.tx="tx",e.verack="verack",e.version="version",e.alert="alert",e.merkleblock="merkleblock",e.notfound="notfound",e.ping="ping",e.pong="pong",e.reject="reject"}(n=t.Command||(t.Command={})),t.InvalidCommandError=s.makeErrorWithCode("INVALID_COMMAND",e=>"Invalid Command. Found: "+e);t.assertCommand=e=>{if((e=>void 0!==n[e])(e))return e;throw new t.InvalidCommandError(e)}},1534:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1937);Object.defineProperty(t,"AddrPayload",{enumerable:!0,get:function(){return s.AddrPayload}});var n=a(1938);Object.defineProperty(t,"FilterAddPayload",{enumerable:!0,get:function(){return n.FilterAddPayload}});var r=a(1939);Object.defineProperty(t,"FilterLoadPayload",{enumerable:!0,get:function(){return r.FilterLoadPayload}});var i=a(1940);Object.defineProperty(t,"GetBlocksPayload",{enumerable:!0,get:function(){return i.GetBlocksPayload}});var o=a(1941);Object.defineProperty(t,"HeadersPayload",{enumerable:!0,get:function(){return o.HeadersPayload}});var c=a(1942);Object.defineProperty(t,"InvPayload",{enumerable:!0,get:function(){return c.InvPayload}});var d=a(1943);Object.defineProperty(t,"MerkleBlockPayload",{enumerable:!0,get:function(){return d.MerkleBlockPayload}});var l=a(1535);Object.defineProperty(t,"NetworkAddress",{enumerable:!0,get:function(){return l.NetworkAddress}});var u=a(1944);Object.defineProperty(t,"VersionPayload",{enumerable:!0,get:function(){return u.VersionPayload}}),Object.defineProperty(t,"SERVICES",{enumerable:!0,get:function(){return u.SERVICES}});var h=a(1536);Object.defineProperty(t,"InventoryType",{enumerable:!0,get:function(){return h.InventoryType}})},1535:function(e,t,a){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.NetworkAddress=void 0;const s=a(24),n=a(48),r=a(1526);class i{constructor({host:e,port:t,timestamp:a,services:n}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.host=e,this.port=t,this.timestamp=a,this.services=n}static deserializeWireBase({reader:e}){const t=e.readUInt32LE(),a=e.readUInt64LE(),s=r.Address6.fromByteArray([...e.readBytes(16)]),n=e.readUInt16BE(),i=null==s?"":s.canonicalForm();return new this({timestamp:t,services:a,host:null==i?"":i,port:n})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}static isValid(e){const t=this.getAddress6(e);if(null==t)return!1;try{return t.toByteArray(),!0}catch(e){return!1}}static getAddress6(e){return 4===e.split(".").length?r.Address6.fromAddress4(e):new r.Address6(e)}serializeWireBase(t){const a=i.getAddress6(this.host);if(null==a)throw new s.InvalidFormatError("Network IP address undefined");t.writeUInt32LE(this.timestamp),t.writeUInt64LE(this.services);const n=e.from(a.toByteArray());t.writeBytes(e.concat([e.alloc(16-n.length,0),n])),t.writeUInt16BE(this.port)}}t.NetworkAddress=i}).call(this,a(26).Buffer)},1536:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.assertInventoryType=t.InvalidInventoryTypeError=t.InventoryType=void 0;const s=a(25);var n;!function(e){e[e.Transaction=1]="Transaction",e[e.Block=2]="Block",e[e.Consensus=224]="Consensus"}(n=t.InventoryType||(t.InventoryType={})),t.InvalidInventoryTypeError=s.makeErrorWithCode("INVALID_INVENTORY_TYPE",e=>"Expected inventory type, found: "+e);t.assertInventoryType=e=>{if((e=>void 0!==n[e])(e))return e;throw new t.InvalidInventoryTypeError(e)}},1857:function(e,t,a){"use strict";a.d(t,"a",(function(){return f}));var s=a(90),n=a(340),r=a(1892),i=a(2235),o=a(1904),c=a(1946),d=a(1879),l=a(1307),u=a(1858),h=a.n(u),m=a(1866),y=a.n(m),g=a(1874),p=a.n(g),v=a(1877),b=a(1945);class f{constructor(e,t,a){this.options=e,this.developerClient=t,this.build=a,this.startPromise=this.startInternal()}async start(){return this.startPromise.then(()=>{})}async stop(){void 0!==this.mutableDisposable&&(await this.mutableDisposable(),this.mutableDisposable=void 0)}async handleRequest(e){return(await this.startPromise)(e)}async startInternal(){const e=s.b.stringToPrivateKey(v.a.PRIVATE_NET_PRIVATE_KEY),t=s.b.stringToECPoint(v.a.PRIVATE_NET_PUBLIC_KEY);n.a.addPublicKey(e,t);const a=Object(i.a)({address:s.b.uInt160ToString(n.a.privateKeyToScriptHash(e)),standbyValidators:[s.b.ecPointToString(t)],privateNet:!0}),u=Object(d.storage)({db:y()("persistent"===this.options.type?h()(this.options.id):p()()),context:{messageMagic:a.messageMagic}}),m=await r.Blockchain.create({settings:a,storage:u,vm:l.vm}),g={consensus:{privateKey:s.b.privateKeyToString(e),privateNet:!0}},f=new o.Node({blockchain:m,options:g,createNetwork:()=>new b.a});return this.mutableDisposable=await f.start(),Object(c.createHandler)({blockchain:m,node:f,handleResetProject:this.reset.bind(this),handleGetNEOTrackerURL:async()=>{}})}async reset(){await this.developerClient.reset(),await this.developerClient.updateSettings({secondsPerBlock:15}),await this.build()}}},1877:function(e,t,a){"use strict";a.d(t,"a",(function(){return n}));var s=a(1232);const n=Object.assign({},s.a)},1879:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1880);Object.defineProperty(t,"storage",{enumerable:!0,get:function(){return s.levelUpStorage}})},1880:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.levelUpStorage=void 0;const s=a(18),n=a(48),r=a(1426),i=s.__importStar(a(1427)),o=a(1883),c=a(1148),d=s.__importStar(a(1884));t.levelUpStorage=({db:e,context:t})=>{const a=async({hashOrIndex:t})=>{let a=t;if("number"==typeof a)try{const t=await e.get(r.keys.serializeHeaderIndexHashKey(a));a=i.deserializeHeaderHash(t)}catch(e){if(e.notFound)throw new c.KeyNotFoundError(""+a);throw e}return a},s=d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.header,deserializeValue:e=>n.Header.deserializeWire({context:t,buffer:e})}),l=async({hashOrIndex:e})=>{const t=await a({hashOrIndex:e});return s.get({hash:t})},u={get:l,tryGet:d.createTryGet({get:l}),tryGetLatest:d.createTryGetLatest({db:e,latestKey:r.keys.maxHeaderHashKey,deserializeResult:e=>({hash:i.deserializeHeaderHash(e)}),get:s.get})},h=d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.block,deserializeValue:e=>n.Block.deserializeWire({context:t,buffer:e})}),m=async({hashOrIndex:e})=>{const t=await a({hashOrIndex:e});return h.get({hash:t})},y={get:m,tryGet:d.createTryGet({get:m}),tryGetLatest:d.createTryGetLatest({db:e,latestKey:r.keys.maxBlockHashKey,deserializeResult:e=>({hash:i.deserializeBlockHash(e)}),get:h.get})},g=d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.transaction,deserializeValue:e=>n.deserializeTransactionWire({context:t,buffer:e})}),p=d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.output,deserializeValue:e=>n.Output.deserializeWire({context:t,buffer:e})});return{header:u,block:y,blockData:d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.blockData,deserializeValue:e=>n.BlockData.deserializeWire({context:t,buffer:e})}),account:d.createReadAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.account,minKey:r.keys.accountMinKey,maxKey:r.keys.accountMaxKey,deserializeValue:e=>n.Account.deserializeWire({context:t,buffer:e})}),accountUnclaimed:d.createReadGetAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.accountUnclaimed,getMinKey:r.keys.getAccountUnclaimedKeyMin,getMaxKey:r.keys.getAccountUnclaimedKeyMax,deserializeValue:e=>n.AccountUnclaimed.deserializeWire({context:t,buffer:e})}),accountUnspent:d.createReadGetAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.accountUnspent,getMinKey:r.keys.getAccountUnspentKeyMin,getMaxKey:r.keys.getAccountUnspentKeyMax,deserializeValue:e=>n.AccountUnspent.deserializeWire({context:t,buffer:e})}),action:d.createReadGetAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.action,getMinKey:r.keys.getActionKeyMin,getMaxKey:r.keys.getActionKeyMax,deserializeValue:e=>n.deserializeActionWire({context:t,buffer:e})}),asset:d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.asset,deserializeValue:e=>n.Asset.deserializeWire({context:t,buffer:e})}),transaction:g,transactionData:d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.transactionData,deserializeValue:e=>n.TransactionData.deserializeWire({context:t,buffer:e})}),output:p,contract:d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.contract,deserializeValue:e=>n.Contract.deserializeWire({context:t,buffer:e})}),storageItem:d.createReadGetAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.storageItem,getMinKey:r.keys.getStorageItemKeyMin,getMaxKey:r.keys.getStorageItemKeyMax,deserializeValue:e=>n.StorageItem.deserializeWire({context:t,buffer:e})}),validator:d.createReadAllStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.validator,minKey:r.keys.validatorMinKey,maxKey:r.keys.validatorMaxKey,deserializeValue:e=>n.Validator.deserializeWire({context:t,buffer:e})}),invocationData:d.createReadStorage({db:e,serializeKey:r.keys.typeKeyToSerializeKey.invocationData,deserializeValue:e=>n.InvocationData.deserializeWire({context:t,buffer:e})}),validatorsCount:d.createReadMetadataStorage({db:e,key:r.keys.validatorsCountKey,deserializeValue:e=>n.ValidatorsCount.deserializeWire({context:t,buffer:e})}),async close(){await e.close()},async commit(t){const a=t.map(o.convertChange).reduce((e,t)=>(e.push(...t),e),[]);await e.batch(a)},async reset(){const t=[];await new Promise((a,s)=>{e.createKeyStream().on("data",e=>{t.push({type:"del",key:e})}).on("error",e=>{s(e)}).on("end",()=>{a()})}),await e.batch(t)}}}},1882:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.keys=void 0;const s=a(24),n=a(25),r=e=>e+"\0",i=e=>e+"ÿ",o=r("0"),c=r("1"),d=r("2"),l=r("3"),u=r("4"),h=r("5"),m=r("6"),y=r("7"),g=r("8"),p=r("9"),v=r("a"),b=r("b"),f=r("c"),w=r("d"),k=r("e"),x=r("f"),C=r("g"),S=r("h"),I=C+"0",T=C+"1",P=e=>({hash:t,input:a})=>`${e}${s.common.uInt160ToString(t)}${s.common.uInt256ToString(a.hash)}${a.index}`,A=e=>({hash:t})=>`${e}${s.common.uInt160ToString(t)}`,E=e=>({hash:t})=>i(`${e}${s.common.uInt160ToString(t)}`),K=A(c),O=E(c),V=A(d),H=E(d),B=({hash:e,prefix:t})=>[w,void 0===e?void 0:s.common.uInt160ToString(e),void 0===t?void 0:t.toString("hex")].filter(n.utils.notNull).join(""),R=({index:e})=>`${l}${e.toString(10,8)}`,N=k,M=i(k),_=e=>t=>`${e}${(({hash:e})=>s.common.uInt160ToString(e))(t)}`,z=e=>t=>`${e}${(({hash:e})=>s.common.uInt256ToString(e))(t)}`,D=o,U=i(o),G={account:_(o),accountUnclaimed:P(c),accountUnspent:P(d),action:R,asset:z(u),block:z(h),blockData:z(m),header:z(y),transaction:z(p),output:({index:e,hash:t})=>`${v}${s.common.uInt256ToString(t)}${e}`,transactionData:z(b),contract:_(f),storageItem:({hash:e,key:t})=>`${w}${s.common.uInt160ToString(e)}${t.toString("hex")}`,validator:({publicKey:e})=>`${k}${s.common.ecPointToString(e)}`,invocationData:z(x)};t.keys={validatorsCountKey:S,serializeHeaderIndexHashKey:e=>`${g}${e}`,maxHeaderHashKey:I,maxBlockHashKey:T,getAccountUnclaimedKeyMin:K,getAccountUnclaimedKeyMax:O,getAccountUnspentKeyMin:V,getAccountUnspentKeyMax:H,getStorageItemKeyMin:B,getStorageItemKeyMax:e=>i(B(e)),serializeActionKey:R,getActionKeyMin:({indexStart:e})=>[l,void 0===e?void 0:e.toString(10,8)].filter(n.utils.notNull).join(""),getActionKeyMax:({indexStop:e})=>i([l,void 0===e?void 0:e.toString(10,8)].filter(n.utils.notNull).join("")),validatorMinKey:N,validatorMaxKey:M,accountMinKey:D,accountMaxKey:U,typeKeyToSerializeKey:G}},1883:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convertChange=void 0;const s=a(18),n=a(1426),r=a(25),i=s.__importStar(a(1427)),o=a(1148),c=e=>{switch(e.type){case"account":return{type:"del",key:n.keys.typeKeyToSerializeKey.account(e.key)};case"accountUnspent":return{type:"del",key:n.keys.typeKeyToSerializeKey.accountUnspent(e.key)};case"accountUnclaimed":return{type:"del",key:n.keys.typeKeyToSerializeKey.accountUnclaimed(e.key)};case"contract":return{type:"del",key:n.keys.typeKeyToSerializeKey.contract(e.key)};case"storageItem":return{type:"del",key:n.keys.typeKeyToSerializeKey.storageItem(e.key)};case"validator":return{type:"del",key:n.keys.typeKeyToSerializeKey.validator(e.key)};default:throw r.utils.assertNever(e),new o.UnknownTypeError}};t.convertChange=e=>{if("add"===e.type)return(e=>{const t=e;switch(t.type){case"account":return[{type:"put",key:n.keys.typeKeyToSerializeKey.account(t.value),value:t.value.serializeWire()}];case"accountUnspent":return[{type:"put",key:n.keys.typeKeyToSerializeKey.accountUnspent({hash:t.value.hash,input:t.value.input}),value:t.value.serializeWire()}];case"accountUnclaimed":return[{type:"put",key:n.keys.typeKeyToSerializeKey.accountUnclaimed({hash:t.value.hash,input:t.value.input}),value:t.value.serializeWire()}];case"action":return[{type:"put",key:n.keys.typeKeyToSerializeKey.action({index:t.value.index}),value:t.value.serializeWire()}];case"asset":return[{type:"put",key:n.keys.typeKeyToSerializeKey.asset(t.value),value:t.value.serializeWire()}];case"block":return[{type:"put",key:n.keys.typeKeyToSerializeKey.block(t.value),value:t.value.serializeWire()},{type:"put",key:n.keys.maxBlockHashKey,value:i.serializeBlockHash(t.value.hash)}];case"blockData":return[{type:"put",key:n.keys.typeKeyToSerializeKey.blockData(t.value),value:t.value.serializeWire()}];case"header":return[{type:"put",key:n.keys.typeKeyToSerializeKey.header(t.value),value:t.value.serializeWire()},{type:"put",key:n.keys.maxHeaderHashKey,value:i.serializeHeaderHash(t.value.hash)},{type:"put",key:n.keys.serializeHeaderIndexHashKey(t.value.index),value:i.serializeHeaderHash(t.value.hash)}];case"transaction":return[{type:"put",key:n.keys.typeKeyToSerializeKey.transaction(t.value),value:t.value.serializeWire()}];case"output":return[{type:"put",key:n.keys.typeKeyToSerializeKey.output({hash:t.value.hash,index:t.value.index}),value:t.value.output.serializeWire()}];case"transactionData":return[{type:"put",key:n.keys.typeKeyToSerializeKey.transactionData(t.value),value:t.value.serializeWire()}];case"contract":return[{type:"put",key:n.keys.typeKeyToSerializeKey.contract(t.value),value:t.value.serializeWire()}];case"storageItem":return[{type:"put",key:n.keys.typeKeyToSerializeKey.storageItem({hash:t.value.hash,key:t.value.key}),value:t.value.serializeWire()}];case"validator":return[{type:"put",key:n.keys.typeKeyToSerializeKey.validator({publicKey:t.value.publicKey}),value:t.value.serializeWire()}];case"invocationData":return[{type:"put",key:n.keys.typeKeyToSerializeKey.invocationData(t.value),value:t.value.serializeWire()}];case"validatorsCount":return[{type:"put",key:n.keys.validatorsCountKey,value:t.value.serializeWire()}];default:throw r.utils.assertNever(t),new o.UnknownTypeError(e.type)}})(e.change);if("delete"===e.type)return[c(e.change)];throw r.utils.assertNever(e),new o.UnknownChangeTypeError}},1884:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createReadMetadataStorage=t.createTryGetMetadata=t.createReadGetAllStorage=t.createReadAllStorage=t.createAll$=t.createReadStorage=t.createTryGetLatest=t.createTryGet=void 0;const s=a(88),n=a(1148),r=a(1889);function i({get:e}){return async t=>{try{return await e(t)}catch(e){if(e.notFound||"KEY_NOT_FOUND"===e.code)return;throw e}}}function o({db:e,serializeKey:t,deserializeValue:a}){const s=async s=>{const r=t(s);try{const t=await e.get(r);return a(t)}catch(e){if(e.notFound||"KEY_NOT_FOUND"===e.code)throw new n.KeyNotFoundError(r);throw e}};return{get:s,tryGet:i({get:s})}}function c({db:e,minKey:t,maxKey:a,deserializeValue:n}){return r.streamToObservable(()=>e.createValueStream({gte:t,lte:a})).pipe(s.map(n))}t.createTryGet=i,t.createTryGetLatest=function({db:e,latestKey:t,deserializeResult:a,get:s}){return async()=>{try{const n=await e.get(t);return await s(a(n))}catch(e){if(e.notFound||"KEY_NOT_FOUND"===e.code)return;throw e}}},t.createReadStorage=o,t.createAll$=c,t.createReadAllStorage=function({db:e,serializeKey:t,minKey:a,maxKey:s,deserializeValue:n}){const r=o({db:e,serializeKey:t,deserializeValue:n});return{get:r.get,tryGet:r.tryGet,all$:c({db:e,minKey:a,maxKey:s,deserializeValue:n})}},t.createReadGetAllStorage=function({db:e,serializeKey:t,getMinKey:a,getMaxKey:s,deserializeValue:n}){const r=o({db:e,serializeKey:t,deserializeValue:n});return{get:r.get,tryGet:r.tryGet,getAll$:t=>c({db:e,minKey:a(t),maxKey:s(t),deserializeValue:n})}},t.createTryGetMetadata=function({get:e}){return async()=>{try{return await e()}catch(e){if(e.notFound||"KEY_NOT_FOUND"===e.code)return;throw e}}},t.createReadMetadataStorage=function({db:e,key:t,deserializeValue:a}){const s=async()=>{try{const s=await e.get(t);return a(s)}catch(e){if(e.notFound||"KEY_NOT_FOUND"===e.code)throw new n.KeyNotFoundError(t);throw e}};return{get:s,tryGet:i({get:s})}}},1889:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.streamToObservable=void 0;const s=a(77);t.streamToObservable=e=>new s.Observable(t=>{const a=e();let s=!1;const n=()=>{s||(s=!0,a.removeListener("end",r),a.removeListener("error",i),a.removeListener("data",o))},r=()=>{n(),t.complete()},i=e=>{n(),t.error(e)},o=e=>t.next(e);return a.once("error",i),a.once("end",r),a.on("data",o),n})},1892:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1893);Object.defineProperty(t,"Blockchain",{enumerable:!0,get:function(){return s.Blockchain}})},1893:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Blockchain=void 0;const s=a(18),n=a(24),r=a(992),i=a(48),o=a(25),c=a(43),d=s.__importDefault(a(1900)),l=a(77),u=a(88),h=a(1517),m=a(1518),y=a(1519),g=a(1902),p=r.createChild(r.nodeLogger,{component:"blockchain"});class v{constructor(e){this.mutablePersistingBlocks=!1,this.mutableBlockQueue=new d.default({comparator:(e,t)=>e.block.index-t.block.index}),this.mutableInQueue=new Set,this.mutableRunning=!1,this.mutableBlock$=new l.Subject,this.getValidators=async e=>(p.debug({name:"neo_blockchain_get_validators"}),m.getValidators(this,e)),this.calculateClaimAmount=async e=>{p.debug({name:"neo_blockchain_calculate_claim_amount"});const t=await Promise.all(e.map(async e=>this.tryGetSpentCoin(e))),a=t.filter(o.utils.notNull);if(t.length!==a.length)throw new h.CoinUnspentError(t.length-a.length);const s=a.filter(e=>{if(e.claimed)throw new h.CoinClaimedError(n.common.uInt256ToString(e.output.asset),e.output.value.toString(10));if(!n.common.uInt256Equal(e.output.asset,this.settings.governingToken.hash))throw new h.InvalidClaimError(n.common.uInt256ToString(e.output.asset),n.common.uInt256ToString(this.settings.governingToken.hash));return!0});return i.utils.calculateClaimAmount({coins:s.map(e=>({value:e.output.value,startHeight:e.startHeight,endHeight:e.endHeight})),decrementInterval:this.settings.decrementInterval,generationAmount:this.settings.generationAmount,getSystemFee:async e=>{const t=await this.header.get({hashOrIndex:e});return(await this.blockData.get({hash:t.hash})).systemFee}})},this.verifyScript=async({scriptContainer:e,hash:t,witness:a})=>{let{verification:s}=a;if(0===s.length){const e=new n.ScriptBuilder;e.emitAppCallVerification(t),s=e.build()}else if(!n.common.uInt160Equal(t,n.crypto.toScriptHash(s)))throw new h.WitnessVerifyError;const r=this.createWriteBlockchain(),o=[];let d=new c.BN(0);const l=await this.vm.executeScripts({scripts:[{code:a.invocation},{code:s}],blockchain:r,scriptContainer:e,triggerType:i.TriggerType.Verification,action:i.NULL_ACTION,gas:i.utils.ONE_HUNDRED_MILLION,listeners:{onLog:({message:e,scriptHash:t})=>{o.push(new i.LogAction({index:d,scriptHash:t,message:e})),d=d.add(i.utils.ONE)},onNotify:({args:e,scriptHash:t})=>{o.push(new i.NotificationAction({index:d,scriptHash:t,args:e})),d=d.add(i.utils.ONE)}}}),u={actions:o,hash:t,witness:a},{stack:m,state:y,errorMessage:g}=l;return y===n.VMState.Fault?Object.assign(Object.assign({},u),{failureMessage:void 0===g?"Script execution ended in a FAULT state":g}):1!==m.length?Object.assign(Object.assign({},u),{failureMessage:`Verification did not return one result. This may be a bug in the smart contract compiler or the smart contract itself. If you are using the NEO•ONE compiler please file an issue. Found ${m.length} results.`}):m[0].asBoolean()?u:Object.assign(Object.assign({},u),{failureMessage:"Verification did not succeed."})},this.tryGetInvocationData=async e=>{const t=await this.invocationData.tryGet({hash:e.hash});if(void 0===t)return;const[a,s,n]=await Promise.all([void 0===t.assetHash?Promise.resolve(void 0):this.asset.get({hash:t.assetHash}),Promise.all(t.contractHashes.map(async e=>this.contract.tryGet({hash:e}))),t.actionIndexStart.eq(t.actionIndexStop)?Promise.resolve([]):this.action.getAll$({indexStart:t.actionIndexStart,indexStop:t.actionIndexStop.sub(i.utils.ONE)}).pipe(u.toArray()).toPromise()]);return{asset:a,contracts:s.filter(o.utils.notNull),deletedContractHashes:t.deletedContractHashes,migratedContractHashes:t.migratedContractHashes,voteUpdates:t.voteUpdates,result:t.result,actions:n,storageChanges:t.storageChanges}},this.tryGetTransactionData=async e=>this.transactionData.tryGet({hash:e.hash}),this.getUnclaimed=async e=>this.accountUnclaimed.getAll$({hash:e}).pipe(u.toArray()).toPromise().then(e=>e.map(e=>e.input)),this.getUnspent=async e=>(await this.accountUnspent.getAll$({hash:e}).pipe(u.toArray()).toPromise()).map(e=>e.input),this.getAllValidators=async()=>this.validator.all$.pipe(u.toArray()).toPromise(),this.isSpent=async e=>{const t=await this.transactionData.tryGet({hash:e.hash});return void 0!==t&&void 0!==t.endHeights[e.index]},this.tryGetSpentCoin=async e=>{const[t,a]=await Promise.all([this.transactionData.tryGet({hash:e.hash}),this.output.get(e)]);if(void 0===t)return;const s=t.endHeights[e.index];if(void 0===s)return;const n=t.claimed[e.index];return{output:a,startHeight:t.startHeight,endHeight:s,claimed:!!n}},this.storage=e.storage,this.mutableCurrentBlock=e.currentBlock,this.mutablePreviousBlock=e.previousBlock,this.mutableCurrentHeader=e.currentHeader,this.vm=e.vm,this.settings$=new l.BehaviorSubject(e.settings);const t=this;this.deserializeWireContext={get messageMagic(){return t.settings.messageMagic}},this.feeContext={get getOutput(){return t.output.get},get governingToken(){return t.settings.governingToken},get utilityToken(){return t.settings.utilityToken},get fees(){return t.settings.fees},get registerValidatorFee(){return t.settings.registerValidatorFee}},this.serializeJSONContext={get addressVersion(){return t.settings.addressVersion},get feeContext(){return t.feeContext},get tryGetInvocationData(){return t.tryGetInvocationData},get tryGetTransactionData(){return t.tryGetTransactionData},get getUnclaimed(){return t.getUnclaimed},get getUnspent(){return t.getUnspent}},this.start()}static async create({settings:e,storage:t,vm:a}){const[s,n]=await Promise.all([t.block.tryGetLatest(),t.header.tryGetLatest()]);let r;void 0!==s&&(r=await t.block.tryGet({hashOrIndex:s.index-1}));const i=new v({currentBlock:s,currentHeader:n,previousBlock:r,settings:e,storage:t,vm:a});return void 0===n&&await i.persistHeaders([e.genesisBlock.header]),void 0===s&&await i.persistBlock({block:e.genesisBlock}),i}get settings(){return this.settings$.getValue()}get currentBlock(){if(void 0===this.mutableCurrentBlock)throw new h.GenesisBlockNotRegisteredError;return this.mutableCurrentBlock}get previousBlock(){return this.mutablePreviousBlock}get currentHeader(){if(void 0===this.mutableCurrentHeader)throw new h.GenesisBlockNotRegisteredError;return this.mutableCurrentHeader}get currentBlockIndex(){return void 0===this.mutableCurrentBlock?-1:this.currentBlock.index}get block$(){return this.mutableBlock$}get isPersistingBlock(){return this.mutablePersistingBlocks}get account(){return this.storage.account}get accountUnclaimed(){return this.storage.accountUnclaimed}get accountUnspent(){return this.storage.accountUnspent}get action(){return this.storage.action}get asset(){return this.storage.asset}get block(){return this.storage.block}get blockData(){return this.storage.blockData}get header(){return this.storage.header}get transaction(){return this.storage.transaction}get transactionData(){return this.storage.transactionData}get output(){return this.storage.output}get contract(){return this.storage.contract}get storageItem(){return this.storage.storageItem}get validator(){return this.storage.validator}get invocationData(){return this.storage.invocationData}get validatorsCount(){return this.storage.validatorsCount}async stop(){if(this.mutableRunning){if(this.mutablePersistingBlocks){const e=new Promise(e=>{this.mutableDoneRunningResolve=e});this.mutableRunning=!1,await e,this.mutableDoneRunningResolve=void 0}else this.mutableRunning=!1;p.info({name:"neo_blockchain_stop"},"NEO blockchain stopped.")}}updateSettings(e){this.settings$.next(e)}async persistBlock({block:e,unsafe:t=!1}){return new Promise((a,s)=>{this.mutableInQueue.has(e.hashHex)?a():(this.mutableInQueue.add(e.hashHex),this.mutableBlockQueue.queue({block:e,resolve:a,reject:s,unsafe:t}),this.persistBlocksAsync())})}async persistHeaders(e){}async verifyBlock(e){await e.verify({genesisBlock:this.settings.genesisBlock,tryGetBlock:this.block.tryGet,tryGetHeader:this.header.tryGet,isSpent:this.isSpent,getAsset:this.asset.get,getOutput:this.output.get,tryGetAccount:this.account.tryGet,getValidators:this.getValidators,standbyValidators:this.settings.standbyValidators,getAllValidators:this.getAllValidators,calculateClaimAmount:async e=>this.calculateClaimAmount(e),verifyScript:async e=>this.verifyScript(e),currentHeight:void 0===this.mutableCurrentBlock?0:this.mutableCurrentBlock.index,governingToken:this.settings.governingToken,utilityToken:this.settings.utilityToken,fees:this.settings.fees,registerValidatorFee:this.settings.registerValidatorFee})}async verifyConsensusPayload(e){await e.verify({getValidators:async()=>this.getValidators([]),verifyScript:async e=>this.verifyScript(e),currentIndex:void 0===this.mutableCurrentBlock?0:this.mutableCurrentBlock.index,currentBlockHash:this.currentBlock.hash})}async verifyTransaction({transaction:e,memPool:t}){try{return{verifications:await e.verify({calculateClaimAmount:this.calculateClaimAmount,isSpent:this.isSpent,getAsset:this.asset.get,getOutput:this.output.get,tryGetAccount:this.account.tryGet,standbyValidators:this.settings.standbyValidators,getAllValidators:this.getAllValidators,verifyScript:async e=>this.verifyScript(e),governingToken:this.settings.governingToken,utilityToken:this.settings.utilityToken,fees:this.settings.fees,registerValidatorFee:this.settings.registerValidatorFee,currentHeight:this.currentBlockIndex,memPool:t})}}catch(e){if(void 0===e.code||"string"!=typeof e.code||!e.code.includes("VERIFY"))throw new h.UnknownVerifyError(e.message);throw e}}async invokeScript(e){const t=new i.InvocationTransaction({script:e,gas:n.common.ONE_HUNDRED_FIXED8});return this.invokeTransaction(t)}async invokeTransaction(e){const t=this.createWriteBlockchain(),a=[];let s=new c.BN(0);return{result:await y.wrapExecuteScripts(async()=>this.vm.executeScripts({scripts:[{code:e.script}],blockchain:t,scriptContainer:{type:i.ScriptContainerType.Transaction,value:e},listeners:{onLog:({message:e,scriptHash:t})=>{a.push(new i.LogAction({index:s,scriptHash:t,message:e})),s=s.add(i.utils.ONE)},onNotify:({args:e,scriptHash:t})=>{a.push(new i.NotificationAction({index:s,scriptHash:t,args:e})),s=s.add(i.utils.ONE)}},triggerType:i.TriggerType.Application,action:i.NULL_ACTION,gas:e.gas,skipWitnessVerify:!0})),actions:a}}async reset(){await this.stop(),await this.storage.reset(),this.mutableCurrentHeader=void 0,this.mutableCurrentBlock=void 0,this.mutablePreviousBlock=void 0,this.start(),await this.persistHeaders([this.settings.genesisBlock.header]),await this.persistBlock({block:this.settings.genesisBlock})}async persistBlocksAsync(){if(this.mutablePersistingBlocks||!this.mutableRunning)return;let e;this.mutablePersistingBlocks=!0;try{for(e=this.cleanBlockQueue();this.mutableRunning&&void 0!==e&&e.block.index===this.currentBlockIndex+1;){const t=e,a={[o.Labels.NEO_BLOCK_INDEX]:e.block.index,name:"neo_blockchain_persist_block_top_level"};try{await this.persistBlockInternal(t.block,t.unsafe),p.debug(a)}catch(e){throw p.error(Object.assign({err:e},a)),e}e.resolve(),this.mutableBlock$.next(e.block),e=this.cleanBlockQueue()}void 0!==e&&this.mutableBlockQueue.queue(e)}catch(t){void 0!==e&&e.reject(t)}finally{this.mutablePersistingBlocks=!1,void 0!==this.mutableDoneRunningResolve&&(this.mutableDoneRunningResolve(),this.mutableDoneRunningResolve=void 0)}}cleanBlockQueue(){let e=this.dequeBlockQueue();for(;void 0!==e&&e.block.index<=this.currentBlockIndex;)e.resolve(),e=this.dequeBlockQueue();return e}dequeBlockQueue(){if(this.mutableBlockQueue.length>0)return this.mutableBlockQueue.dequeue()}start(){this.mutableBlock$=new l.Subject,this.mutablePersistingBlocks=!1,this.mutableBlockQueue=new d.default({comparator:(e,t)=>e.block.index-t.block.index}),this.mutableInQueue=new Set,this.mutableDoneRunningResolve=void 0,this.mutableRunning=!0,p.info({name:"neo_blockchain_start"},"Neo blockchain started.")}async persistBlockInternal(e,t){t||await this.verifyBlock(e);const a=this.createWriteBlockchain();await a.persistBlock(e),await this.storage.commit(a.getChangeSet()),this.mutablePreviousBlock=this.mutableCurrentBlock,this.mutableCurrentBlock=e,this.mutableCurrentHeader=e.header}createWriteBlockchain(){return new g.WriteBatchBlockchain({settings:this.settings,currentBlock:this.mutableCurrentBlock,currentHeader:this.mutableCurrentHeader,storage:this.storage,vm:this.vm,getValidators:this.getValidators})}}t.Blockchain=v},1894:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createChild=t.getFinalLogger=t.setGlobalLogLevel=t.testLogger=t.httpLogger=t.cliLogger=t.rpcLogger=t.nodeLogger=t.serverLogger=t.editorLogger=void 0;const s=a(18),n=a(1895),r=s.__importDefault(a(1897)),i=(e,t={})=>void 0!==t.browser?r.default(Object.assign(Object.assign({},t),{base:{service:e},prettyPrint:n.getPretty()})):r.default(Object.assign(Object.assign({},t),{base:{service:e},prettyPrint:n.getPretty()}),r.default.extreme(1)),o="undefined"==typeof window&&"undefined"==typeof origin?{}:{browser:{asObject:!0}};t.editorLogger=i("editor-server",o),t.serverLogger=i("server",o),t.nodeLogger=i("node",o),t.rpcLogger=i("rpc",o),t.cliLogger=i("cli",o),t.httpLogger=i("http",o),t.testLogger=i("test",o);let c=[t.editorLogger,t.serverLogger,t.nodeLogger,t.rpcLogger,t.cliLogger,t.httpLogger,t.testLogger];t.setGlobalLogLevel=e=>c.forEach(t=>{t.level=e}),t.getFinalLogger=e=>r.default.final(e),t.createChild=(e,t)=>{const a=e.child(t);return c=c.concat(a),a}},1895:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),a(18).__exportStar(a(1896),t)},1896:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setPretty=t.getPretty=void 0;let s=!1;t.getPretty=()=>s,t.setPretty=e=>{s=e}},1899:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},1901:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ValidatorCache=void 0;const s=a(18),n=a(24),r=a(48),i=s.__importDefault(a(29)),o=a(88);t.ValidatorCache=class{constructor(e){this.blockchain=e,this.mutableAccounts={},this.mutableValidators={}}async getAccount(e){let t=this.mutableAccounts[n.common.uInt160ToHex(e)];return void 0===t&&(t=await this.blockchain.account.tryGet({hash:e})),void 0===t&&(t=new r.Account({hash:e})),this.mutableAccounts[n.common.uInt160ToHex(e)]=t,t}async updateAccountBalance(e,t,a){const s=n.common.uInt256ToHex(t);await this.getAccount(e);const r=n.common.uInt160ToHex(e),i=this.mutableAccounts[r],o=i.balances[s];this.mutableAccounts[r]=i.update({balances:Object.assign(Object.assign({},i.balances),{[s]:a.add(void 0===o?n.utils.ZERO:o)})})}async getValidator(e){const t=n.common.ecPointToHex(e);let a=this.mutableValidators[t];return void 0===a&&(a=await this.blockchain.validator.tryGet({publicKey:e})),void 0===a&&(a=new r.Validator({publicKey:e})),this.mutableValidators[t]=a,a}async addValidator(e){this.mutableValidators[n.common.ecPointToHex(e.publicKey)]=e}async deleteValidator(e){this.mutableValidators[n.common.ecPointToHex(e)]=void 0}async updateValidatorVotes(e,t){await this.getValidator(e);const a=n.common.ecPointToHex(e),s=this.mutableValidators[a];if(void 0===s)throw new Error("For Flow");this.mutableValidators[a]=s.update({votes:s.votes.add(t)})}async updateValidator(e,t){await this.getValidator(e);const a=n.common.ecPointToHex(e),s=this.mutableValidators[a];if(void 0===s)throw new Error("For Flow");const r=s.update(t);return this.mutableValidators[a]=r,r}async getAllValidators(){const e=await this.blockchain.validator.all$.pipe(o.toArray()).toPromise(),t=i.default.fromPairs(e.map(e=>[n.common.ecPointToHex(e.publicKey),e]));return Object.entries(this.mutableValidators).forEach(([e,a])=>{const s=n.common.ecPointToHex(e);void 0===a?delete t[s]:t[s]=a}),Object.values(t)}async getValidatorsCount(){let e=this.mutableValidatorsCount;return void 0===e&&(e=await this.blockchain.validatorsCount.tryGet()),void 0===e&&(e=new r.ValidatorsCount),this.mutableValidatorsCount=e,e}async updateValidatorsCountVotes(e,t){await this.getValidatorsCount();const a=this.mutableValidatorsCount;if(void 0===a)throw new Error("For Flow");const s=a.votes[e];this.mutableValidatorsCount=a.update({votes:a.votes.slice(0,e).concat((void 0===s?n.utils.ZERO:s).add(t)).concat(a.votes.slice(e+1))})}async addValidatorsCount(e){this.mutableValidatorsCount=e}async updateValidatorsCount(e){await this.getValidatorsCount();const t=this.mutableValidatorsCount;if(void 0===t)throw new Error("For Flow");return this.mutableValidatorsCount=t.update(e),this.mutableValidatorsCount}}},1902:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WriteBatchBlockchain=void 0;const s=a(18),n=a(24),r=a(48),i=a(25),o=a(43),c=s.__importDefault(a(29)),d=a(1517),l=a(1518),u=a(1903),h=a(1519);class m{constructor(e){this.settings=e.settings,this.currentBlockInternal=e.currentBlock,this.currentHeaderInternal=e.currentHeader,this.storage=e.storage,this.vm=e.vm,this.getValidators=e.getValidators;const t=new u.OutputStorageCache(()=>this.storage.output);this.caches={account:new u.ReadAllAddUpdateDeleteStorageCache({name:"account",readAllStorage:()=>this.storage.account,update:(e,t)=>e.update(t),getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt160ToString(e.hash),createAddChange:e=>({type:"account",value:e}),createDeleteChange:e=>({type:"account",key:e})}),accountUnspent:new u.ReadGetAllAddDeleteStorageCache({name:"accountUnspent",readGetAllStorage:()=>this.storage.accountUnspent,getKeyFromValue:e=>({hash:e.hash,input:e.input}),getKeyString:e=>`${n.common.uInt160ToString(e.hash)}:${n.common.uInt256ToString(e.input.hash)}:${e.input.index}`,matchesPartialKey:(e,t)=>n.common.uInt160Equal(e.hash,t.hash),createAddChange:e=>({type:"accountUnspent",value:e}),createDeleteChange:e=>({type:"accountUnspent",key:e})}),accountUnclaimed:new u.ReadGetAllAddDeleteStorageCache({name:"accountUnclaimed",readGetAllStorage:()=>this.storage.accountUnclaimed,getKeyFromValue:e=>({hash:e.hash,input:e.input}),getKeyString:e=>`${n.common.uInt160ToString(e.hash)}:${n.common.uInt256ToString(e.input.hash)}:${e.input.index}`,matchesPartialKey:(e,t)=>n.common.uInt160Equal(e.hash,t.hash),createAddChange:e=>({type:"accountUnclaimed",value:e}),createDeleteChange:e=>({type:"accountUnclaimed",key:e})}),action:new u.ReadGetAllAddStorageCache({name:"action",readGetAllStorage:()=>this.storage.action,getKeyFromValue:e=>({index:e.index}),getKeyString:e=>e.index.toString(10),matchesPartialKey:(e,t)=>(void 0===t.indexStart||e.index.gte(t.indexStart))&&(void 0===t.indexStop||e.index.lte(t.indexStop)),createAddChange:e=>({type:"action",value:e})}),asset:new u.ReadAddUpdateStorageCache({name:"asset",readStorage:()=>this.storage.asset,update:(e,t)=>e.update(t),getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt256ToString(e.hash),createAddChange:e=>({type:"asset",value:e})}),block:new u.BlockLikeStorageCache({name:"block",readStorage:()=>({get:this.storage.block.get,tryGet:this.storage.block.tryGet}),createAddChange:e=>({type:"block",value:e})}),blockData:new u.ReadAddStorageCache({name:"blockData",readStorage:()=>this.storage.blockData,getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt256ToString(e.hash),createAddChange:e=>({type:"blockData",value:e})}),header:new u.BlockLikeStorageCache({name:"header",readStorage:()=>({get:this.storage.header.get,tryGet:this.storage.header.tryGet}),createAddChange:e=>({type:"header",value:e})}),transaction:new u.ReadAddStorageCache({name:"transaction",readStorage:()=>this.storage.transaction,getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt256ToString(e.hash),createAddChange:e=>({type:"transaction",value:e}),onAdd:async e=>{await Promise.all(e.outputs.map(async(a,s)=>t.add({hash:e.hash,index:s,output:a})))},allowDupes:!0}),transactionData:new u.ReadAddUpdateStorageCache({name:"transactionData",readStorage:()=>this.storage.transactionData,update:(e,t)=>e.update(t),getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt256ToString(e.hash),createAddChange:e=>({type:"transactionData",value:e}),allowDupes:!0}),output:t,contract:new u.ReadAddDeleteStorageCache({name:"contract",readStorage:()=>this.storage.contract,getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt160ToString(e.hash),createAddChange:e=>({type:"contract",value:e}),createDeleteChange:e=>({type:"contract",key:e})}),storageItem:new u.ReadGetAllAddUpdateDeleteStorageCache({name:"storageItem",readGetAllStorage:()=>this.storage.storageItem,update:(e,t)=>e.update(t),getKeyFromValue:e=>({hash:e.hash,key:e.key}),getKeyString:e=>`${n.common.uInt160ToString(e.hash)}:${e.key.toString("hex")}`,matchesPartialKey:(e,t)=>(void 0===t.hash||n.common.uInt160Equal(e.hash,t.hash))&&(void 0===t.prefix||t.prefix.every((t,a)=>e.key[a]===t)),createAddChange:e=>({type:"storageItem",value:e}),createDeleteChange:e=>({type:"storageItem",key:e})}),validator:new u.ReadAllAddUpdateDeleteStorageCache({name:"validator",readAllStorage:()=>this.storage.validator,getKeyFromValue:e=>({publicKey:e.publicKey}),getKeyString:e=>n.common.ecPointToString(e.publicKey),createAddChange:e=>({type:"validator",value:e}),update:(e,t)=>e.update(t),createDeleteChange:e=>({type:"validator",key:e})}),invocationData:new u.ReadAddStorageCache({name:"invocationData",readStorage:()=>this.storage.invocationData,getKeyFromValue:e=>({hash:e.hash}),getKeyString:e=>n.common.uInt256ToString(e.hash),createAddChange:e=>({type:"invocationData",value:e})}),validatorsCount:new u.ReadAddUpdateMetadataStorageCache({name:"validatorsCount",readStorage:()=>this.storage.validatorsCount,createAddChange:e=>({type:"validatorsCount",value:e}),update:(e,t)=>e.update(t)})},this.account=this.caches.account,this.accountUnspent=this.caches.accountUnspent,this.accountUnclaimed=this.caches.accountUnclaimed,this.action=this.caches.action,this.asset=this.caches.asset,this.block=this.caches.block,this.blockData=this.caches.blockData,this.header=this.caches.header,this.transaction=this.caches.transaction,this.transactionData=this.caches.transactionData,this.output=this.caches.output,this.contract=this.caches.contract,this.storageItem=this.caches.storageItem,this.validator=this.caches.validator,this.invocationData=this.caches.invocationData,this.validatorsCount=this.caches.validatorsCount}get currentBlock(){if(void 0===this.currentBlockInternal)throw new d.GenesisBlockNotRegisteredError;return this.currentBlockInternal}get currentBlockIndex(){return void 0===this.currentBlockInternal?0:this.currentBlockInternal.index}get currentHeader(){if(void 0===this.currentHeaderInternal)throw new d.GenesisBlockNotRegisteredError;return this.currentHeaderInternal}getChangeSet(){return Object.values(this.caches).reduce((e,t)=>e.concat(t.getChangeSet()),[])}getTrackedChangeSet(){return Object.values(this.caches).reduce((e,t)=>e.concat(t.getTrackedChangeSet()),[])}async persistBlock(e){const[t,a]=await Promise.all([0===e.index?Promise.resolve(void 0):this.blockData.get({hash:e.previousHash}),Promise.all([...new Set(e.transactions.reduce((e,t)=>e.concat(t.outputs.map(e=>n.common.uInt160ToString(e.address))),[]))].map(async e=>this.contract.tryGet({hash:n.common.stringToUInt160(e)}))),this.block.add(e),this.header.add(e.header)]),s=void 0===t?{lastGlobalTransactionIndex:n.utils.NEGATIVE_ONE,lastGlobalActionIndex:n.utils.NEGATIVE_ONE,systemFee:n.utils.ZERO}:{lastGlobalTransactionIndex:t.lastGlobalTransactionIndex,lastGlobalActionIndex:t.lastGlobalActionIndex,systemFee:t.systemFee},d={};a.filter(i.utils.notNull).forEach(e=>{d[e.hashHex]=e});const[l,u]=c.default.partition(e.transactions.map((e,t)=>[t,e]),([e,t])=>(t.type===r.TransactionType.Claim&&t instanceof r.ClaimTransaction||t.type===r.TransactionType.Contract&&t instanceof r.ContractTransaction||t.type===r.TransactionType.Miner&&t instanceof r.MinerTransaction)&&!t.outputs.some(e=>void 0!==d[n.common.uInt160ToString(e.address)])),[h]=await Promise.all([u.length>0?this.persistTransactions(e,u,s.lastGlobalTransactionIndex,s.lastGlobalActionIndex):Promise.resolve(s.lastGlobalActionIndex),l.length>0?this.persistUTXOTransactions(e,l,s.lastGlobalTransactionIndex):Promise.resolve()]);await this.blockData.add(new r.BlockData({hash:e.hash,lastGlobalTransactionIndex:s.lastGlobalTransactionIndex.add(new o.BN(e.transactions.length)),lastGlobalActionIndex:h,systemFee:s.systemFee.add(e.getSystemFee({getOutput:this.output.get,governingToken:this.settings.governingToken,utilityToken:this.settings.utilityToken,fees:this.settings.fees,registerValidatorFee:this.settings.registerValidatorFee}))}))}async persistUTXOTransactions(e,t,a){const s=[],n=[],i=[];for(const e of t){const t=e[1];s.push(...t.inputs),t.type===r.TransactionType.Claim&&t instanceof r.ClaimTransaction&&n.push(...t.claims),i.push(...this.getOutputWithInput(t))}await Promise.all([Promise.all(t.map(async([e,t])=>this.transaction.add(t))),Promise.all(t.map(async([t,s])=>this.transactionData.add(new r.TransactionData({hash:s.hash,startHeight:e.index,blockHash:e.hash,index:t,globalIndex:a.add(new o.BN(t+1))})))),this.updateAccounts(s,n,i),this.updateCoins(s,n,e)])}async persistTransactions(e,t,a,s){let r=s.add(n.utils.ONE);for(const[s,n]of t)r=await this.persistTransaction(e,n,s,a,r);return r.sub(n.utils.ONE)}async persistTransaction(e,t,a,s,c){let d=c;const u=t,y=u.type===r.TransactionType.Claim&&u instanceof r.ClaimTransaction?u.claims:[];let g={},p={},v=[];if(u.type===r.TransactionType.State&&u instanceof r.StateTransaction&&({accountChanges:g,validatorChanges:p,validatorsCountChanges:v}=await l.getDescriptorChanges({transactions:[u],getAccount:async e=>this.account.tryGet({hash:e}).then(t=>void 0===t?new r.Account({hash:e}):t),governingTokenHash:this.settings.governingToken.hashHex})),await Promise.all([this.transaction.add(u),this.transactionData.add(new r.TransactionData({hash:u.hash,blockHash:e.hash,startHeight:e.index,index:a,globalIndex:s.add(new o.BN(a+1))})),this.updateAccounts(u.inputs,y,this.getOutputWithInput(u),g),this.updateCoins(u.inputs,y,e),this.processStateTransaction(p,v)]),u.type===r.TransactionType.Register&&u instanceof r.RegisterTransaction)await this.asset.add(new r.Asset({hash:u.hash,type:u.asset.type,name:u.asset.name,amount:u.asset.amount,precision:u.asset.precision,owner:u.asset.owner,admin:u.asset.admin,issuer:u.asset.admin,expiration:this.currentBlockIndex+4e6,isFrozen:!1}));else if(u.type===r.TransactionType.Issue&&u instanceof r.IssueTransaction){const e=await Promise.all(Object.entries(u.getTransactionResults({getOutput:this.output.get})));await Promise.all(e.map(async([e,t])=>{const a=n.common.stringToUInt256(e),s=await this.asset.get({hash:a});await this.asset.update(s,{available:s.available.add(t.neg())})}))}else if(u.type===r.TransactionType.Enrollment&&u instanceof r.EnrollmentTransaction)await this.validator.add(new r.Validator({publicKey:u.publicKey}));else if(u.type===r.TransactionType.Publish&&u instanceof r.PublishTransaction){void 0===await this.contract.tryGet({hash:u.contract.hash})&&await this.contract.add(u.contract)}else if(u.type===r.TransactionType.Invocation&&u instanceof r.InvocationTransaction){const t=new m({settings:this.settings,currentBlock:this.currentBlockInternal,currentHeader:this.currentHeader,storage:this,vm:this.vm,getValidators:this.getValidators}),s=[],o=[],l=[],y=await h.wrapExecuteScripts(async()=>this.vm.executeScripts({scripts:[{code:u.script}],blockchain:t,scriptContainer:{type:r.ScriptContainerType.Transaction,value:u},triggerType:r.TriggerType.Application,action:{blockIndex:e.index,blockHash:e.hash,transactionIndex:a,transactionHash:u.hash},gas:u.gas,listeners:{onLog:({message:e,scriptHash:t})=>{l.push(new r.LogAction({index:d,scriptHash:t,message:e})),d=d.add(n.utils.ONE)},onNotify:({args:e,scriptHash:t})=>{l.push(new r.NotificationAction({index:d,scriptHash:t,args:e})),d=d.add(n.utils.ONE)},onMigrateContract:({from:e,to:t})=>{s.push([e,t])},onSetVotes:({address:e,votes:t})=>{o.push([e,t])}},persistingBlock:e})),g=Promise.all(l.map(async e=>this.action.add(e)));if(y instanceof r.InvocationResultSuccess){const n=t.asset.getChangeSet().map(e=>"add"===e.type&&"asset"===e.change.type?e.change.value.hash:void 0).find(e=>void 0!==e),l=t.contract.getChangeSet(),h=l.map(e=>"add"===e.type&&"contract"===e.change.type?e.change.value.hash:void 0).filter(i.utils.notNull),m=l.map(e=>"delete"===e.type&&"contract"===e.change.type?e.change.key.hash:void 0).filter(i.utils.notNull),p=t.storageItem.getChangeSet().map(e=>{const t="add"===e.type&&"storageItem"===e.change.type?{value:e.change.value,subType:e.subType}:void 0;if(void 0!==t){const e={hash:t.value.hash,key:t.value.key,value:t.value.value};return"add"===t.subType?new r.StorageChangeAdd(e):new r.StorageChangeModify(e)}const a="delete"===e.type&&"storageItem"===e.change.type?e.change.key:void 0;if(void 0!==a)return new r.StorageChangeDelete(a)}).filter(i.utils.notNull);t.getTrackedChangeSet().forEach(e=>{this.caches[e.type].addTrackedChange(e.key,e.value)}),await Promise.all([this.invocationData.add(new r.InvocationData({hash:u.hash,assetHash:n,contractHashes:h,deletedContractHashes:m,migratedContractHashes:s,voteUpdates:o,blockIndex:e.index,transactionIndex:a,actionIndexStart:c,actionIndexStop:d,result:y,storageChanges:p})),g])}else await Promise.all([this.invocationData.add(new r.InvocationData({hash:u.hash,assetHash:void 0,contractHashes:[],deletedContractHashes:[],migratedContractHashes:[],voteUpdates:[],blockIndex:e.index,transactionIndex:a,actionIndexStart:c,actionIndexStop:d,result:y,storageChanges:[]})),g])}return d}async processStateTransaction(e,t){const a=await this.validatorsCount.tryGet(),s=void 0===a?[]:[...a.votes];for(const[e,a]of t.entries())s[e]=a;await Promise.all([Promise.all(Object.entries(e).map(async([e,{registered:t,votes:a}])=>{const s=n.common.hexToECPoint(e),i=await this.validator.tryGet({publicKey:s});void 0===i?await this.validator.add(new r.Validator({publicKey:s,registered:t,votes:a})):(void 0!==t&&!t||void 0===t&&!i.registered)&&(void 0!==a&&a.eq(n.utils.ZERO)||void 0===a&&i.votes.eq(n.utils.ZERO))?await this.validator.delete({publicKey:i.publicKey}):await this.validator.update(i,{votes:a,registered:t})})),void 0===a?this.validatorsCount.add(new r.ValidatorsCount({votes:s})):(async()=>{await this.validatorsCount.update(a,{votes:s})})()])}async updateAccounts(e,t,a,s={}){const[r,i]=await Promise.all([this.getInputOutputs(e),this.getInputOutputs(t)]),o=Object.entries(c.default.groupBy(r.map(({output:e})=>[e.address,e.asset,e.value.neg()]).concat(a.map(({output:e})=>[e.address,e.asset,e.value])),([e])=>n.common.uInt160ToHex(e))),d=this.groupByAddress(r),l=c.default.mapValues(this.groupByAddress(i),e=>e.map(({input:e})=>e)),u=c.default.groupBy(a,e=>n.common.uInt160ToHex(e.output.address));await Promise.all(o.map(async([e,t])=>{const a=d[e],r=l[e],i=u[e],o=s[e];await this.updateAccount(n.common.hexToUInt160(e),t.map(([e,t,a])=>[t,a]),void 0===a?[]:a,void 0===r?[]:r,void 0===i?[]:i,void 0===o?[]:o)}))}getOutputWithInput(e){return e.outputs.map((t,a)=>({output:t,input:new r.Input({hash:e.hash,index:a})}))}async getInputOutputs(e){return Promise.all(e.map(async e=>({input:e,output:await this.output.get(e)})))}groupByAddress(e){return c.default.groupBy(e,({output:e})=>n.common.uInt160ToHex(e.address))}async updateAccount(e,t,a,s,i,o){const c=await this.account.tryGet({hash:e}),d=t.reduce((e,[t,a])=>{const s=n.common.uInt256ToHex(t);return void 0===e[s]&&(e[s]=n.utils.ZERO),e[s]=e[s].add(a),e},void 0===c?{}:Object.entries(c.balances).reduce((e,[t,a])=>void 0===a?Object.assign(Object.assign({},e),{[t]:n.utils.ZERO}):Object.assign(Object.assign({},e),{[t]:a}),{})),l=[];l.push(...a.map(async({input:t})=>this.accountUnspent.delete({hash:e,input:t}))),l.push(...i.map(async({input:t})=>this.accountUnspent.add(new r.AccountUnspent({hash:e,input:t})))),l.push(...s.map(async t=>this.accountUnclaimed.delete({hash:e,input:t}))),l.push(...a.filter(({output:e})=>n.common.uInt256Equal(e.asset,this.settings.governingToken.hash)).map(async({input:t})=>this.accountUnclaimed.add(new r.AccountUnclaimed({hash:e,input:t})))),void 0===c?l.push(this.account.add(new r.Account({hash:e,balances:d,votes:o}))):l.push(this.account.update(c,{balances:d,votes:o}).then(async t=>{t.isDeletable()&&await this.account.delete({hash:e})})),await Promise.all(l)}async updateCoins(e,t,a){const s=e.map(e=>({type:"input",input:e,hash:e.hash})).concat(t.map(e=>({type:"claim",input:e,hash:e.hash}))),r=Object.entries(c.default.groupBy(s,({hash:e})=>n.common.uInt256ToHex(e)));await Promise.all(r.map(async([e,t])=>this.updateCoin(n.common.hexToUInt256(e),t,a)))}async updateCoin(e,t,a){const s=await this.transactionData.get({hash:e}),n=Object.assign({},s.endHeights),r=Object.assign({},s.claimed);for(const e of t)"input"===e.type?n[e.input.index]=a.index:r[e.input.index]=!0;await this.transactionData.update(s,{endHeights:n,claimed:r})}}t.WriteBatchBlockchain=m},1903:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ReadAddUpdateMetadataStorageCache=t.BaseReadMetadataStorageCache=t.OutputStorageCache=t.BlockLikeStorageCache=t.ReadAllAddStorageCache=t.ReadAllAddUpdateDeleteStorageCache=t.ReadGetAllAddStorageCache=t.ReadGetAllAddUpdateDeleteStorageCache=t.ReadGetAllAddDeleteStorageCache=t.ReadAddStorageCache=t.ReadAddDeleteStorageCache=t.ReadAddUpdateStorageCache=t.ReadAddUpdateDeleteStorageCache=t.BaseReadStorageCache=void 0;const s=a(24),n=a(25),r=a(77),i=a(88);class o{constructor(e){this.readStorage=e.readStorage,this.name=e.name,this.createAddChange=e.createAddChange,this.createDeleteChange=e.createDeleteChange,this.onAdd=e.onAdd,this.mutableValues={},this.get=function({tryGetTracked:e,readStorage:t}){return async a=>{const s=e(a);if(void 0!==s){if("delete"===s.type)throw new Error("Not found");return s.value}return t().get(a)}}({readStorage:this.readStorage,tryGetTracked:this.tryGetTracked.bind(this)}),this.tryGet=function({tryGetTracked:e,readStorage:t}){return async a=>{const s=e(a);if(void 0!==s){if("delete"===s.type)return;return s.value}return t().tryGet(a)}}({readStorage:this.readStorage,tryGetTracked:this.tryGetTracked.bind(this)}),this.tryGetValue=e=>this.readStorage().tryGet(e)}getChangeSet(){const e=this.createDeleteChange;return Object.values(this.mutableValues).map(t=>{if("delete"===t.type){if(void 0===e)throw new Error("Invalid delete");return{type:"delete",change:e(t.key)}}return{type:"add",change:this.createAddChange(t.addValue),subType:t.subType}})}getTrackedChangeSet(){const e=this.createDeleteChange;return Object.entries(this.mutableValues).map(([t,a])=>{if("delete"===a.type){if(void 0===e)throw new Error("Invalid delete");return{type:e(a.key).type,key:t,value:a}}return{type:this.createAddChange(a.addValue).type,key:t,value:a}})}tryGetTracked(e){throw new Error("Not Implemented")}}t.BaseReadStorageCache=o;class c extends o{constructor(e){super({readStorage:e.readStorage,name:e.name,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.getKeyString=e.getKeyString}tryGetTracked(e){return this.mutableValues[this.getKeyString(e)]}addTrackedChange(e,t){this.mutableValues[e]=t}}class d extends c{constructor(e){super({readStorage:()=>({get:e.readAllStorage().get,tryGet:e.readAllStorage().tryGet}),name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.readAllStorage=e.readAllStorage,this.getKeyFromValue=e.getKeyFromValue,this.all$=r.concat(r.defer(()=>this.readAllStorage().all$.pipe(i.concatMap(e=>void 0!==this.tryGetTracked(this.getKeyFromValue(e))?r.EMPTY:r.of(e)))),r.defer(()=>r.of(...Object.values(this.mutableValues).map(e=>"add"===e.type?e.value:void 0).filter(n.utils.notNull))))}}class l extends c{constructor(e){super({readStorage:()=>({get:e.readGetAllStorage().get,tryGet:e.readGetAllStorage().tryGet}),name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.readGetAllStorage=e.readGetAllStorage,this.getKeyFromValue=e.getKeyFromValue,this.matchesPartialKey=e.matchesPartialKey,this.getAll$=e=>r.concat(r.defer(()=>this.readGetAllStorage().getAll$(e).pipe(i.concatMap(e=>void 0!==this.tryGetTracked(this.getKeyFromValue(e))?r.EMPTY:r.of(e)))),r.defer(()=>r.of(...Object.values(this.mutableValues).map(t=>"add"===t.type&&this.matchesPartialKey(t.value,e)?t.value:void 0).filter(n.utils.notNull))))}}function u({cache:e,getKeyFromValue:t,getKeyString:a,allowDupes:s}){return async n=>{const r=t(n);if(!s){if(void 0!==await e.tryGet(r))throw new Error(`Attempted to add an already existing object for key ${e.name}:${a(r)}.`)}void 0!==e.onAdd&&await e.onAdd(n);const i=e.tryGetTracked(r);e.mutableValues[e.getKeyString(r)]={type:"add",addValue:n,value:n,subType:void 0===i?"add":"update"}}}function h({cache:e,update:t,getKeyFromValue:a}){return async(s,n)=>{const r=a(s),i=t(s,n),o=e.tryGetTracked(r);return e.mutableValues[e.getKeyString(r)]={type:"add",addValue:i,value:i,subType:void 0===o||"delete"===o.type||"update"===o.subType?"update":"add"},i}}function m({cache:e}){return async t=>{void 0===await e.tryGetValue(t)?delete e.mutableValues[e.getKeyString(t)]:e.mutableValues[e.getKeyString(t)]={type:"delete",key:t}}}t.ReadAddUpdateDeleteStorageCache=class extends c{constructor(e){super({readStorage:e.readStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString}),this.update=h({cache:this,update:e.update,getKeyFromValue:e.getKeyFromValue}),this.delete=m({cache:this})}};t.ReadAddUpdateStorageCache=class extends c{constructor(e){super({readStorage:e.readStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString,allowDupes:e.allowDupes}),this.update=h({cache:this,update:e.update,getKeyFromValue:e.getKeyFromValue})}};t.ReadAddDeleteStorageCache=class extends c{constructor(e){super({readStorage:e.readStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString}),this.delete=m({cache:this})}};t.ReadAddStorageCache=class extends c{constructor(e){super({readStorage:e.readStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString,allowDupes:e.allowDupes})}};t.ReadGetAllAddDeleteStorageCache=class extends l{constructor(e){super({readGetAllStorage:e.readGetAllStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd,getKeyFromValue:e.getKeyFromValue,matchesPartialKey:e.matchesPartialKey}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString}),this.delete=m({cache:this})}};t.ReadGetAllAddUpdateDeleteStorageCache=class extends l{constructor(e){super({readGetAllStorage:e.readGetAllStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd,getKeyFromValue:e.getKeyFromValue,matchesPartialKey:e.matchesPartialKey}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString}),this.update=h({cache:this,update:e.update,getKeyFromValue:e.getKeyFromValue}),this.delete=m({cache:this})}};t.ReadGetAllAddStorageCache=class extends l{constructor(e){super({readGetAllStorage:e.readGetAllStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd,getKeyFromValue:e.getKeyFromValue,matchesPartialKey:e.matchesPartialKey}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString})}};t.ReadAllAddUpdateDeleteStorageCache=class extends d{constructor(e){super({readAllStorage:e.readAllStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd,getKeyFromValue:e.getKeyFromValue}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString}),this.update=h({cache:this,update:e.update,getKeyFromValue:e.getKeyFromValue}),this.delete=m({cache:this})}};t.ReadAllAddStorageCache=class extends d{constructor(e){super({readAllStorage:e.readAllStorage,name:e.name,getKeyString:e.getKeyString,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd,getKeyFromValue:e.getKeyFromValue}),this.add=u({cache:this,getKeyFromValue:e.getKeyFromValue,getKeyString:e.getKeyString})}};t.BlockLikeStorageCache=class extends o{constructor(e){super({readStorage:e.readStorage,name:e.name,createAddChange:e.createAddChange}),this.mutableIndexValues={}}async add(e){if(void 0!==await this.tryGet({hashOrIndex:e.index}))throw new Error("Attempted to add an already existing object.");const t={type:"add",addValue:e,value:e,subType:"add"};this.mutableValues[s.common.uInt256ToString(e.hash)]=t,this.mutableIndexValues[""+e.index]=t}tryGetTracked(e){return"number"!=typeof e.hashOrIndex?this.mutableValues[s.common.uInt256ToString(e.hashOrIndex)]:this.mutableIndexValues[""+e.hashOrIndex]}addTrackedChange(e,t){this.mutableValues[e]=t}};const y=e=>`${s.common.uInt256ToHex(e.hash)}:${e.index}`;t.OutputStorageCache=class extends c{constructor(e){super({readStorage:e,name:"output",getKeyString:y,createAddChange:e=>({type:"output",value:e})}),this.add=async e=>{const t={hash:e.hash,index:e.index};if(void 0!==await this.tryGet(t))throw new Error(`Attempted to add an already existing object for key ${this.name}:${this.getKeyString(t)}.`);this.mutableValues[this.getKeyString(t)]={type:"add",addValue:e,value:e.output,subType:"add"}}}};class g{constructor(e){this.readStorage=e.readStorage,this.name=e.name,this.createAddChange=e.createAddChange,this.createDeleteChange=e.createDeleteChange,this.onAdd=e.onAdd,this.get=function({tryGetTracked:e,readStorage:t}){return async()=>{const a=e();if(void 0!==a){if("delete"===a.type)throw new Error("Not found");return a.value}return t().get()}}({readStorage:this.readStorage,tryGetTracked:this.tryGetTracked.bind(this)}),this.tryGet=function({tryGetTracked:e,readStorage:t}){return async()=>{const a=e();if(void 0!==a){if("delete"===a.type)return;return a.value}return t().tryGet()}}({readStorage:this.readStorage,tryGetTracked:this.tryGetTracked.bind(this)})}getChangeSet(){const e=this.createDeleteChange,t=this.mutableValue;if(void 0===t)return[];if("delete"===t.type){if(void 0===e)throw new Error("Invalid delete");return[{type:"delete",change:e()}]}return[{type:"add",change:this.createAddChange(t.addValue),subType:t.subType}]}getTrackedChangeSet(){const e=this.createDeleteChange,t=this.mutableValue;if(void 0===t)return[];if("delete"===t.type){if(void 0===e)throw new Error("Invalid delete");return[{type:e().type,key:"metadata",value:Object.assign(Object.assign({},t),{key:"metadata"})}]}return[{type:this.createAddChange(t.addValue).type,key:"metadata",value:t}]}tryGetTracked(){return this.mutableValue}addTrackedChange(e,t){this.mutableValue=t}}t.BaseReadMetadataStorageCache=g;class p extends g{}t.ReadAddUpdateMetadataStorageCache=class extends p{constructor(e){super({readStorage:e.readStorage,name:e.name,createAddChange:e.createAddChange,createDeleteChange:e.createDeleteChange,onAdd:e.onAdd}),this.add=function({cache:e}){return async t=>{void 0!==e.onAdd&&await e.onAdd(t),e.mutableValue={type:"add",addValue:t,value:t,subType:"add"}}}({cache:this}),this.update=function({cache:e,update:t}){return async(a,s)=>{const n=t(a,s);return e.mutableValue={type:"add",addValue:n,value:n,subType:"update"},n}}({cache:this,update:e.update})}}},1904:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1905);Object.defineProperty(t,"Node",{enumerable:!0,get:function(){return s.Node}})},1905:function(e,t,a){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.Node=void 0;const s=a(18),n=a(24),r=a(992),i=a(1906),o=a(48),c=a(25),d=a(1920),l=s.__importDefault(a(1923)),u=s.__importDefault(a(1301)),h=a(1526),m=s.__importDefault(a(29)),y=s.__importDefault(a(1932)),g=a(1533),p=a(1935),v=a(1936),b=a(1534),f=r.createChild(r.nodeLogger,{component:"node-protocol"}),w=()=>new d.ScalingBloem(.05,{initial_capacity:1e5,scaling:4}),k=(e,t)=>{const a=e.networkFee.divn(e.transaction.size),s=t.networkFee.divn(t.transaction.size);return a.lt(s)?-1:s.lt(a)?1:e.transaction.hash.compare(t.transaction.hash)},x=new Set(["","0.0.0.0","localhost","127.0.0.1","::","::1"]);t.Node=class{constructor({blockchain:e,createNetwork:t,options:a}){this.mutableUnhealthyPeerSeconds=300,this.requestBlocks=m.default.debounce(()=>{const e=this.mutableBestPeer,t=this.blockchain.previousBlock,a=void 0===t?this.blockchain.currentBlock:t;void 0!==e&&a.index<e.data.startHeight&&(this.mutableGetBlocksRequestsCount>2?(this.mutableBestPeer=this.findBestPeer(e),this.network.blacklistAndClose(e),this.mutableGetBlocksRequestsCount=0):this.shouldRequestBlocks()&&(this.mutableGetBlocksRequestsIndex===a.index?this.mutableGetBlocksRequestsCount+=1:(this.mutableGetBlocksRequestsCount=1,this.mutableGetBlocksRequestsIndex=a.index),this.mutableGetBlocksRequestTime=Date.now(),this.sendMessage(e,this.createMessage({command:g.Command.getblocks,payload:new b.GetBlocksPayload({hashStart:[a.hash]})}))),this.requestBlocks())},1e3),this.onRequestEndpoints=m.default.throttle(()=>{this.relay(this.createMessage({command:g.Command.getaddr})),this.fetchEndpointsFromRPC()},5e3),this.trimMemPool=m.default.throttle(async()=>{const e=Object.values(this.mutableMemPool);if(e.length>5e3){const t=await Promise.all(e.map(async e=>{const t=await e.getNetworkFee({getOutput:this.blockchain.output.get,governingToken:this.blockchain.settings.governingToken,utilityToken:this.blockchain.settings.utilityToken,fees:this.blockchain.settings.fees,registerValidatorFee:this.blockchain.settings.registerValidatorFee});return{transaction:e,networkFee:t}}));m.default.take(t.slice().sort(k),this.blockchain.settings.memPoolSize).map(e=>e.transaction.hashHex).forEach(e=>{delete this.mutableMemPool[e]})}},5e3),this.negotiate=async e=>{this.sendMessage(e,this.createMessage({command:g.Command.version,payload:new b.VersionPayload({protocolVersion:0,services:b.SERVICES.NODE_NETWORK,timestamp:Math.round(Date.now()/1e3),port:this.externalPort,nonce:this.nonce,userAgent:this.userAgent,startHeight:this.blockchain.currentBlockIndex,relay:!0})}));const t=await e.receiveMessage(3e4);let a;if(t.value.command!==g.Command.version)throw new p.NegotiationError(t);a=t.value.payload,this.checkVersion(e,t,a);const{host:s}=o.getEndpointConfig(e.endpoint);let n;b.NetworkAddress.isValid(s)&&(n=new b.NetworkAddress({host:s,port:a.port,timestamp:a.timestamp,services:a.services})),this.sendMessage(e,this.createMessage({command:g.Command.verack}));const r=await e.receiveMessage(3e4);if(r.value.command!==g.Command.verack)throw new p.NegotiationError(r);return{data:{nonce:a.nonce,startHeight:a.startHeight,mutableBloomFilter:void 0,address:n},relay:a.relay}},this.checkPeerHealth=(e,t)=>{const a=c.utils.nowSeconds(),s=this.mutableBlockIndex[e.endpoint];return void 0===t||void 0!==t.blockIndex&&void 0!==s&&t.blockIndex<s?{healthy:!0,checkTimeSeconds:a,blockIndex:s}:t.blockIndex===s&&c.utils.nowSeconds()-t.checkTimeSeconds<this.mutableUnhealthyPeerSeconds?{healthy:!0,checkTimeSeconds:t.checkTimeSeconds,blockIndex:t.blockIndex}:{healthy:!1,checkTimeSeconds:a,blockIndex:s}},this.onEvent=e=>{if("PEER_CONNECT_SUCCESS"===e.event){const{connectedPeer:t}=e;(void 0===this.mutableBestPeer||this.mutableBestPeer.data.startHeight+100<t.data.startHeight)&&(this.mutableBestPeer=t,this.resetRequestBlocks(),this.requestBlocks())}else"PEER_CLOSED"===e.event&&void 0!==this.mutableBestPeer&&this.mutableBestPeer.endpoint===e.peer.endpoint&&(this.mutableBestPeer=this.findBestPeer(),this.resetRequestBlocks(),this.requestBlocks())},this.blockchain=e,this.network=t({negotiate:this.negotiate,checkPeerHealth:this.checkPeerHealth,createMessageTransform:()=>new v.MessageTransform(this.blockchain.deserializeWireContext),onMessageReceived:(e,t)=>{this.onMessageReceived(e,t)},onRequestEndpoints:this.onRequestEndpoints.bind(this),onEvent:this.onEvent}),this.options=a;const{externalPort:s=0}=a;this.externalPort=s,this.nonce=Math.floor(Math.random()*n.utils.UINT_MAX_NUMBER),this.userAgent="NEO:neo-one-js:1.0.0-preview",this.mutableMemPool={},this.mutableKnownBlockHashes=w(),this.tempKnownBlockHashes=new Set,this.mutableKnownTransactionHashes=w(),this.tempKnownTransactionHashes=new Set,this.mutableKnownHeaderHashes=w(),this.tempKnownHeaderHashes=new Set,this.mutableGetBlocksRequestsCount=1,this.consensusCache=new y.default(1e4),this.mutableBlockIndex={}}get consensus(){return this.mutableConsensus}get connectedPeers(){return this.network.connectedPeers.map(e=>e.endpoint)}get memPool(){return this.mutableMemPool}async reset(){this.mutableMemPool={},this.mutableKnownBlockHashes=w(),this.tempKnownBlockHashes.clear(),this.mutableKnownTransactionHashes=w(),this.tempKnownTransactionHashes.clear(),this.mutableKnownHeaderHashes=w(),this.tempKnownHeaderHashes.clear(),this.mutableGetBlocksRequestsCount=1,this.consensusCache.reset(),this.mutableBlockIndex={}}async start(){let e=c.noopDisposable;try{if(this.network.start(),f.debug({name:"neo_protocol_start"},"Protocol started."),e=c.composeDisposables(e,()=>{this.network.stop(),f.debug({name:"neo_protocol_stop"},"Protocol stopped.")}),void 0!==this.options.consensus){const t=new i.Consensus({options:this.options.consensus,node:this});this.mutableConsensus=t;const a=await t.start();e=c.composeDisposables(e,a)}return this.mutableUnhealthyPeerSeconds=void 0===this.options.unhealthyPeerSeconds?300:this.options.unhealthyPeerSeconds,e}catch(t){throw await e(),t}}async relayTransaction(e,{throwVerifyError:t=!1,forceAdd:a=!1}={throwVerifyError:!1,forceAdd:!1}){const s={};if(e.type===o.TransactionType.Miner||void 0!==this.mutableMemPool[e.hashHex]||this.tempKnownTransactionHashes.has(e.hashHex))return s;if(!this.mutableKnownTransactionHashes.has(e.hash)){this.tempKnownTransactionHashes.add(e.hashHex);try{if(Object.values(this.mutableMemPool).length>2500&&!a)return this.mutableKnownTransactionHashes.add(e.hash),s;let t,n={[c.Labels.NEO_TRANSACTION_HASH]:e.hashHex};try{let a,s;try{a=await this.blockchain.transaction.tryGet({hash:e.hash})}finally{n=Object.assign({[c.Labels.NEO_TRANSACTION_FOUND]:void 0!==a},n)}if(void 0===a){s=await this.blockchain.verifyTransaction({transaction:e,memPool:Object.values(this.mutableMemPool)}),s.verifications.every(({failureMessage:e})=>void 0===e)&&(this.mutableMemPool[e.hashHex]=e,void 0!==this.mutableConsensus&&this.mutableConsensus.onTransactionReceived(e),this.relayTransactionInternal(e),await this.trimMemPool())}this.mutableKnownTransactionHashes.add(e.hash),t={verifyResult:s},f.debug(Object.assign({name:"neo_relay_transaction"},n))}catch(e){throw f.error(Object.assign({name:"neo_relay_transaction",err:e},n)),e}return t}catch(e){if(void 0===e.code||"string"!=typeof e.code||!e.code.includes("VERIFY")||t)throw e}finally{this.tempKnownTransactionHashes.delete(e.hashHex)}}return s}async relayStrippedTransaction(e,t,{throwVerifyError:a=!1,forceAdd:s=!1}={throwVerifyError:!1,forceAdd:!1}){const n={};if(e.type!==o.TransactionType.Invocation||t.type!==o.TransactionType.Invocation)throw new p.InvalidRelayStrippedTransactionType(e.type);if(e.inputs.length!==t.inputs.length||e.outputs.length!==t.outputs.length||!m.default.zip(e.inputs,t.inputs).every(([e,t])=>e.equals(t))||!m.default.zip(e.outputs,t.outputs).every(([e,t])=>e.equals(t))||!e.script.equals(t.script))throw new p.RelayStrippedTransactionMismatch;if(!this.mutableKnownTransactionHashes.has(t.hash)){this.tempKnownTransactionHashes.add(t.hashHex);try{if(Object.values(this.mutableMemPool).length>2500&&!s)return this.mutableKnownTransactionHashes.add(t.hash),n;let a,r={[c.Labels.NEO_TRANSACTION_HASH]:t.hashHex};try{let s,n;try{s=await this.blockchain.transaction.tryGet({hash:t.hash})}finally{r=Object.assign({[c.Labels.NEO_TRANSACTION_FOUND]:void 0!==s},r)}if(void 0===s){n=await this.blockchain.verifyTransaction({transaction:e,memPool:Object.values(this.mutableMemPool)}),n.verifications.every(({failureMessage:e})=>void 0===e)&&(this.mutableMemPool[t.hashHex]=t,void 0!==this.mutableConsensus&&this.mutableConsensus.onTransactionReceived(t),this.relayTransactionInternal(t),await this.trimMemPool())}this.mutableKnownTransactionHashes.add(t.hash),a={verifyResult:n},f.debug(Object.assign({name:"neo_relay_transaction"},r))}catch(e){throw f.error(Object.assign({name:"neo_relay_transaction",err:e},r)),e}return a}catch(e){if(void 0===e.code||"string"!=typeof e.code||!e.code.includes("VERIFY")||a)throw e}finally{this.tempKnownTransactionHashes.delete(t.hashHex)}}return n}async relayBlock(e){await this.persistBlock(e)}relayConsensusPayload(e){const t=this.createMessage({command:g.Command.inv,payload:new b.InvPayload({type:b.InventoryType.Consensus,hashes:[e.hash]})});this.consensusCache.set(e.hashHex,e),this.relay(t)}syncMemPool(){this.relay(this.createMessage({command:g.Command.mempool}))}relay(e){this.network.relay(e.serializeWire())}relayTransactionInternal(e){const t=this.createMessage({command:g.Command.inv,payload:new b.InvPayload({type:b.InventoryType.Transaction,hashes:[e.hash]})}).serializeWire();this.network.connectedPeers.forEach(a=>{a.relay&&this.testFilter(a.data.mutableBloomFilter,e)&&a.write(t)})}sendMessage(e,t){e.write(t.serializeWire())}findBestPeer(e){let t=this.network.connectedPeers;void 0!==e&&(t=t.filter(t=>t.endpoint!==e.endpoint));const a=m.default.maxBy(t,e=>e.data.startHeight);if(void 0!==a)return m.default.shuffle(t.filter(e=>e.data.startHeight===a.data.startHeight))[0]}resetRequestBlocks(){this.mutableGetBlocksRequestsIndex=void 0,this.mutableGetBlocksRequestsCount=0}shouldRequestBlocks(){const e=this.blockchain.currentBlock,t=this.mutableGetBlocksRequestTime;return void 0===this.mutableGetBlocksRequestsIndex||e.index-this.mutableGetBlocksRequestsIndex>500/3||void 0===t||Date.now()-t>1e4}checkVersion(e,t,a){if(a.nonce===this.nonce)throw this.network.permanentlyBlacklist(e.endpoint),new p.NegotiationError(t,"Nonce equals my nonce.");if(void 0!==this.network.connectedPeers.find(e=>a.nonce===e.data.nonce))throw new p.AlreadyConnectedError("Already connected to nonce.")}ready(){const e=this.mutableBestPeer,t=this.blockchain.currentBlock;return void 0!==e&&t.index>=e.data.startHeight}async fetchEndpointsFromRPC(){try{await this.doFetchEndpointsFromRPC()}catch(e){}}async doFetchEndpointsFromRPC(){const{rpcURLs:e=[]}=this.options;await Promise.all(e.map(async e=>this.fetchEndpointsFromRPCURL(e)))}async fetchEndpointsFromRPCURL(e){try{const t=await u.default(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:"getpeers",params:[]})});if(!t.ok)throw new Error(`Failed to fetch peers from ${e}: ${t.status} ${t.statusText}`);const a=await t.json();if("object"==typeof a&&void 0!==a.error&&"object"==typeof a.error&&"number"==typeof a.error.code&&"string"==typeof a.error.message)throw new Error(a.error);a.result.connected.map(e=>{const{address:t,port:a}=e;let s=new h.Address6(t).canonicalForm();return null==s&&(s=h.Address6.fromAddress4(t).canonicalForm()),{host:null==s?"":s,port:a}}).filter(e=>!x.has(e.host)).map(e=>o.createEndpoint({type:"tcp",host:e.host,port:e.port})).forEach(e=>this.network.addEndpoint(e))}catch(t){f.error({name:"neo_protocol_fetch_endpoints_error",[c.Labels.HTTP_URL]:e,err:t},"Failed to fetch endpoints from "+e)}}onMessageReceived(e,t){try{new Promise(async a=>{switch(t.value.command){case g.Command.addr:this.onAddrMessageReceived(t.value.payload);break;case g.Command.block:await this.onBlockMessageReceived(e,t.value.payload);break;case g.Command.consensus:await this.onConsensusMessageReceived(t.value.payload);break;case g.Command.filteradd:this.onFilterAddMessageReceived(e,t.value.payload);break;case g.Command.filterclear:this.onFilterClearMessageReceived(e);break;case g.Command.filterload:this.onFilterLoadMessageReceived(e,t.value.payload);break;case g.Command.getaddr:this.onGetAddrMessageReceived(e);break;case g.Command.getblocks:await this.onGetBlocksMessageReceived(e,t.value.payload);break;case g.Command.getdata:await this.onGetDataMessageReceived(e,t.value.payload);break;case g.Command.getheaders:await this.onGetHeadersMessageReceived(e,t.value.payload);break;case g.Command.headers:await this.onHeadersMessageReceived(e,t.value.payload);break;case g.Command.inv:this.onInvMessageReceived(e,t.value.payload);break;case g.Command.mempool:this.onMemPoolMessageReceived(e);break;case g.Command.tx:await this.onTransactionReceived(t.value.payload);break;case g.Command.verack:this.onVerackMessageReceived(e);break;case g.Command.version:this.onVersionMessageReceived(e);break;case g.Command.alert:case g.Command.merkleblock:case g.Command.notfound:case g.Command.ping:case g.Command.pong:case g.Command.reject:break;default:c.utils.assertNever(t.value)}a()}).catch(()=>{})}catch(e){}}onAddrMessageReceived(e){e.addresses.filter(e=>!x.has(e.host)).map(e=>o.createEndpoint({type:"tcp",host:e.host,port:e.port})).forEach(e=>this.network.addEndpoint(e))}async onBlockMessageReceived(e,t){const a=this.mutableBlockIndex[e.endpoint];this.mutableBlockIndex[e.endpoint]=Math.max(t.index,void 0===a?0:a),await this.relayBlock(t)}async persistBlock(e){if(!(this.blockchain.currentBlockIndex>e.index||this.tempKnownBlockHashes.has(e.hashHex)||this.mutableKnownBlockHashes.has(e.hash))){this.tempKnownBlockHashes.add(e.hashHex);try{if(void 0===await this.blockchain.block.tryGet({hashOrIndex:e.hash}))try{await this.blockchain.persistBlock({block:e}),void 0!==this.mutableConsensus&&this.mutableConsensus.onPersistBlock();const t=this.mutableBestPeer;void 0!==t&&e.index>t.data.startHeight&&this.relay(this.createMessage({command:g.Command.inv,payload:new b.InvPayload({type:b.InventoryType.Block,hashes:[e.hash]})})),f.info({name:"neo_relay_block",[c.Labels.NEO_BLOCK_INDEX]:e.index})}catch(t){throw f.error({name:"neo_relay_block",[c.Labels.NEO_BLOCK_INDEX]:e.index,err:t}),t}this.mutableKnownBlockHashes.add(e.hash),this.mutableKnownHeaderHashes.add(e.hash),e.transactions.forEach(e=>{delete this.mutableMemPool[e.hashHex],this.mutableKnownTransactionHashes.add(e.hash)})}finally{this.tempKnownBlockHashes.delete(e.hashHex)}}}async onConsensusMessageReceived(e){const{consensus:t}=this;void 0!==t&&(await this.blockchain.verifyConsensusPayload(e),t.onConsensusPayloadReceived(e))}onFilterAddMessageReceived(e,t){void 0!==e.data.mutableBloomFilter&&e.data.mutableBloomFilter.insert(t.data)}onFilterClearMessageReceived(e){e.data.mutableBloomFilter=void 0}onFilterLoadMessageReceived(t,a){t.data.mutableBloomFilter=(({filter:t,k:a,tweak:s})=>new l.default({vData:e.from(t),nHashFuncs:a,nTweak:s}))(a)}onGetAddrMessageReceived(e){const t=m.default.take(m.default.shuffle(this.network.connectedPeers.map(e=>e.data.address).filter(c.utils.notNull)),200);t.length>0&&this.sendMessage(e,this.createMessage({command:g.Command.addr,payload:new b.AddrPayload({addresses:t})}))}async onGetBlocksMessageReceived(e,t){const a=await this.getHeaders(t,this.blockchain.currentBlockIndex);this.sendMessage(e,this.createMessage({command:g.Command.inv,payload:new b.InvPayload({type:b.InventoryType.Block,hashes:a.map(e=>e.hash)})}))}async onGetDataMessageReceived(e,t){switch(t.type){case b.InventoryType.Transaction:await Promise.all(t.hashes.map(async t=>{let a=this.mutableMemPool[n.common.uInt256ToHex(t)];void 0===a&&(a=await this.blockchain.transaction.tryGet({hash:t})),void 0!==a&&this.sendMessage(e,this.createMessage({command:g.Command.tx,payload:a}))}));break;case b.InventoryType.Block:await Promise.all(t.hashes.map(async t=>{const a=await this.blockchain.block.tryGet({hashOrIndex:t});void 0!==a&&(void 0===e.data.mutableBloomFilter?this.sendMessage(e,this.createMessage({command:g.Command.block,payload:a})):this.sendMessage(e,this.createMessage({command:g.Command.merkleblock,payload:this.createMerkleBlockPayload({block:a,flags:a.transactions.map(t=>this.testFilter(e.data.mutableBloomFilter,t))})})))}));break;case b.InventoryType.Consensus:t.hashes.forEach(t=>{const a=this.consensusCache.get(n.common.uInt256ToHex(t));void 0!==a&&this.sendMessage(e,this.createMessage({command:g.Command.consensus,payload:a}))});break;default:c.utils.assertNever(t.type)}}async onGetHeadersMessageReceived(e,t){const a=await this.getHeaders(t,this.blockchain.currentHeader.index);this.sendMessage(e,this.createMessage({command:g.Command.headers,payload:new b.HeadersPayload({headers:a})}))}async onHeadersMessageReceived(e,t){const a=t.headers.filter(e=>!this.mutableKnownHeaderHashes.has(e.hash)&&!this.tempKnownHeaderHashes.has(e.hashHex));if(a.length>0){a.forEach(e=>{this.tempKnownHeaderHashes.add(e.hashHex)});try{await this.blockchain.persistHeaders(a),a.forEach(e=>{this.mutableKnownHeaderHashes.add(e.hash)})}finally{a.forEach(e=>{this.tempKnownHeaderHashes.delete(e.hashHex)})}}this.blockchain.currentHeader.index<e.data.startHeight&&this.sendMessage(e,this.createMessage({command:g.Command.getheaders,payload:new b.GetBlocksPayload({hashStart:[this.blockchain.currentHeader.hash]})}))}onInvMessageReceived(e,t){let a;switch(t.type){case b.InventoryType.Transaction:a=t.hashes.filter(e=>!this.mutableKnownTransactionHashes.has(e)&&!this.tempKnownTransactionHashes.has(n.common.uInt256ToHex(e)));break;case b.InventoryType.Block:a=t.hashes.filter(e=>!this.mutableKnownBlockHashes.has(e)&&!this.tempKnownBlockHashes.has(n.common.uInt256ToHex(e)));break;case b.InventoryType.Consensus:a=t.hashes;break;default:c.utils.assertNever(t.type),a=[]}a.length>0&&this.sendMessage(e,this.createMessage({command:g.Command.getdata,payload:new b.InvPayload({type:t.type,hashes:a})}))}onMemPoolMessageReceived(e){this.sendMessage(e,this.createMessage({command:g.Command.inv,payload:new b.InvPayload({type:b.InventoryType.Transaction,hashes:Object.values(this.mutableMemPool).map(e=>e.hash)})}))}async onTransactionReceived(e){this.ready()&&(e.type===o.TransactionType.Miner?void 0!==this.mutableConsensus&&this.mutableConsensus.onTransactionReceived(e):await this.relayTransaction(e))}onVerackMessageReceived(e){e.close()}onVersionMessageReceived(e){e.close()}async getHeaders(e,t){let a=Promise.resolve(t);e.hashStop.equals(n.common.ZERO_UINT256)||(a=this.blockchain.header.tryGet({hashOrIndex:e.hashStop}).then(e=>void 0===e?t:Math.min(e.index,t)));const[s,r]=await Promise.all([Promise.all(e.hashStart.map(async e=>this.blockchain.header.tryGet({hashOrIndex:e}))),a]),i=m.default.head(m.default.orderBy(s.filter(c.utils.notNull),[e=>e.index]));if(void 0===i)return[];const o=i.index+1;return o>t?[]:Promise.all(m.default.range(o,Math.min(o+500,r)).map(async e=>this.blockchain.header.get({hashOrIndex:e})))}testFilter(e,t){const a=e;return void 0===a||(a.contains(t.hash)||t.outputs.some(e=>a.contains(e.address))||t.inputs.some(e=>a.contains(e.serializeWire()))||t.scripts.some(e=>a.contains(n.crypto.toScriptHash(e.verification)))||t.type===o.TransactionType.Register&&t instanceof o.RegisterTransaction&&a.contains(t.asset.admin))}createMerkleBlockPayload({block:t,flags:a}){const s=new o.MerkleTree(t.transactions.map(e=>e.hash)).trim(a),n=e.allocUnsafe(Math.floor((a.length+7)/8));for(let e=0;e<a.length;e+=1)a[e]&&(n[Math.floor(e/8)]|=1<<e%8);return new b.MerkleBlockPayload({version:t.version,previousHash:t.previousHash,merkleRoot:t.merkleRoot,timestamp:t.timestamp,index:t.index,consensusData:t.consensusData,nextConsensus:t.nextConsensus,script:t.script,transactionCount:t.transactions.length,hashes:s.toHashArray(),flags:n})}createMessage(e){return new v.Message({magic:this.blockchain.settings.messageMagic,value:e})}}}).call(this,a(26).Buffer)},1906:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var s=a(1907);Object.defineProperty(t,"Consensus",{enumerable:!0,get:function(){return s.Consensus}})},1907:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Consensus=void 0;const s=a(24),n=a(992),r=a(25),i=a(112),o=a(1908),c=a(923),d=a(1914),l=a(1915),u=a(1916),h=a(1917),m=a(1918),y=a(1919),g=n.createChild(n.nodeLogger,{component:"consensus"});t.Consensus=class{constructor({options:e,node:t}){this.mutableQueue=new l.ConsensusQueue;const a=s.common.stringToPrivateKey(e.privateKey),n=s.crypto.privateKeyToPublicKey(a),r=s.crypto.publicKeyToScriptHash(n);this.options={privateKey:a,publicKey:n,feeAddress:r,privateNet:e.privateNet},this.node=t,this.mutableConsensusContext=new d.ConsensusContext}async start(){let e=r.noopDisposable;try{return await this.pause(),this.doStart(this.options),e=r.composeDisposables(e,async()=>{await this.pause()}),e}catch(t){throw await e(),t}}onPersistBlock(){this.mutableQueue.write({type:"handlePersistBlock"})}onConsensusPayloadReceived(e){this.mutableQueue.write({type:"handleConsensusPayload",payload:e})}onTransactionReceived(e){this.mutableQueue.write({type:"handleTransactionReceived",transaction:e})}async runConsensusNow(){if(!this.options.privateNet)throw new Error("Can only force consensus on a private network.");await new Promise((e,t)=>{this.mutableQueue.write({type:"timer",promise:{resolve:e,reject:t}})})}nowSeconds(){return this.mutableConsensusContext.nowSeconds()}async fastForwardOffset(e){if(!this.options.privateNet)throw new Error("Can only fast forward on a private network.");this.mutableConsensusContext.fastForwardOffset(e)}async fastForwardToTime(e){if(!this.options.privateNet)throw new Error("Can only fast forward on a private network.");this.mutableConsensusContext.fastForwardToTime(e)}async pause(){this.clearTimer(),this.mutableQueue.done(),this.mutableQueue=new l.ConsensusQueue,void 0!==this.mutableStartPromise&&await this.mutableStartPromise}async reset(){this.mutableConsensusContext=new d.ConsensusContext}async resume(){this.doStart(this.options)}doStart(e){let t=!1;const a=this.startInternal(e).then(()=>{t=!0,this.mutableStartPromise=void 0});t||(this.mutableStartPromise=a)}async startInternal(e){g.info({name:"neo_consensus_start"},"Consensus started.");const t=await c.initializeNewConsensus({blockchain:this.node.blockchain,publicKey:e.publicKey,consensusContext:this.mutableConsensusContext});await i.AsyncIterableX.from(this.mutableQueue).pipe(o.scan(async(t,a)=>{let s;switch(a.type){case"handlePersistBlock":s=await h.handlePersistBlock({blockchain:this.node.blockchain,publicKey:e.publicKey,consensusContext:this.mutableConsensusContext});break;case"handleConsensusPayload":s=await u.handleConsensusPayload({context:t,node:this.node,privateKey:e.privateKey,payload:a.payload,consensusContext:this.mutableConsensusContext});break;case"handleTransactionReceived":s=await m.handleTransactionReceived({context:t,node:this.node,privateKey:e.privateKey,transaction:a.transaction,consensusContext:this.mutableConsensusContext});break;case"timer":s=await y.runConsensus({context:t,node:this.node,options:e,consensusContext:this.mutableConsensusContext}).catch(e=>{throw void 0!==a.promise&&a.promise.reject(e),e}),void 0!==a.promise&&a.promise.resolve();break;default:throw r.utils.assertNever(a),new Error("For TS")}return this.handleResult(s)},this.handleResult(t))).forEach(()=>{}),g.info({name:"neo_consensus_stop"},"Consensus stopped.")}handleResult(e){return void 0!==e.timerSeconds&&this.handleTimer(e.timerSeconds),e.context}handleTimer(e){this.clearTimer(),this.mutableTimer=setTimeout(()=>this.mutableQueue.write({type:"timer"}),1e3*e)}clearTimer(){void 0!==this.mutableTimer&&(clearTimeout(this.mutableTimer),this.mutableTimer=void 0)}}},1910:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RequestReceivedContext=void 0;const s=a(994),n=a(1522),r=a(1524);class i extends s.HeaderContext{constructor({viewNumber:e,myIndex:t,primaryIndex:a,expectedView:s,validators:n,blockReceivedTimeSeconds:r,transactions:i,signatures:o,header:c}){super({type:"backup",viewNumber:e,myIndex:t,primaryIndex:a,expectedView:s,validators:n,blockReceivedTimeSeconds:r,transactions:i,signatures:o,header:c})}clone({transactions:e}){return new i({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:e,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes},signatures:this.signatures})}cloneViewChanging({expectedView:e}){return new r.ViewChangingContext({previousHash:this.previousHash,blockIndex:this.blockIndex,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds})}cloneSignatureSent({signatures:e}){return new n.SignatureSentContext({type:this.type,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes},signatures:e})}cloneExpectedView({expectedView:e}){return new i({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:e,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:this.signatures,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}cloneSignatures({signatures:e}){return new i({viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:this.expectedView,validators:this.validators,blockReceivedTimeSeconds:this.blockReceivedTimeSeconds,transactions:this.transactions,signatures:e,header:{type:"existing",block:this.header,transactionHashes:this.transactionHashes}})}}t.RequestReceivedContext=i},1911:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},1912:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.cloneBlockSent=void 0;const s=a(1520);t.cloneBlockSent=function(e){return new s.BlockSentContext({type:e.type,previousHash:e.previousHash,blockIndex:e.blockIndex,viewNumber:e.viewNumber,myIndex:e.myIndex,primaryIndex:e.primaryIndex,expectedView:e.expectedView,validators:e.validators,blockReceivedTimeSeconds:e.blockReceivedTimeSeconds})}},1913:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.cloneInitial=void 0;const s=a(1521);t.cloneInitial=function(e,{type:t,previousHash:a,blockIndex:n,viewNumber:r,myIndex:i,primaryIndex:o,expectedView:c,validators:d,blockReceivedTimeSeconds:l}){return new s.InitialContext({type:t,previousHash:void 0===a?e.previousHash:a,blockIndex:void 0===n?e.blockIndex:n,viewNumber:r,myIndex:void 0===i?e.myIndex:i,primaryIndex:o,expectedView:void 0===c?e.expectedView:c,validators:void 0===d?e.validators:d,blockReceivedTimeSeconds:void 0===l?e.blockReceivedTimeSeconds:l})}},1914:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ConsensusContext=void 0;const s=a(25);t.ConsensusContext=class{constructor(){this.mutableFastForwardSeconds=0}nowSeconds(){return s.utils.nowSeconds()+this.mutableFastForwardSeconds}fastForwardOffset(e){if(!(e>=0))throw new Error("Can only fast forward to future time.");this.mutableFastForwardSeconds+=e}fastForwardToTime(e){this.fastForwardOffset(e-this.nowSeconds())}}},1915:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ConsensusQueue=void 0;class s{constructor(){this.mutableItems=[],this.mutableResolvers=[],this.mutableDoneInternal=!1}[Symbol.asyncIterator](){return this}async next(){const e=this.mutableItems.shift();return void 0!==e?"error"===e.type?Promise.reject(e.error):Promise.resolve({done:!1,value:e.value}):this.mutableDoneInternal?Promise.resolve({done:!0}):new Promise((e,t)=>{this.mutableResolvers.push({resolve:e,reject:t})})}write(e){let t=!1;"handlePersistBlock"===e.type&&(t=this.mutableItems.some(e=>"value"===e.type&&"timer"===e.value.type),this.clear()),this.push({type:"value",value:e}),t&&this.push({type:"value",value:{type:"timer"}})}error(e){this.push({type:"error",error:e})}clear(){this.mutableItems=[]}done(){this.clear(),this.mutableResolvers.forEach(({resolve:e})=>e({done:!0})),this.mutableResolvers=[],this.mutableDoneInternal=!0}push(e){if(this.mutableDoneInternal)throw new Error("ConsensusQueue already ended");const t=this.mutableResolvers.shift();if(void 0!==t){const{resolve:a,reject:s}=t;"error"===e.type?s(e.error):a({done:!1,value:e.value})}else this.mutableItems.push(e)}}t.ConsensusQueue=s},1916:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.handleConsensusPayload=void 0;const s=a(24),n=a(48),r=a(25),i=a(923),o=a(993);t.handleConsensusPayload=async({context:e,node:t,privateKey:a,payload:c,consensusContext:d})=>{const{consensusMessage:l}=c;if(c.validatorIndex===e.myIndex||c.version!==e.version||!s.common.uInt256Equal(c.previousHash,e.previousHash)||c.blockIndex!==e.blockIndex||c.validatorIndex>=e.validators.length||l.type!==n.ConsensusMessageType.ChangeView&&l.viewNumber!==e.viewNumber)return{context:e};switch(l.type){case n.ConsensusMessageType.ChangeView:return(({context:e,node:t,payload:a,consensusContext:s,message:n})=>{let r=e;const o=n.newViewNumber;if(o>r.expectedView[a.validatorIndex]){const e=[...r.expectedView];if(e[a.validatorIndex]=o,r=r.cloneExpectedView({expectedView:e}),i.checkExpectedView({context:r,viewNumber:o}))return i.initializeConsensus({node:t,context:r,viewNumber:o,consensusContext:s})}return{context:r}})({context:e,node:t,payload:c,consensusContext:d,message:l});case n.ConsensusMessageType.PrepareRequest:return(async({context:e,node:t,privateKey:a,payload:n,consensusContext:r,message:c})=>{let d=e;if("backup"!==d.type||d instanceof o.RequestReceivedContext||n.validatorIndex!==d.primaryIndex||n.timestamp>r.nowSeconds()+600)return{context:d};const l=await t.blockchain.header.get({hashOrIndex:d.previousHash});if(n.timestamp<=l.timestamp)return{context:d};const u=[];u[n.validatorIndex]=c.signature;const h=new o.RequestReceivedContext({viewNumber:d.viewNumber,myIndex:d.myIndex,primaryIndex:d.primaryIndex,expectedView:d.expectedView,validators:d.validators,blockReceivedTimeSeconds:d.blockReceivedTimeSeconds,transactions:{},signatures:u,header:{type:"new",previousHash:d.previousHash,transactionHashes:c.transactionHashes.map(e=>s.common.uInt256ToHex(e)),blockIndex:d.blockIndex,nonce:c.nonce,timestamp:n.timestamp,nextConsensus:c.nextConsensus}});if(!s.crypto.verify({message:h.header.message,signature:c.signature,publicKey:d.validators[n.validatorIndex]}))return{context:d};let m=h;for(const e of h.transactionHashes.slice(1)){const s=t.memPool[e];if(void 0!==s){const e=await i.addTransaction({context:m,node:t,privateKey:a,transaction:s,verify:!1,consensusContext:r});if(!(e.context instanceof o.RequestReceivedContext))return e;m=e.context}}const y=await i.addTransaction({context:m,node:t,privateKey:a,transaction:c.minerTransaction,verify:!0,consensusContext:r});return y.context instanceof o.RequestReceivedContext?(d=y.context,t.syncMemPool(),{context:d}):y})({context:e,node:t,privateKey:a,payload:c,consensusContext:d,message:l});case n.ConsensusMessageType.PrepareResponse:return(async({context:e,node:t,payload:a,message:n})=>{if(e instanceof o.HeaderContext&&void 0===e.signatures[a.validatorIndex]&&s.crypto.verify({message:e.header.message,signature:n.signature,publicKey:e.validators[a.validatorIndex]})){const s=[...e.signatures];s[a.validatorIndex]=n.signature;const r=e.cloneSignatures({signatures:s});return i.checkSignatures({context:r,node:t})}return{context:e}})({context:e,node:t,payload:c,message:l});default:throw r.utils.assertNever(l),new Error("For TS")}}},1917:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.handlePersistBlock=void 0;const s=a(923);t.handlePersistBlock=async({blockchain:e,publicKey:t,consensusContext:a})=>s.initializeNewConsensus({blockchain:e,publicKey:t,consensusContext:a})},1918:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.handleTransactionReceived=void 0;const s=a(923),n=a(993);t.handleTransactionReceived=async({context:e,node:t,privateKey:a,transaction:r,consensusContext:i})=>e instanceof n.RequestReceivedContext&&void 0===e.transactions[r.hashHex]&&e.transactionHashesSet.has(r.hashHex)?s.addTransaction({context:e,node:t,privateKey:a,transaction:r,verify:!0,consensusContext:i}):{context:e}},1919:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.runConsensus=void 0;const s=a(18),n=a(24),r=a(48),i=a(25),o=s.__importDefault(a(69)),c=s.__importDefault(a(29)),d=a(923),l=a(993);t.runConsensus=async({context:e,node:t,options:{privateKey:a,feeAddress:s,privateNet:u},consensusContext:h})=>{if("primary"===e.type&&!(e instanceof l.RequestSentContext)){let m;if(e instanceof l.SignatureSentContext)m=e.cloneRequestSent();else{const i=r.utils.randomUInt64();let d=Object.values(t.memPool);const u=await(async({node:e,feeAddress:t,transactions:a,nonce:s})=>{const n=await r.Block.calculateNetworkFee(e.blockchain.feeContext,a),i=n.isZero()?[]:[new r.Output({asset:e.blockchain.settings.utilityToken.hash,value:n,address:t})];return new r.MinerTransaction({nonce:s.mod(r.utils.UINT_MAX.addn(1)).toNumber(),outputs:i})})({node:t,feeAddress:s,transactions:d,nonce:i});if(d.length>=t.blockchain.settings.maxTransactionsPerBlock){const e=await Promise.all(d.map(async e=>{const a=await e.getNetworkFee(t.blockchain.feeContext);return[e,new o.default(a.toString(10))]}));e.sort(([e,t],[a,s])=>s.div(a.size).comparedTo(t.div(e.size))),d=c.default.take(e,t.blockchain.settings.maxTransactionsPerBlock-1).map(([e,t])=>e)}d.unshift(u);const[y,g]=await Promise.all([t.blockchain.header.get({hashOrIndex:e.previousHash}),t.blockchain.getValidators(d)]),p=new l.RequestSentContext({viewNumber:e.viewNumber,myIndex:e.myIndex,primaryIndex:e.primaryIndex,expectedView:e.expectedView,validators:e.validators,blockReceivedTimeSeconds:e.blockReceivedTimeSeconds,transactions:d.reduce((e,t)=>Object.assign(Object.assign({},e),{[t.hashHex]:t}),{}),signatures:[],header:{type:"new",previousHash:e.previousHash,transactionHashes:d.map(e=>e.hashHex),blockIndex:e.blockIndex,nonce:i,timestamp:Math.max(h.nowSeconds(),y.timestamp+1),nextConsensus:n.crypto.getConsensusAddress(g)}}),v=[];v[p.myIndex]=n.crypto.sign({message:p.header.message,privateKey:a}),m=p.cloneSignatures({signatures:v})}if(u)return d.checkSignatures({node:t,context:m});d.signAndRelay({context:m,node:t,privateKey:a,consensusMessage:new r.PrepareRequestConsensusMessage({viewNumber:m.viewNumber,nonce:m.header.consensusData,nextConsensus:m.header.nextConsensus,transactionHashes:m.transactionHashes.map(e=>n.common.hexToUInt256(e)),minerTransaction:i.utils.nullthrows(m.transactions[m.transactionHashes[0]]),signature:i.utils.nullthrows(m.signatures[m.myIndex])})});const{secondsPerBlock:y}=t.blockchain.settings;return{context:m,timerSeconds:y<<m.viewNumber+1}}return e instanceof l.RequestSentContext||"backup"===e.type?(({context:e,node:t,privateKey:a,consensusContext:s})=>{let n=e;n=n.cloneExpectedView({expectedView:d.incrementExpectedView(n)}),d.signAndRelayChangeView({context:n,node:t,privateKey:a});const r=n.expectedView[n.myIndex];if(d.checkExpectedView({context:n,viewNumber:r}))return d.initializeConsensusInitial({blockchain:t.blockchain,context:n,viewNumber:r,consensusContext:s});const{secondsPerBlock:i}=t.blockchain.settings;return{context:n,timerSeconds:i<<r+1}})({context:e,node:t,privateKey:a,consensusContext:h}):{context:e}}},1935:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RelayStrippedTransactionMismatch=t.InvalidRelayStrippedTransactionType=t.AlreadyConnectedError=t.NegotiationError=void 0;const s=a(25);t.NegotiationError=s.makeErrorWithCode("NEGOTIATION",(e,t)=>`Negotiation failed. Unexpected message received: ${e.value.command}${void 0===t?"":". "+t}`),t.AlreadyConnectedError=s.makeErrorWithCode("ALREADY_CONNECTED",e=>"Negotiation failed: "+e),t.InvalidRelayStrippedTransactionType=s.makeErrorWithCode("INVALID_TRANSACTION_TYPE_FOR_STRIPPED_RELAY",e=>`tried to use relayStrippedTransaction on a ${e} transaction`),t.RelayStrippedTransactionMismatch=s.makeErrorWithCode("RELAY_STRIPPED_TRANSACTION_MISMATCH",()=>"verificationTransaction and relayTransaction weren't identical transactions")},1936:function(e,t,a){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.MessageTransform=t.InvalidMessageTransformEncodingError=t.Message=t.PAYLOAD_MAX_SIZE=t.COMMAND_LENGTH=void 0;const s=a(24),n=a(48),r=a(25),i=a(948),o=a(1533),c=a(1534);t.COMMAND_LENGTH=12,t.PAYLOAD_MAX_SIZE=33554432;const d=e=>s.common.toUInt32LE(s.crypto.hash256(e)),l=({context:e,reader:a})=>{if(a.readUInt32LE()!==e.messageMagic)throw new s.InvalidFormatError(`Expected BinaryReader readUInt32LE(0) to equal ${e.messageMagic}. Received: ${e.messageMagic}`);const n=o.assertCommand(a.readFixedString(t.COMMAND_LENGTH)),r=a.readUInt32LE();if(r>t.PAYLOAD_MAX_SIZE)throw new s.InvalidFormatError(`Expected buffer readout to be less than max payload size of ${t.PAYLOAD_MAX_SIZE}. Received: ${r}`);return{command:n,length:r,checksum:a.readUInt32LE()}};class u{constructor({magic:e,value:t}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.magic=e,this.value=t}static deserializeWireBase(e){const{reader:t,context:a}=e,{command:i,length:u,checksum:h}=l(e),m=t.readBytes(u),y=d(m);if(y!==h)throw new s.InvalidFormatError(`Expected payloadBuffer checksum to be ${h}. Received: ${y}`);const g={context:e.context,buffer:m};let p;switch(i){case o.Command.addr:p={command:o.Command.addr,payload:c.AddrPayload.deserializeWire(g)};break;case o.Command.block:p={command:o.Command.block,payload:n.Block.deserializeWire(g)};break;case o.Command.consensus:p={command:o.Command.consensus,payload:n.ConsensusPayload.deserializeWire(g)};break;case o.Command.filteradd:p={command:o.Command.filteradd,payload:c.FilterAddPayload.deserializeWire(g)};break;case o.Command.filterclear:p={command:o.Command.filterclear};break;case o.Command.filterload:p={command:o.Command.filterload,payload:c.FilterLoadPayload.deserializeWire(g)};break;case o.Command.getaddr:p={command:o.Command.getaddr};break;case o.Command.getblocks:p={command:o.Command.getblocks,payload:c.GetBlocksPayload.deserializeWire(g)};break;case o.Command.getdata:p={command:o.Command.getdata,payload:c.InvPayload.deserializeWire(g)};break;case o.Command.getheaders:p={command:o.Command.getheaders,payload:c.GetBlocksPayload.deserializeWire(g)};break;case o.Command.headers:p={command:o.Command.headers,payload:c.HeadersPayload.deserializeWire(g)};break;case o.Command.inv:p={command:o.Command.inv,payload:c.InvPayload.deserializeWire(g)};break;case o.Command.mempool:p={command:o.Command.mempool};break;case o.Command.tx:p={command:o.Command.tx,payload:n.deserializeTransactionWire(g)};break;case o.Command.verack:p={command:o.Command.verack};break;case o.Command.version:p={command:o.Command.version,payload:c.VersionPayload.deserializeWire(g)};break;case o.Command.alert:p={command:o.Command.alert};break;case o.Command.merkleblock:p={command:o.Command.merkleblock,payload:c.MerkleBlockPayload.deserializeWire(g)};break;case o.Command.notfound:p={command:o.Command.notfound};break;case o.Command.ping:p={command:o.Command.ping};break;case o.Command.pong:p={command:o.Command.pong};break;case o.Command.reject:p={command:o.Command.reject};break;default:throw r.utils.assertNever(i),new s.InvalidFormatError("")}return new this({magic:a.messageMagic,value:p})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(a){const{value:n}=this;a.writeUInt32LE(this.magic),a.writeFixedString(n.command,t.COMMAND_LENGTH);let i=e.alloc(0);switch(n.command){case o.Command.addr:case o.Command.block:case o.Command.consensus:case o.Command.filteradd:i=n.payload.serializeWire();break;case o.Command.filterclear:break;case o.Command.filterload:i=n.payload.serializeWire();break;case o.Command.getaddr:break;case o.Command.getblocks:case o.Command.getdata:case o.Command.getheaders:case o.Command.headers:case o.Command.inv:i=n.payload.serializeWire();break;case o.Command.mempool:break;case o.Command.tx:i=n.payload.serializeWire();break;case o.Command.verack:break;case o.Command.version:i=n.payload.serializeWire();break;case o.Command.alert:break;case o.Command.merkleblock:i=n.payload.serializeWire();break;case o.Command.notfound:case o.Command.ping:case o.Command.pong:case o.Command.reject:break;default:throw r.utils.assertNever(n),new s.InvalidFormatError("Command does not exist")}a.writeUInt32LE(i.length),a.writeUInt32LE(d(i)),a.writeBytes(i)}}t.Message=u,t.InvalidMessageTransformEncodingError=r.makeErrorWithCode("INVALID_MESSAGE_TRANSFORM_ENCODING",e=>e);const h=s.IOHelper.sizeOfUInt32LE+s.IOHelper.sizeOfFixedString(t.COMMAND_LENGTH)+s.IOHelper.sizeOfUInt32LE+s.IOHelper.sizeOfUInt32LE;class m extends i.Transform{constructor(t){super({readableObjectMode:!0}),this.context=t,this.mutableBuffer=e.from([])}_transform(a,s,r){if("string"==typeof a)throw new t.InvalidMessageTransformEncodingError("Invalid Message Transform Chunk Type. Expected chunk type to be 'string', found: "+typeof a);if("buffer"!==s)throw new t.InvalidMessageTransformEncodingError("Invalid Message Transform Encoding. Expected: 'buffer', found: "+s);this.mutableBuffer=e.concat([this.mutableBuffer,a]);try{const{remainingBuffer:e,mutableMessages:t}=this.processBuffer(new n.BinaryReader(this.mutableBuffer));this.mutableBuffer=e,t.forEach(e=>this.push(e)),r(void 0)}catch(e){r(e)}}processBuffer(e){if(e.remaining<h)return{remainingBuffer:e.remainingBuffer,mutableMessages:[]};const{length:t}=l({context:this.context,reader:e.clone()});if(e.remaining<h+t)return{remainingBuffer:e.remainingBuffer,mutableMessages:[]};const a=u.deserializeWireBase({context:this.context,reader:e}),{remainingBuffer:s,mutableMessages:n}=this.processBuffer(e);return n.push(a),{remainingBuffer:s,mutableMessages:n}}}t.MessageTransform=m}).call(this,a(26).Buffer)},1937:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AddrPayload=void 0;const s=a(24),n=a(48),r=a(1535);t.AddrPayload=class{constructor({addresses:e}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.addresses=e}static deserializeWireBase(e){const{reader:t}=e;return new this({addresses:t.readArray(()=>r.NetworkAddress.deserializeWireBase(e))})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeArray(this.addresses,t=>t.serializeWireBase(e))}}},1938:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FilterAddPayload=void 0;const s=a(24),n=a(48);t.FilterAddPayload=class{constructor({data:e}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.data=e}static deserializeWireBase({reader:e}){return new this({data:e.readVarBytesLE(520)})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeVarBytesLE(this.data)}}},1939:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FilterLoadPayload=void 0;const s=a(24),n=a(48);t.FilterLoadPayload=class{constructor({filter:e,k:t,tweak:a}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.filter=e,this.k=t,this.tweak=a}static deserializeWireBase({reader:e}){const t=e.readVarBytesLE(36e3),a=e.readUInt8(),n=e.readUInt32LE();if(a>50)throw new s.InvalidFormatError("Expected BinaryReader's readUInt8(0) to be less than 50. Received: "+a);return new this({filter:t,k:a,tweak:n})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeVarBytesLE(this.filter),e.writeUInt8(this.k),e.writeUInt32LE(this.tweak)}}},1940:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GetBlocksPayload=void 0;const s=a(24),n=a(48);t.GetBlocksPayload=class{constructor({hashStart:e,hashStop:t=s.common.ZERO_UINT256}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.hashStart=e,this.hashStop=t}static deserializeWireBase({reader:e}){return new this({hashStart:e.readArray(()=>e.readUInt256()),hashStop:e.readUInt256()})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeArray(this.hashStart,t=>{e.writeUInt256(t)}),e.writeUInt256(this.hashStop)}}},1941:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HeadersPayload=void 0;const s=a(24),n=a(48);t.HeadersPayload=class{constructor({headers:e}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.headers=e}static deserializeWireBase(e){const{reader:t}=e;return new this({headers:t.readArray(()=>n.Header.deserializeWireBase(e))})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeArray(this.headers,t=>t.serializeWireBase(e))}}},1942:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvPayload=void 0;const s=a(24),n=a(48),r=a(1536);t.InvPayload=class{constructor({type:e,hashes:t}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.type=e,this.hashes=t}static deserializeWireBase({reader:e}){return new this({type:r.assertInventoryType(e.readUInt8()),hashes:e.readArray(()=>e.readUInt256())})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeUInt8(this.type),e.writeArray(this.hashes,t=>{e.writeUInt256(t)})}}},1943:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleBlockPayload=void 0;const s=a(24),n=a(48);class r extends n.BlockBase{constructor({version:e,previousHash:t,merkleRoot:a,timestamp:r,index:i,consensusData:o,nextConsensus:c,script:d,transactionCount:l,hashes:u,flags:h}){super({version:e,previousHash:t,merkleRoot:a,timestamp:r,index:i,consensusData:o,nextConsensus:c,script:d}),this.transactionCount=l,this.hashes=u,this.flags=h,this.merkleBlockPayloadSizeInternal=n.utils.lazy(()=>super.size+s.IOHelper.sizeOfUInt32LE+s.IOHelper.sizeOfArray(this.hashes,()=>s.IOHelper.sizeOfUInt256)+s.IOHelper.sizeOfVarBytesLE(this.flags))}static deserializeWireBase(e){const{reader:t}=e,a=super.deserializeBlockBaseWireBase(e),s=t.readVarUIntLE(n.utils.INT_MAX_VALUE).toNumber(),r=t.readArray(()=>t.readUInt256()),i=t.readVarBytesLE();return new this({version:a.version,previousHash:a.previousHash,merkleRoot:a.merkleRoot,timestamp:a.timestamp,index:a.index,consensusData:a.consensusData,nextConsensus:a.nextConsensus,script:a.script,transactionCount:s,hashes:r,flags:i})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}get size(){return this.merkleBlockPayloadSizeInternal()}serializeWireBase(e){super.serializeWireBase(e),e.writeVarUIntLE(this.transactionCount),e.writeArray(this.hashes,t=>{e.writeUInt256(t)}),e.writeVarBytesLE(this.flags)}}t.MerkleBlockPayload=r},1944:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VersionPayload=t.SERVICES=void 0;const s=a(24),n=a(48),r=a(43);t.SERVICES={NODE_NETWORK:new r.BN(1)};t.VersionPayload=class{constructor({protocolVersion:e,services:t,timestamp:a,port:n,nonce:r,userAgent:i,startHeight:o,relay:c}){this.serializeWire=s.createSerializeWire(this.serializeWireBase.bind(this)),this.protocolVersion=e,this.services=t,this.timestamp=a,this.port=n,this.nonce=r,this.userAgent=i,this.startHeight=o,this.relay=c}static deserializeWireBase({reader:e}){return new this({protocolVersion:e.readUInt32LE(),services:e.readUInt64LE(),timestamp:e.readUInt32LE(),port:e.readUInt16LE(),nonce:e.readUInt32LE(),userAgent:e.readVarString(1024),startHeight:e.readUInt32LE(),relay:e.readBoolean()})}static deserializeWire(e){return this.deserializeWireBase({context:e.context,reader:new n.BinaryReader(e.buffer)})}serializeWireBase(e){e.writeUInt32LE(this.protocolVersion),e.writeUInt64LE(this.services),e.writeUInt32LE(this.timestamp),e.writeUInt16LE(this.port),e.writeUInt32LE(this.nonce),e.writeVarString(this.userAgent),e.writeUInt32LE(this.startHeight),e.writeBoolean(this.relay)}}},1945:function(e,t,a){"use strict";a.d(t,"a",(function(){return s}));class s{constructor(){this.connectedPeers=[]}blacklistAndClose(e){}start(){}stop(){}relay(e){}permanentlyBlacklist(e){}addEndpoint(e){}}},1946:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),a(18).__exportStar(a(1947),t)},1947:function(e,t,a){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0}),t.createHandler=t.JSONRPCError=void 0;const s=a(24),n=a(992),r=a(48),i=a(25),o=a(88),c=n.createChild(n.nodeLogger,{component:"rpc-handler"});class d{constructor(e,t){this.code=e,this.message=t}}t.JSONRPCError=d;const l={getaccountstate:"getaccountstate",getassetstate:"getassetstate",getbestblockhash:"getbestblockhash",getblock:"getblock",getblockcount:"getblockcount",getblockhash:"getblockhash",getblocksysfee:"getblocksysfee",getconnectioncount:"getconnectioncount",getcontractstate:"getcontractstate",getrawmempool:"getrawmempool",getrawtransaction:"getrawtransaction",getstorage:"getstorage",gettxout:"gettxout",invoke:"invoke",invokefunction:"invokefunction",invokescript:"invokescript",sendrawtransaction:"sendrawtransaction",submitblock:"submitblock",validateaddress:"validateaddress",getpeers:"getpeers",relaytransaction:"relaytransaction",relaystrippedtransaction:"relaystrippedtransaction",getoutput:"getoutput",getclaimamount:"getclaimamount",getallstorage:"getallstorage",testinvocation:"testinvocation",gettransactionreceipt:"gettransactionreceipt",getinvocationdata:"getinvocationdata",getvalidators:"getvalidators",getnetworksettings:"getnetworksettings",runconsensusnow:"runconsensusnow",updatesettings:"updatesettings",getsettings:"getsettings",fastforwardoffset:"fastforwardoffset",fastforwardtotime:"fastforwardtotime",reset:"reset",getneotrackerurl:"getneotrackerurl",resetproject:"resetproject",UNKNOWN:"UNKNOWN",INVALID:"INVALID"},u=e=>{const t=async t=>{let a={},s=l.UNKNOWN;try{let n;try{n=(e=>{if(void 0!==e&&"object"==typeof e&&"2.0"===e.jsonrpc&&void 0!==e.method&&"string"==typeof e.method&&(void 0===e.params||Array.isArray(e.params)||"object"==typeof e.params)&&(void 0===e.id||"string"==typeof e.id||"number"==typeof e.id))return e;throw new d(-32600,"Invalid Request")})(t)}finally{void 0!==n?({method:s}=n):"object"==typeof t&&({method:s}=t),void 0===l[s]&&(s=l.INVALID),a={[i.Labels.RPC_METHOD]:s}}const r=e[n.method];if(void 0===r)throw new d(-32601,"Method not found");const{params:o}=n;let u;u=void 0===o?[]:Array.isArray(o)?o:[o];const h=await r(u);return c.debug(Object.assign({name:"jsonrpc_server_single_request"},a)),{jsonrpc:"2.0",result:h,id:void 0===n.id?void 0:n.id}}catch(e){throw c.error(Object.assign(Object.assign({name:"jsonrpc_server_single_request"},a),{err:e})),e}},a=async(e,a)=>{try{let s;try{s=await(async e=>Array.isArray(e)?Promise.all(e.map(async e=>t(e))):t(e))(a),c.debug(Object.assign({name:"jsonrpc_server_request"},e))}catch(t){throw c.error(Object.assign(Object.assign({name:"jsonrpc_server_request"},e),{err:t})),t}return s}catch(e){let t={code:-32603,message:void 0===e.message?"Internal error":e.message};return void 0!==e.code&&void 0!==e.message&&"number"==typeof e.code&&"string"==typeof e.message&&(t={code:e.code,message:e.message}),{jsonrpc:"2.0",error:t,id:void 0}}};return async e=>a({[i.Labels.RPC_TYPE]:"jsonrpc"},e)},h=e=>({blockIndex:e.startHeight,blockHash:s.JSONHelper.writeUInt256(e.blockHash),transactionIndex:e.index,globalIndex:s.JSONHelper.writeUInt64(e.globalIndex)});t.createHandler=({blockchain:t,node:a,handleGetNEOTrackerURL:n,handleResetProject:i})=>{const c=e=>{if(e<0||e>t.currentBlockIndex)throw new d(-100,"Invalid Height")};return u({[l.getaccountstate]:async e=>{const a=s.crypto.addressToScriptHash({addressVersion:t.settings.addressVersion,address:e[0]});let n=await t.account.tryGet({hash:a});return void 0===n&&(n=new r.Account({hash:a})),n.serializeJSON(t.serializeJSONContext)},[l.getassetstate]:async e=>{const a=await t.asset.tryGet({hash:s.JSONHelper.readUInt256(e[0])});if(void 0===a)throw new d(-100,"Unknown asset");return a.serializeJSON(t.serializeJSONContext)},[l.getbestblockhash]:async()=>s.JSONHelper.writeUInt256(t.currentBlock.hash),[l.getblock]:async e=>{let a,n=e[0];"string"==typeof e[0]&&(n=s.JSONHelper.readUInt256(e[0])),void 0!==e[1]&&"number"==typeof e[1]&&1!==e[1]?a=e[1]:void 0!==e[2]&&"number"==typeof e[2]&&(a=e[2]);let r=await t.block.tryGet({hashOrIndex:n});if(void 0===r){if(void 0===a)throw new d(-100,"Unknown block");try{r=await t.block$.pipe(o.filter(t=>t.hashHex===e[0]||t.index===e[0]),o.take(1),o.timeout(new Date(Date.now()+a))).toPromise()}catch(e){throw new d(-100,"Unknown block")}}return!0===e[1]||1===e[1]?r.serializeJSON(t.serializeJSONContext):r.serializeWire().toString("hex")},[l.getblockcount]:async()=>t.currentBlockIndex+1,[l.getblockhash]:async e=>{const a=e[0];c(a);const n=await t.block.get({hashOrIndex:a});return s.JSONHelper.writeUInt256(n.hash)},[l.getblocksysfee]:async e=>{const a=e[0];c(a);const s=await t.header.get({hashOrIndex:a});return(await t.blockData.get({hash:s.hash})).systemFee.toString(10)},[l.getconnectioncount]:async()=>a.connectedPeers.length,[l.getcontractstate]:async e=>{const a=s.JSONHelper.readUInt160(e[0]),n=await t.contract.tryGet({hash:a});if(void 0===n)throw new d(-100,"Unknown contract");return n.serializeJSON(t.serializeJSONContext)},[l.getrawmempool]:async()=>Object.values(a.memPool).map(e=>s.JSONHelper.writeUInt256(e.hash)),[l.getrawtransaction]:async e=>{const n=s.JSONHelper.readUInt256(e[0]);let r=a.memPool[s.common.uInt256ToHex(n)];if(void 0===r&&(r=await t.transaction.tryGet({hash:n})),void 0===r)throw new d(-100,"Unknown transaction");return!0===e[1]||1===e[1]?r.serializeJSON(t.serializeJSONContext):r.serializeWire().toString("hex")},[l.getstorage]:async a=>{const n=s.JSONHelper.readUInt160(a[0]),r=e.from(a[1],"hex"),i=await t.storageItem.tryGet({hash:n,key:r});return void 0===i?void 0:i.value.toString("hex")},[l.gettxout]:async e=>{const a=s.JSONHelper.readUInt256(e[0]),n=e[1],[r,i]=await Promise.all([t.output.tryGet({hash:a,index:n}),t.transactionData.tryGet({hash:a})]);if(void 0===i||void 0===i.endHeights[n])return void 0===r?void 0:r.serializeJSON(t.serializeJSONContext,n)},[l.invoke]:async()=>{throw new d(-101,"Not implemented")},[l.invokefunction]:async()=>{throw new d(-101,"Not implemented")},[l.invokescript]:async e=>{const a=s.JSONHelper.readBuffer(e[0]),n=await t.invokeScript(a);return{result:n.result.serializeJSON(t.serializeJSONContext),actions:n.actions.map(e=>e.serializeJSON(t.serializeJSONContext))}},[l.sendrawtransaction]:async e=>{const n=r.deserializeTransactionWire({context:t.deserializeWireContext,buffer:s.JSONHelper.readBuffer(e[0])});try{return await a.relayTransaction(n,{throwVerifyError:!0,forceAdd:!0}),!0}catch(e){return!1}},[l.submitblock]:async()=>{throw new d(-101,"Not implemented")},[l.validateaddress]:async e=>{let a;try{a=s.crypto.addressToScriptHash({addressVersion:t.settings.addressVersion,address:e[0]})}catch(e){}return{address:e[0],isvalid:void 0!==a}},[l.getpeers]:async()=>({connected:a.connectedPeers.map(e=>{const{host:t,port:a}=r.getEndpointConfig(e);return{address:t,port:a}})}),[l.relaytransaction]:async e=>{const n=r.deserializeTransactionWire({context:t.deserializeWireContext,buffer:s.JSONHelper.readBuffer(e[0])});try{const[e,r]=await Promise.all([n.serializeJSON(t.serializeJSONContext),a.relayTransaction(n,{forceAdd:!0,throwVerifyError:!0})]),i=void 0===r.verifyResult?{}:{verifyResult:{verifications:r.verifyResult.verifications.map(e=>({hash:s.JSONHelper.writeUInt160(e.hash),witness:e.witness.serializeJSON(t.serializeJSONContext),actions:e.actions.map(e=>e.serializeJSON(t.serializeJSONContext)),failureMessage:e.failureMessage}))}};return Object.assign(Object.assign({},i),{transaction:e})}catch(e){throw new d(-110,"Relay transaction failed: "+e.message)}},[l.relaystrippedtransaction]:async e=>{const n=r.deserializeTransactionWire({context:t.deserializeWireContext,buffer:s.JSONHelper.readBuffer(e[0])}),i=r.deserializeTransactionWire({context:t.deserializeWireContext,buffer:s.JSONHelper.readBuffer(e[1])});try{const[e,r]=await Promise.all([i.serializeJSON(t.serializeJSONContext),a.relayStrippedTransaction(n,i,{forceAdd:!0,throwVerifyError:!0})]),o=void 0===r.verifyResult?{}:{verifyResult:{verifications:r.verifyResult.verifications.map(e=>({hash:s.JSONHelper.writeUInt160(e.hash),witness:e.witness.serializeJSON(t.serializeJSONContext),actions:e.actions.map(e=>e.serializeJSON(t.serializeJSONContext)),failureMessage:e.failureMessage}))}};return Object.assign(Object.assign({},o),{transaction:e})}catch(e){throw new d(-110,"Relay transaction failed: "+e.message)}},[l.getoutput]:async e=>{const a=s.JSONHelper.readUInt256(e[0]),n=e[1],r=await t.output.tryGet({hash:a,index:n});if(void 0===r)throw new d(-100,"Unknown output");return r.serializeJSON(t.serializeJSONContext,n)},[l.getclaimamount]:async e=>{const a=s.JSONHelper.readUInt256(e[0]),n=e[1];try{const e=await t.calculateClaimAmount([new r.Input({hash:a,index:n})]);return s.common.fixed8ToDecimal(e).toString()}catch(e){throw new d(-102,e.message)}},[l.getallstorage]:async e=>{const a=s.JSONHelper.readUInt160(e[0]);return(await t.storageItem.getAll$({hash:a}).pipe(o.toArray()).toPromise()).map(e=>e.serializeJSON(t.serializeJSONContext))},[l.testinvocation]:async e=>{const a=r.deserializeTransactionWire({context:t.deserializeWireContext,buffer:s.JSONHelper.readBuffer(e[0])});if(a instanceof r.InvocationTransaction){const e=await t.invokeTransaction(a);return{result:e.result.serializeJSON(t.serializeJSONContext),actions:e.actions.map(e=>e.serializeJSON(t.serializeJSONContext))}}throw new d(-103,"Invalid InvocationTransaction")},[l.gettransactionreceipt]:async e=>{const a=await t.transactionData.tryGet({hash:s.JSONHelper.readUInt256(e[0])});let n,r;if(void 0!==e[1]&&"number"==typeof e[1]&&(n=e[1]),void 0===a){if(void 0===n)throw new d(-100,"Unknown transaction");try{r=await t.block$.pipe(o.switchMap(async()=>{const a=await t.transactionData.tryGet({hash:s.JSONHelper.readUInt256(e[0])});return void 0===a?void 0:h(a)}),o.filter(e=>void 0!==e),o.take(1),o.timeout(new Date(Date.now()+n))).toPromise()}catch(e){throw new d(-100,"Unknown transaction")}}else r=h(a);return r},[l.getinvocationdata]:async e=>{const a=await t.transaction.get({hash:s.JSONHelper.readUInt256(e[0])}),n=await a.serializeJSON(t.serializeJSONContext);if("InvocationTransaction"!==n.type||void 0===n.invocationData)throw new d(-103,"Invalid InvocationTransaction");return n.invocationData},[l.getvalidators]:async()=>(await t.validator.all$.pipe(o.toArray()).toPromise()).map(e=>e.serializeJSON(t.serializeJSONContext)),[l.getnetworksettings]:async()=>{const e=t.settings.fees[r.TransactionType.Issue];return{issueGASFee:s.common.fixed8ToDecimal(void 0===e?s.utils.ZERO:e).toString()}},[l.runconsensusnow]:async()=>{if(!a.consensus)throw new Error("This node does not support triggering consensus.");return await a.consensus.runConsensusNow(),!0},[l.updatesettings]:async e=>{const{settings:a}=t,s=Object.assign(Object.assign({},a),{secondsPerBlock:e[0].secondsPerBlock});return t.updateSettings(s),!0},[l.getsettings]:async()=>({secondsPerBlock:t.settings.secondsPerBlock}),[l.fastforwardoffset]:async e=>{if(!a.consensus)throw new Error("This node does not support fast forwarding.");return await a.consensus.fastForwardOffset(e[0]),!0},[l.fastforwardtotime]:async e=>{if(void 0===a.consensus)throw new Error("This node does not support fast forwarding.");return await a.consensus.fastForwardToTime(e[0]),!0},[l.reset]:async()=>(void 0!==a.consensus&&(await a.consensus.pause(),await a.consensus.reset()),await a.reset(),await t.reset(),void 0!==a.consensus&&await a.consensus.resume(),!0),[l.getneotrackerurl]:async()=>n(),[l.resetproject]:async()=>(await i(),!0)})}}).call(this,a(26).Buffer)},2234:function(e,t,a){"use strict";a.d(t,"a",(function(){return l}));var s=a(1368),n=a(1071),r=a(965),i=a(1232),o=a(1857);let c;const d=async(e,t,a,r)=>{const d=await(async(e,t,a)=>{if(void 0===c){const r=new o.a(e,new s.a(new n.a({network:i.a.LOCAL_NETWORK_NAME,rpcURL:t})),a);c=r.start().then(()=>r)}return c})(e,t,a),{watchTimeoutMS:l,params:u=[]}=r;return d.handleRequest({jsonrpc:"2.0",id:1,method:r.method,params:void 0===l?u:u.concat([l])})};class l extends r.a{constructor(e){super(),this.options=e}async request(e){const t=await this.getOptions(),a=await d(t.options,this,t.build,e);return this.handleResponse(a)}async getOptions(){return this.options}}},923:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.addTransaction=t.incrementExpectedView=t.initializeConsensusInitial=t.checkExpectedView=t.signAndRelayChangeView=t.checkSignatures=t.initializeConsensus=t.initializeNewConsensus=t.getInitialContextAdd=t.signAndRelay=void 0;const s=a(18),n=a(24),r=a(48),i=a(25),o=s.__importDefault(a(29)),c=a(993);function d({context:e,blockchain:t,consensusContext:a}){if(e.myIndex<0)return{context:e};if("primary"===e.type)return{context:e,timerSeconds:Math.max(0,t.settings.secondsPerBlock-(a.nowSeconds()-e.blockReceivedTimeSeconds))};const{secondsPerBlock:s}=t.settings;return{context:e,timerSeconds:s<<e.viewNumber+1}}t.signAndRelay=({node:e,privateKey:t,context:a,consensusMessage:s})=>{const n=r.ConsensusPayload.sign(new r.UnsignedConsensusPayload({version:a.version,previousHash:a.previousHash,blockIndex:a.blockIndex,validatorIndex:a.myIndex,consensusMessage:s}),t);e.relayConsensusPayload(n)},t.getInitialContextAdd=({blockchain:e,publicKey:t,validators:a,blockReceivedTimeSeconds:s})=>{const r=e.currentBlock.index+1,i=r%a.length,c=o.default.findIndex(a,e=>n.common.ecPointEqual(e,t));return{type:i===c?"primary":"backup",previousHash:e.currentBlock.hash,blockIndex:r,viewNumber:0,myIndex:c,primaryIndex:i,expectedView:o.default.range(0,a.length).map(()=>0),validators:a,blockReceivedTimeSeconds:s}},t.initializeNewConsensus=async({blockchain:e,publicKey:t,consensusContext:a})=>{const s=await e.getValidators([]),r=e.currentBlock.timestamp,i=e.currentBlock.index+1,l=i%s.length,u=o.default.findIndex(s,e=>n.common.ecPointEqual(e,t));return d({context:new c.InitialContext({type:l===u?"primary":"backup",previousHash:e.currentBlock.hash,blockIndex:i,viewNumber:0,myIndex:u,primaryIndex:l,expectedView:o.default.range(0,s.length).map(()=>0),validators:s,blockReceivedTimeSeconds:r}),blockchain:e,consensusContext:a})};async function l({node:e,context:t}){if(t.signatures.filter(e=>void 0!==e).length>=t.M&&t.transactionHashes.every(e=>void 0!==t.transactions[e])){const a={};for(let e=0,s=0;e<t.validators.length&&s<t.M;e+=1){const r=t.validators[e],i=t.signatures[e];void 0!==i&&(a[n.common.ecPointToHex(r)]=i,s+=1)}const s=n.crypto.createMultiSignatureWitness(t.M,t.validators,a,r.Witness),o=t.header.clone({transactions:t.transactionHashes.map(e=>t.transactions[e]).filter(i.utils.notNull),script:s});return await e.relayBlock(o),{context:c.cloneBlockSent(t)}}return{context:t}}t.initializeConsensus=({node:e,context:t,viewNumber:a,consensusContext:s})=>{if(a<=0)throw new Error("Programming error");const{blockchain:n}=e;let r=t,i=(r.blockIndex-a)%r.validators.length;i<0&&(i+=r.validators.length);const o=i===r.myIndex?"primary":"backup";return r="primary"===o&&r instanceof c.SignatureSentContext?r.clone({type:o,primaryIndex:i,viewNumber:a}):c.cloneInitial(r,{type:o,primaryIndex:i,viewNumber:a}),d({blockchain:n,context:r,consensusContext:s})},t.checkSignatures=l,t.signAndRelayChangeView=({node:e,privateKey:a,context:s})=>{t.signAndRelay({node:e,privateKey:a,context:s,consensusMessage:new r.ChangeViewConsensusMessage({viewNumber:s.viewNumber,newViewNumber:s.expectedView[s.myIndex]})})},t.checkExpectedView=({context:e,viewNumber:t})=>e.viewNumber!==t&&e.expectedView.filter(e=>e===t).length>=e.M,t.initializeConsensusInitial=({blockchain:e,context:t,viewNumber:a,consensusContext:s})=>{const{primaryIndex:n,type:r}=(({context:e,viewNumber:t})=>{let a=(e.blockIndex-t)%e.validators.length;return a<0&&(a+=e.validators.length),{type:a===e.myIndex?"primary":"backup",primaryIndex:a}})({context:t,viewNumber:a});return d({blockchain:e,context:c.cloneInitial(t,{type:r,primaryIndex:n,viewNumber:a}),consensusContext:s})},t.incrementExpectedView=e=>{const t=[...e.expectedView];return t[e.myIndex]+=1,t};t.addTransaction=async({context:e,node:a,privateKey:s,transaction:o,verify:c,consensusContext:d})=>{let u=e;const{blockchain:h}=a;if(void 0!==await h.transaction.tryGet({hash:o.hash}))return{context:u};if(c){let e=!0;try{const{verifications:t}=await h.verifyTransaction({transaction:o,memPool:Object.values(u.transactions).filter(i.utils.notNull)});e=t.every(({failureMessage:e})=>void 0===e)}catch(t){e=!1}if(!e)return{context:u}}u=u.clone({transactions:Object.assign(Object.assign({},u.transactions),{[o.hashHex]:o})});const m=Object.values(u.transactions).length;if(u.transactionHashes.length===m){const e=await h.getValidators(Object.values(u.transactions).filter(i.utils.notNull)),o=n.crypto.getConsensusAddress(e);if(n.common.uInt160Equal(o,u.header.nextConsensus)){const e=[...u.signatures];e[u.myIndex]=n.crypto.sign({message:u.header.message,privateKey:s});const o=u.cloneSignatureSent({signatures:e});return t.signAndRelay({node:a,context:o,privateKey:s,consensusMessage:new r.PrepareResponseConsensusMessage({viewNumber:o.viewNumber,signature:i.utils.nullthrows(e[o.myIndex])})}),l({node:a,context:o})}return(({context:e,node:a,privateKey:s,consensusContext:n})=>{const r=e.cloneViewChanging({expectedView:t.incrementExpectedView(e)});t.signAndRelayChangeView({context:r,node:a,privateKey:s});const i=r.expectedView[r.myIndex];return t.checkExpectedView({context:r,viewNumber:i})?t.initializeConsensusInitial({blockchain:a.blockchain,context:r,viewNumber:i,consensusContext:n}):{context:r}})({context:u,node:a,privateKey:s,consensusContext:d})}return{context:u}}},924:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Context=void 0;const s=a(24);t.Context=class{constructor({type:e,previousHash:t,blockIndex:a,viewNumber:s,myIndex:n,primaryIndex:r,expectedView:i,validators:o,blockReceivedTimeSeconds:c}){this.version=0,this.type=e,this.previousHash=t,this.blockIndex=a,this.viewNumber=s,this.myIndex=n,this.primaryIndex=r,this.expectedView=i,this.validators=o,this.blockReceivedTimeSeconds=c}get M(){return Math.floor(this.validators.length-(this.validators.length-1)/3)}cloneExpectedView(e){throw new Error("Not Implemented")}toJSON(){return{class:this.constructor.name,version:this.version,type:this.type,previousHash:s.common.uInt256ToString(this.previousHash),blockIndex:this.blockIndex,viewNumber:this.viewNumber,myIndex:this.myIndex,primaryIndex:this.primaryIndex,expectedView:[...this.expectedView],validators:this.validators.map(e=>s.common.ecPointToString(e)),blockReceivedTimeSeconds:this.blockReceivedTimeSeconds}}}},93:function(e,t,a){"use strict";var s=a(94);a.d(t,"a",(function(){return s}));var n=a(95);a.d(t,"b",(function(){return n}))},94:function(e,t,a){"use strict";a.r(t),a.d(t,"transferHandlers",(function(){return o})),a.d(t,"proxy",(function(){return d})),a.d(t,"proxyValue",(function(){return l})),a.d(t,"expose",(function(){return u})),a.d(t,"isEndpoint",(function(){return p})),a.d(t,"isTransferable",(function(){return w})),a.d(t,"transferableProperties",(function(){return k}));a(50);const s=[ArrayBuffer,MessagePort],n=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER),r=Symbol("proxyValue"),i=Symbol("throw"),o=new Map([["PROXY",{canHandle:e=>e&&(e[r]||e instanceof Function),serialize:e=>{const{port1:t,port2:a}=new MessageChannel;return u(e,t),a},deserialize:e=>d(e)}],["THROW",{canHandle:e=>e&&e[i]||e instanceof Error,serialize:e=>{const t=e&&e.message,a=e&&e.stack;return Object.assign({},e,{message:t,stack:a})},deserialize:e=>{throw Object.assign(Error(),e)}}]]);let c=0;function d(e,t){if(f(e)&&(e=g(e)),!p(e))throw Error("endpoint does not have all of addEventListener, removeEventListener and postMessage defined");return v(e),function e(t,a=[],s=function(){}){return new Proxy(s,{construct:(e,s,n)=>t({type:"CONSTRUCT",callPath:a,argumentsList:s}),apply:(s,n,r)=>"bind"===a[a.length-1]?e(t,a.slice(0,-1)):t({type:"APPLY",callPath:"apply"===a[a.length-1]?a.slice(0,-1):a,argumentsList:"apply"===a[a.length-1]?r[1]:r}),get(s,n,i){if(n===r)return!0;if("then"===n&&0===a.length)return{then:()=>i};if("then"===n){const e=t({type:"GET",callPath:a});return Promise.resolve(e).then.bind(e)}return e(t,a.concat(n),s[n])},set:(e,s,n,i)=>s===r||t({type:"SET",callPath:a,property:s,value:n})})}(async t=>{let a=[];return"APPLY"!==t.type&&"CONSTRUCT"!==t.type||(a=t.argumentsList.map(h)),m((await function(e,t,a){const s=`${n}-${c++}`;return new Promise(n=>{b(e,(function t(a){a.data.id===s&&"RETURN"===a.data.type&&(!function(e,t){e.removeEventListener("message",t)}(e,t),n(a))})),t=Object.assign({},t,{id:s}),e.postMessage(t,a)})}(e,Object.assign({},t,{argumentsList:a}),k(a))).data.value)},[],t)}function l(e){return e instanceof MessagePort||(e[r]=!0),e}function u(e,t){if(f(t)&&(t=g(t)),!p(t))throw Error("endpoint does not have all of addEventListener, removeEventListener and postMessage defined");v(t),b(t,(async function(a){if(!a.data.id||!a.data.callPath)return;let s;const n=a.data;try{const t=await n.callPath.slice(0,-1).reduce((e,t)=>e[t],e);let a=[];if("APPLY"!==n.type&&"CONSTRUCT"!==n.type||(a=n.argumentsList.map(m)),"APPLY"===n.type&&(s=n.callPath.length>0?await t[n.callPath[n.callPath.length-1]](...a):await t(...a)),"CONSTRUCT"===n.type&&(s=n.callPath.length>0?await new t[n.callPath[n.callPath.length-1]](...a):await new t(...a),s=l(s)),"SET"===n.type||"GET"===n.type){const e=n.callPath.length>0?await t[n.callPath[n.callPath.length-1]]:t;"SET"===n.type?(e[n.property]=n.value,s=!0):s=e}}catch(e){s=e,s[i]=!0}return s=function(e,t){return{type:"RETURN",id:e.id,value:h(t)}}(n,s),t.postMessage(s,k([s]))}))}function h(e){for(const[t,a]of o)if(a.canHandle(e))return{type:t,value:a.serialize(e)};let t=[];!function e(t,a,s=[],n=null){if(!t)return;n||(n=new WeakSet);if(n.has(t))return;if("string"==typeof t)return;"object"==typeof t&&n.add(t);if(ArrayBuffer.isView(t))return;if(a(t,s))return;const r=Object.keys(t);for(const i of r)e(t[i],a,[...s,i],n)}(e,(e,a)=>{for(const[s,n]of o)if(n.canHandle(e))return t.push({path:a,wrappedValue:{type:s,value:n.serialize(e)}}),!0;return!1});for(const a of t){a.path.slice(0,-1).reduce((e,t)=>e[t],e)[a.path[a.path.length-1]]=null}return{type:"RAW",value:e,wrappedChildren:t}}function m(e){if(o.has(e.type)){return o.get(e.type).deserialize(e.value)}if(function(e){return"RAW"===e.type}(e)){for(const t of e.wrappedChildren||[]){if(!o.has(t.wrappedValue.type))throw Error(`Unknown value type "${e.type}" at ${t.path.join(".")}`);const a=o.get(t.wrappedValue.type).deserialize(t.wrappedValue.value);y(e.value,t.path,a)}return e.value}throw Error(`Unknown value type "${e.type}"`)}function y(e,t,a){const s=t.slice(-1)[0];t.slice(0,-1).reduce((e,t)=>e[t],e)[s]=a}function g(e){if("Window"!==self.constructor.name)throw Error("self is not a window");return{addEventListener:self.addEventListener.bind(self),removeEventListener:self.removeEventListener.bind(self),postMessage:(t,a)=>e.postMessage(t,"*",a)}}function p(e){return"addEventListener"in e&&"removeEventListener"in e&&"postMessage"in e}function v(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.start()}function b(e,t){e.addEventListener("message",t)}function f(e){return["window","length","location","parent","opener"].every(t=>t in e)}function w(e){return s.some(t=>e instanceof t)}function k(e){const t=[];for(const a of function*e(t,a=[],s=null){if(!t)return;if(s||(s=new WeakSet),s.has(t))return;if("string"==typeof t)return;if("object"==typeof t&&s.add(t),ArrayBuffer.isView(t))return;yield{value:t,path:a};const n=Object.keys(t);for(const r of n)yield*e(t[r],[...a,r],s)}(e))w(a.value)&&t.push(a.value);return t}},943:function(e,t){},946:function(e,t){},947:function(e,t){},95:function(e,t,a){"use strict";function s(e){return a=e,["postMessage","addEventListener","removeEventListener","start","close"].every(e=>e in a)?e:function(e){return["window","length","location","parent","opener"].every(t=>t in e)}(e)?function(e){if("Window"!==self.constructor.name)throw Error("self is not a window");return{addEventListener:self.addEventListener.bind(self),removeEventListener:self.removeEventListener.bind(self),postMessage:(t,a)=>e.postMessage(t,"*",a),start:()=>{},close:()=>{}}}(e):function(e){return["onmessage","postMessage","terminate","addEventListener","removeEventListener"].every(t=>t in e)}(e)?{addEventListener:(t=e).addEventListener.bind(t),removeEventListener:t.removeEventListener.bind(t),postMessage:t.postMessage.bind(t),start:()=>{},close:t.terminate.bind(t)}:function(e){return{addEventListener:e.addEventListener.bind(e),removeEventListener:e.removeEventListener.bind(e),postMessage:e.postMessage.bind(e),start:()=>{n(e)},close:()=>{e.close&&e.close()}}}(e);var t,a}function n(e){e.start&&e.start()}a.r(t),a.d(t,"getEndpoint",(function(){return s})),a.d(t,"activate",(function(){return n}))},951:function(e,t){},992:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=a(18);s.__exportStar(a(1894),t),s.__exportStar(a(1899),t)},993:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=a(18);s.__exportStar(a(924),t),s.__exportStar(a(1520),t),s.__exportStar(a(994),t),s.__exportStar(a(1521),t),s.__exportStar(a(1910),t),s.__exportStar(a(1523),t),s.__exportStar(a(1522),t),s.__exportStar(a(1524),t),s.__exportStar(a(1911),t),s.__exportStar(a(1912),t),s.__exportStar(a(1913),t)},994:function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HeaderContext=void 0;const s=a(24),n=a(48),r=a(924);class i extends r.Context{constructor({type:e,viewNumber:t,myIndex:a,primaryIndex:r,expectedView:i,validators:o,blockReceivedTimeSeconds:c,transactions:d,signatures:l,header:u}){const h="existing"===u.type?u.block.previousHash:u.previousHash,m=u.transactionHashes,y="existing"===u.type?u.block.index:u.blockIndex,g="existing"===u.type?u.block.consensusData:u.nonce,p="existing"===u.type?u.block.timestamp:u.timestamp,v="existing"===u.type?u.block.nextConsensus:u.nextConsensus;super({type:e,previousHash:h,blockIndex:y,viewNumber:t,myIndex:a,primaryIndex:r,expectedView:i,validators:o,blockReceivedTimeSeconds:c}),this.transactions=d,this.transactionHashes=m,this.transactionHashesSet=new Set(m),this.signatures=l,"existing"===u.type?this.header=u.block:this.header=new n.Block({version:this.version,previousHash:this.previousHash,merkleRoot:n.MerkleTree.computeRoot(this.transactionHashes.map(e=>s.common.hexToUInt256(e))),timestamp:p,index:this.blockIndex,consensusData:g,nextConsensus:v,transactions:[]})}cloneSignatures(e){throw new Error("Not Implemented")}toJSON(){return Object.assign(Object.assign({},super.toJSON()),{transactionHashes:this.transactionHashes.map(e=>s.common.uInt256ToString(e)),signatures:this.signatures.map(e=>void 0===e?"undefined":e.toString("hex"))})}}t.HeaderContext=i}});
//# sourceMappingURL=workers.18.fc3d1a98.js.map